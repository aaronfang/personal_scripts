string $NinjaUV_Version = "Ninja UV 4.0";
string $MayaIconFolder = `internalVar -ubd`;
string $L_Border = "L_Border";
string $R_Border = "R_Border";
string $NinjaUV_MatchUVs_Target[] = {};
string $Source_Mesh[] = {};
int $InteractiveMappingJobNumber;
int $NinjaUV_UIWidth = 250;
int $NinjaUV_FrameWidth = 255;
float $NinjaUV_ButtonColorA[] = {.6, .6, .6};
float $NinjaUV_ButtonColorB[] = {.4, .4, .4};
float $NinjaUV_FrameColor[] = {.3, .3, .3};
int $UVSymmetryJobID;
int $UVSymmetrySelectJobID;
string $LastUVCommand;
string $EditCam;
string $LeftUVArray[];
string $RightUVArray[];
string $SymmetryUVs[];
string $CopyUVs[];
string $CopyFaceUVs[];
string $UVEdgeSelection[] = {};
string $StraightenUVSelection[] = {};

global proc mentalRayLoad()
{
//check to see if plugin is loaded and if not then load it
	if (`pluginInfo -q -loaded Mayatomr` == 0)
	{
		loadPlugin Mayatomr;
		setAttr defaultRenderGlobals.currentRenderer -type "string" "mentalRay";
		miCreateDefaultNodes();
	}

	else
	{
		setAttr defaultRenderGlobals.currentRenderer -type "string" "mentalRay";
		miCreateDefaultNodes();
	}
}//end mental ray load

global proc string NinjaProjection_Attach()
{
	DeleteHistory;
	string $selected_objects[] = `ls -sl -fl -l`;
	string $Tag[] = `listConnections $selected_objects[0]`;
	$Parent = `firstParentOf $selected_objects[0]`;
	$empty_name = `ls -sl -l`;
	$base_name = `shortNameOf ($selected_objects[0])`;
	$base_pivot = `xform -q -piv -ws $selected_objects[0]`;
	string $newmesh[] = `polyUnite -ch 1 -o 1`;
	xform -piv $base_pivot[0] $base_pivot[1] $base_pivot[2] $newmesh;//move pivot to base pivots location
	DeleteHistory;
	$NewName =`rename $newmesh[0] $base_name`;//rename object to first selection

	string $NewMesh[];
	$NewMesh = `ls -sl -l`;
	if ($Parent != "")
		{
			select $NewName;
			parent  $NewName $Parent;
			$NewMesh = `ls -sl -l`;
        }


	for ($c = 0; $c < `size $selected_objects`; $c++)
		{

			//print $selected_objects[$c];
			//print $NewMesh[0];
			if(`objExists $selected_objects[$c]` == 1  && $selected_objects[$c] != $NewMesh[0]	)
			{
    			delete $selected_objects[$c];
            }

        }

	return $NewMesh[0];

}

global proc NinjaProjection_LockCamera(string $Camera)
{
	setAttr -lock true ($Camera + ".tx");
	setAttr -lock true ($Camera + ".ty");
	setAttr -lock true ($Camera + ".tz");
	setAttr -lock true ($Camera + ".rx");
	setAttr -lock true ($Camera + ".ry");
	setAttr -lock true ($Camera + ".rz");
}

global proc NinjaProjection_UnLockCamera(string $Camera)
{
	setAttr -lock false ($Camera + ".tx");
	setAttr -lock false ($Camera + ".ty");
	setAttr -lock false ($Camera + ".tz");
	setAttr -lock false ($Camera + ".rx");
	setAttr -lock false ($Camera + ".ry");
	setAttr -lock false ($Camera + ".rz");
}

global proc NinjaProjection_Render(string $Camera)
{
	RenderViewWindow;
	render -x 768 -y 576 $Camera;
}

global proc NinjaProjection_BakeTexture(string $CamShortName)
{

	mentalRayLoad;
	string $Sel[] = `ls -sl -fl -l`;
	for ($s = 0; $s < (`size $Sel`); $s++)
		{
			polyCopyUV -uvSetNameInput ("UV_" + $CamShortName) -uvSetName map1 -ch 1 $Sel[$s];
        }

	$Tex_Width = `intField -q -v  ("NinjaProjection_BakeWidth" + $CamShortName)`;
	$Tex_Height = `intField -q -v ("NinjaProjection_BakeHeight" + $CamShortName)`;

	string $Temp_Mesh[] = `duplicate -rr`;
	$Temp_Mesh = `ls -sl -fl`;
	for ($r = 0; $r < (`size $Temp_Mesh`); $r++)
		{
			rename $Temp_Mesh[$r] ("Temp_Mesh_" + $r);
		}

	$Temp_Mesh = `ls -sl -fl`;
	if (`size $Temp_Mesh` > 1)
		{
			select $Temp_Mesh;
			NinjaProjection_Attach();
			$Temp_Mesh = `ls -sl -fl -l`;

    	}
	hide $Sel;
	polyCopyUV -uvSetNameInput ("UV_" + $CamShortName) -uvSetName map1 -ch 1 $Temp_Mesh;

	select $Temp_Mesh;

	////Create Bake Set
	// check to make sure Mental Ray is setup
 	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}

	if (`objExists "ProjectionBakeSet"` == 0)
	{
		createBakeSet ProjectionBakeSet textureBakeSet;
		setAttr "ProjectionBakeSet.colorMode" 0;
		setAttr "ProjectionBakeSet.xResolution" $Tex_Width;
		setAttr "ProjectionBakeSet.yResolution" $Tex_Height;
		setAttr "ProjectionBakeSet.bakeToOneMap" 1;
		//setAttr -type "string" ProjectionBakeSet.prefix ($CamShortName + "_Projection");
		setAttr "ProjectionBakeSet.fileFormat" 6;
	}


	sets -forceElement ProjectionBakeSet `ls -dag -objectsOnly -geometry -selection`;//assign set to object

	////////////////////////Set Ouput Directory


	select $Temp_Mesh;
	string $TexturePath;
	//$TexturePath = eval ("NinjaUV_SetBakeDirectory Projection");
	$MayaLocation = `internalVar -uad`;
	sysFile -md ($MayaLocation + "NinjaBake");
	string $BakeFiles[] = `getFileList -fld ($MayaLocation + "NinjaBake/") -fs "*.tga"`;
	string $Projection_Array[] = {};
	for ($b = 0 ;$b < `size $BakeFiles`; $b++)
		{
			if (endsWith ($BakeFiles[$b], "_Projection.tga") == 1)
			{
				stringArrayInsertAtIndex(0, $Projection_Array, $BakeFiles[$b]);
            }

        }

	int $count = `size $Projection_Array`;
	$TexturePath = ($MayaLocation + "/NinjaDojo/NinjaBake/" + ($CamShortName ) + $count + ".tga");

	$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
	$Projection_Name = substituteAllString ($TextureName, ".", "_Projection.");
	string $buf[];
	$numTokens = `tokenize $Projection_Name "." $buf`;
	string $FileName = $buf[0];
	setAttr -type "string" ProjectionBakeSet.prefix ($Texture_Directory + $FileName ) ;
	////////////////////////End Set Ouput Directory

	convertLightmapSetup  -camera $CamShortName -keepOrgSG -showcpv;

	$ShaderName = ("Baked_" + $CamShortName);
	int $Total_BakedProjection;
	if (`objExists ("SG_" + $ShaderName + "*")` == 1)
		{
			select ("SG_" + $ShaderName + "*");
			string $SelMat_Baked[] = `ls -sl -fl`;
			$Total_BakedProjection = `size $SelMat_Baked`;
		}

	else
	{
		$Total_BakedProjection = 0;
	}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_" + $ShaderName + $Total_BakedProjection)`;//create a Shading Group node
		string $Mat_Name = `shadingNode  -asShader blinn -name ("Mat_" + $ShaderName + $Total_BakedProjection )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_" + $ShaderName + $Total_BakedProjection) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_" + $ShaderName  + $Total_BakedProjection)  -asUtility place2dTexture`;//create uv node

		//error;
		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Texture_Directory + $FileName + ".tga");//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

		$ApplyMaterial =  `checkBox -q -v ApplyProjectionBakedMater`;
		if ($ApplyMaterial == 1)
		{
			sets -e -forceElement $SG_Name $Sel;//assign material to object

        }


	delete   $Temp_Mesh;
	showHidden $Sel;
	//return ($Color_Name + ".tga");
}

global proc NinjaProjection_ApplyBakeTexture(string $CamShortName)
{
	$Sel = `ls -sl -fl -l`;
	print $CamShortName;
	sets -e -forceElement ("SG_Baked" + $CamShortName) $Sel;//assign material to object
}


global proc NinjaProjection_CameraMapping(string $Camera)
{
	$Sel = `ls -sl -fl -l`;
	catchQuiet (`polyUVSet -d -uvSet ("UV_" + $Camera) $Sel`);
 	polyUVSet -create -uvSet ("UV_" + $Camera)  $Sel;

	$UVType = `radioButtonGrp -q -select UVProjectionType`;

	if ($UVType == 1)
	{
		for ($i = 0 ;$i < `size $Sel`; $i++)

		{
			polyCopyUV -uvSetNameInput map1  -uvSetName ("UV_" + $Camera) -ch 1 $Sel[$i];

        }
    }

	if ($UVType == 2)
	{
		$CamImagePlane = `listConnections -type "imagePlane" $Camera`;

		//Layout Test 2
		//create and rotate temp plane
		string $CameraShape[] = `ls -o -dag -ni -type "camera" $Camera`;
		float $PolyWidth = `getAttr ($CameraShape[0] +".horizontalFilmAperture")`;
		float $PolyHeight = `getAttr ($CameraShape[0] +".verticalFilmAperture")`;

		$TempPlane = `polyPlane -n "Temp Projection Plane" -ch on -o on -ax 0 0 1 -w $PolyWidth -h $PolyHeight -sw 1 -sh 1 -cuv 2 `;
		$TargetRotation = `xform -q -ro $Camera`;
		$TargetPosition = `xform -q -ws -piv $Camera`;

		move -ws $TargetPosition[0] $TargetPosition[1] $TargetPosition[2] $TempPlane;
		rotate -ws $TargetRotation[0] $TargetRotation[1] $TargetRotation[2] $TempPlane;
		//adjust depth position
		move -r -os -wd 0 0 (-100) Temp_Projection_Plane;

		//adjust scale of temp plane
		$FocalLength = `getAttr ($CameraShape[0] + ".focalLength")`;
		$Scale = ((254/$FocalLength) * 10 );
		scale -a $Scale $Scale $Scale  $TempPlane;

		polyUVSet -create -uvSet ("UV_" + $Camera)  $TempPlane;

		select $Sel $TempPlane;
		ConvertSelectionToFaces;
		$Faces = `ls -sl -fl`;

		polyProjection -ch 1 -type Planar -ibd on -kir  -md c  -uvs ("UV_" + $Camera) $Faces;

		polyUVSet -cuv -uvSet ("UV_" + $Camera) $Sel $TempPlane;
		delete $TempPlane;
	}

	if ($UVType == 3)
	{
		ConvertSelectionToFaces;
		$Faces = `ls -sl -fl`;
		polyProjection -type Planar -md p -uvs ("UV_" + $Camera) $Faces;
		polyUVSet -cuv -uvSet ("UV_" + $Camera) $Sel;

		for ($c = 0 ;$c < `size $Sel`; $c++)
			{
				select $Sel[$c];
				polyLayoutUV -lm 1 -sc 1 -se 2 -rbf 0 -fr 1 -ps 0.8 -l 2 -ch 1 ;

			}

		select $Sel;
		polyMultiLayoutUV -lm 0 -sc 1 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 0 -su 1 -sv 1 -ou 0 -ov 0;

    }

	if ($UVType == 4)
	{
		ConvertSelectionToFaces;
		$Faces = `ls -sl -fl`;
		polyProjection -type Planar -md p -uvs ("UV_" + $Camera) $Faces;
		polyUVSet -cuv -uvSet ("UV_" + $Camera) $Sel;

    }

	select $Sel;

}

global proc NinjaProjection_EditMapping(string $Camera)
{
	TextureViewWindow;
	polyUVSet -cuv -uvSet ("UV_" + $Camera) ;
}

global proc NinjaProjection_ImagePlane(string $CameraName)
{

	string $CamParent[] = `listRelatives -p $CameraName`;
	if (`objExists ("ImagePlane_" + $CamParent[0])` == 0)
	{

		// create a new image plane
		string $ImagePlane = `createNode -n ("ImagePlane_" + $CamParent[0]) imagePlane`;

		// assign the imageplane to the camera
		cameraImagePlaneUpdate $CameraName $ImagePlane;

		string $ProjectionConnection[] =`listConnections -type "projection" $CameraName`;
		string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
		$TexturePath = `getAttr ($TextureNode[0] + ".fileTextureName")`;
		setAttr -type "string" ($ImagePlane + ".imageName") $TexturePath;
		setAttr ($ImagePlane + ".useDepthMap") 1;
    }

	else
	{
		$ImagePlane = ("ImagePlane_" + $CamParent[0]);
		string $ProjectionConnection[] =`listConnections -type "projection" $CameraName`;
		string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
		$TexturePath = `getAttr ($TextureNode[0] + ".fileTextureName")`;
		setAttr -type "string" ($ImagePlane + ".imageName") $TexturePath;
		setAttr ($ImagePlane + ".useDepthMap") 1;
    }


}

global proc NinjaProjection_RemoveImagePlane(string $CameraName)
{
	string $Camera[] = `ls -o -dag -ni -type "camera" $CameraName`;
	string $ProjectionConnection[] =`listConnections -type "imagePlane" $Camera[0]`;
	if (`size $ProjectionConnection` != 0)
			{
				print $ProjectionConnection[0];
				delete $ProjectionConnection[0];
				//string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
				//catchQuiet ($IconImage = `getAttr ($TextureNode[0] + ".fileTextureName")`);
            }


}

global proc NinjaProjection_BuildCameraAttr()
{

	$NinjaProjection_UIWidth = 250;

	$ChildUI =`columnLayout -q -ca CameraAttributeParent`;
	deleteUI $ChildUI;

	string $SelCameraList[] = `textScrollList -q -si sceneCameraList`;
	string $Camera[] = `ls -o -dag -ni -type "camera" $SelCameraList[0]`;
	//select $SelCameraList[0];

	string $KeyableAttributeArray[] = `listAttr -k $Camera[0]`;

	columnLayout -p CameraAttributeParent ;
		columnLayout;
		for ($a = 0; $a < (`size $KeyableAttributeArray`) ; $a++)
				{
				 	catchQuiet (`attrFieldSliderGrp -pre 2 -cw 1 120 -cw 2 50 -cw 3 50  -minValue -100.0 -maxValue 100.0 -fieldMinValue -100000.0 -fieldMaxValue 100000.0
					-at ($SelCameraList[0] + "." + $KeyableAttributeArray[$a])`);
				}
		setParent..;
	setParent..;//parent scrollLayout
}



global proc NinjaProjection_SelectCam()
{
	if ((`window -ex NinjaProjectionCamWindow`) == true)
	{
		deleteUI NinjaProjectionCamWindow;
	}

	string $SelCameraList[] = `textScrollList -q -si sceneCameraList`;
	///Rebuild the Camera window
	$Ninja_ProjectionWindow = `window -t "NinjaProjectionCamWindow" -wh 640 480 "NinjaProjectionCamWindow"`;
	string $pnlLayout = `paneLayout`;
	string $mdlPanel = `modelPanel`;
	showWindow $Ninja_ProjectionWindow;
	lookThroughModelPanelClipped $SelCameraList[0] $mdlPanel  0.001 10000;

	camera -e -displayFilmGate on -displayResolution off -overscan 1.3 $SelCameraList[0];

	//$CamName = `firstParentOf $CameraName`;
	//$CamShortName = `shortNameOf $CamName`;
	//select $SelCameraList[0];
	//NinjaProjection_BuildCameraAttr;
}

global proc NinjaProjection_DeleteCam()
{

	string $SelCameraList[] = `textScrollList -q -si sceneCameraList`;
	delete $SelCameraList[0];
	NinjaProjection_RefreshCameraList;

	string $SelCameraList[] = `textScrollList -q -ai sceneCameraList`;
	textScrollList -e -si $SelCameraList[0] sceneCameraList;
}

global proc NinjaProjection_ImageFile(string $CamShortName)
{

	fileBrowserDialog -m 0 -in $CamShortName -fc ("NinjaProjection_SetCamImage") -an ("NinjaProjection_SetCamImage" ) -ft $CamShortName -wt "Image File"  ;

}

global proc NinjaProjection_SetCamImage(string $FileName, string $FileType)
{

 	//print $FileType;
	NinjaProjection_CreateShader $FileName $FileType;
	NinjaProjection_BuildCameraEdit;


}

global proc NinjaProjection_AdjustFocalLength(string $CamShortName, float $Amount)
{
	//print $CamShortName;
	string $CameraShape[] = `ls -o -dag -ni -type "camera" $CamShortName`;
	float $CurrentFocalLength = `floatField  -q -v ("CameraFocalLength" + $CamShortName)`;
	setAttr ($CameraShape[0] + ".focalLength")  ($CurrentFocalLength + $Amount);
	floatField  -e -v ($CurrentFocalLength + $Amount) ("CameraFocalLength" + $CamShortName);
}


global proc NinjaProjection_CreateShader(string $ImageFileName, string $CameraName)
{

		$ShaderName = "pCam1";
		string $CameraShape[] = `ls -o -dag -ni -type "camera" $CameraName`;
		string $ProjectionConnection[] =`listConnections -type "projection" $CameraShape`;

		string $Mat_Name;

		if (`size $ProjectionConnection` == 0)
		{
			$SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_" + $CameraName)`;//create a Shading Group node
			$Mat_Name = `shadingNode -asShader blinn -name ("Mat_" + $CameraName)` ;//create a material node
			string $ColorTextureNode = `shadingNode -name ("Tex_" + $CameraName) -asTexture file`;//create texture node
			string $ProjectionNode = `shadingNode -name ("Proj_" + $CameraName) -asUtility projection`;
			string $ColorUVNode = `shadingNode -name ("UV_" + $CameraName)  -asUtility place2dTexture`;//create uv node
			connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node

			string $UVAttr[] = {"stagger", "coverage", "translateFrame", "rotateFrame", "mirrorU" ,"mirrorV", "wrapU", "wrapV", "repeatUV", "rotateUV", "noiseUV", "vertexUvOne" , "vertexUvTwo", "vertexUvThree", "vertexCameraOne", "uvFilterSize"};

			for ($a = 0; $a <`size $UVAttr`; $a++)
					{
						connectAttr -f ($ColorUVNode + "." + $UVAttr[$a])  ($ColorTextureNode + "." + $UVAttr[$a]);//connects uv node to texture node

					}

			connectAttr -f ($ColorUVNode + ".uv")  ($ColorTextureNode + ".uvCoord");//connects uv node to texture node
			connectAttr -f ($ColorUVNode + ".outUV")  ($ColorTextureNode + ".uvCoord");//connects uv node to texture node

			connectAttr -force ($ColorTextureNode  + ".outColor") ($ProjectionNode + ".image");//connects texture node to Projection Node
			connectAttr -force ($ProjectionNode  + ".outColor") ($Mat_Name + ".color");//connects projection node to Shading Node

			setAttr -type "string" ($ColorTextureNode + ".fileTextureName") ($ImageFileName);//assign texture to texture node
			setAttr ($ProjectionNode + ".projType") 8;
			//string $CameraShape[] = `ls -o -dag -ni -type "camera" $CameraName`;
			connectAttr -f ($CameraShape[0] + ".message" ) ($ProjectionNode + ".linkedCamera");//connect camera to projection node
			catchQuiet (linkProjToCamera ($ProjectionNode + ".linkedCamera") );
			refreshAE;

		}


		else
		{
			string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
			setAttr -type "string" ($TextureNode[0] + ".fileTextureName") ($ImageFileName);//assign texture to texture node
        }


		//Adjust Camera Aspect Ratio
		string $ProjectionConnection[] =`listConnections -type "projection" $CameraShape`;
		string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
		float $TexWidth  = `getAttr ($TextureNode[0] + ".outSizeX")`;
		float $TexHeight = `getAttr ($TextureNode[0] + ".outSizeY")`;
		$AspectRatio = ($TexWidth/$TexHeight);
		setAttr ($CameraShape[0] + ".verticalFilmAperture") 1;
		setAttr ($CameraShape[0] + ".horizontalFilmAperture") $AspectRatio;

		//string $CameraShape[] = `ls -o -dag -ni -type "camera" $FileType`;
		NinjaProjection_ImagePlane $CameraShape[0];

}

global proc NinjaProjection_AssignShader(string $Camera)
{

	$Sel = `ls -sl -fl -l`;
	string $ProjectionConnection[] =`listConnections $Camera`;
	print $ProjectionConnection;
		if (`size $ProjectionConnection` != 0)
			{
				string $SurfaceShader[] = `listConnections -type "blinn" $ProjectionConnection[0]`;
				print $SurfaceShader;
				string $ShadingEngine[] = `listConnections  -type "shadingEngine" $SurfaceShader[0]`;
				sets -e -forceElement $ShadingEngine[0] $Sel;//assign material to object
            }
}


global proc NinjaProjection_RefreshImage(string $Camera)
{

	string $ProjectionConnection[] =`listConnections -type "projection" $Camera`;
		if (`size $ProjectionConnection` != 0)
			{
				string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
				$IconImage = `getAttr ($TextureNode[0] + ".fileTextureName")`;
				setAttr -type "string" ($TextureNode[0] + ".fileTextureName") $IconImage;
            }
}


global proc NinjaProjection_RefreshCameraList()

{
	$Cameras = `ls -ca`;
	textScrollList -e -ra sceneCameraList;

	for ($i = 0 ;$i < `size $Cameras`; $i++)

		{
			$CamName = `firstParentOf $Cameras[$i]`;
			$CamShortName = `shortNameOf $CamName`;
			textScrollList -e -append $CamShortName sceneCameraList;
      	}

}

global proc NinjaProjection_BuildCameraEdit()

{

	string $CameraList[] = `textScrollList -q -ai sceneCameraList`;
	//print $CameraList;
	string $SelCameraList[] = `textScrollList -q -si sceneCameraList`;
	//print $SelCameraList[0];
	string $Camera[] = `ls -o -dag -ni -type "camera" $SelCameraList[0]`;
	//print $Camera;
	select $Camera;

	string $IconImage = "view.xpm";
	$CamName = `firstParentOf $Camera[0]`;
	$CamShortName = `shortNameOf $CamName`;
	//print $CamShortName;

	string $ProjectionConnection[] =`listConnections -type "projection" $Camera[0]`;
		if (`size $ProjectionConnection` != 0)
			{
				string $TextureNode[] = `listConnections -type "file" $ProjectionConnection[0]`;
				catchQuiet ($IconImage = `getAttr ($TextureNode[0] + ".fileTextureName")`);
            }

		//deleteUI CameraEdit;
		$ChildUI = `columnLayout -q -ca CameraUI_Parent`;
		deleteUI $ChildUI;
		columnLayout -p CameraUI_Parent ;

				textFieldButtonGrp -label "" -text $CamShortName -buttonLabel "Rename" -cw3 1 150 1 -bc ("NinaProjection_RenameCamera " + $CamShortName) ("icon_PcamName_" + $CamShortName);
				rowColumnLayout -nc 2 -cw 1 128  -cw 2 120 ;
					iconTextButton -rpt 1 -style "iconOnly" -w 128 -h 128 -image1 $IconImage -label $CamShortName
					-c("select " + $CamShortName + ";" + "NinjaProjection_BuildCameraAttr")
					-dcc ("NinjaProjection_SelectCam") ("iconTextButton -rpt 1_" + $CamShortName);
					popupMenu;
						menuItem -l "Set Image" -c ("NinjaProjection_ImageFile " + $CamShortName);
						menuItem -l "Refresh Image" -c ("NinjaProjection_RefreshImage " + $Camera[0]);
						menuItem -l "Lock Camera" -c ("NinjaProjection_LockCamera " + $CamShortName);
						menuItem -l "UnLock Camera" -c ("NinjaProjection_UnLockCamera " + $CamShortName);
						//menuItem -l "Delete Camera" -c ("NinjaProjection_DeleteCam " + $CamShortName);
    				//button -l "Set Image" -w 100 -h 100;

					columnLayout;
						button -l "Set Projection Image" 		-w 120 -h 20 -c ("NinjaProjection_ImageFile " + $CamShortName);
						button -l "Refresh Image" 	-w 120 -h 20 -c ("NinjaProjection_RefreshImage " + $Camera[0]);
						button -l "Apply Projection Shader" 	-w 120 -h 20 -c ("NinjaProjection_AssignShader " + $Camera[0]);
						button -l "Create Image Plane" 	-w 120 -h 20 -c ("NinjaProjection_ImagePlane " + $Camera[0]);
						button -l "Remove Image Plane" 	-w 120 -h 20 -c ("NinjaProjection_RemoveImagePlane " + $Camera[0]);
						button -l "Edit Projection UV's" 		-w 120 -h 20 -c ("NinjaProjection_EditMapping " + $CamShortName);
						//button -l "" 	-w 90 -h 20 -c (" " + $Cameras[$c]);
						//button -l "" 	-w 90 -h 20 -c (" " + $Cameras[$c]);
					setParent..;//columnLayout
				setParent..;//rowColumnLayout

				rowColumnLayout -nc 4 -cw 1 75  -cw 2 75 -cw 3 50 -cw 4 50 ;
					$CamFocalLength = `getAttr ($CamName + ".focalLength")`;
					text -l "Focal Length";
					floatField  -v $CamFocalLength -cc ("NinjaProjection_AdjustFocalLength " + $CamShortName + " " + 0) ("CameraFocalLength" + $CamShortName);
					button -l "<" -c ("NinjaProjection_AdjustFocalLength " + $CamShortName + " " + -0.5);
					button -l ">" -c ("NinjaProjection_AdjustFocalLength " + $CamShortName + " " + 0.5);
				setParent..;//rowColumnLayout

				radioButtonGrp -numberOfRadioButtons 4  -label "" -labelArray4 "map1" "Planar" "Layout" "Camera" -select 1 -columnWidth5 1 55 55 55 55 UVProjectionType;
				button -l "Create projection UV's " -w 240 -c ("NinjaProjection_CameraMapping " + $CamShortName);

				rowColumnLayout -nc 2 -cw 1 120  -cw 2 120 ;
					intField -v 1024 ("NinjaProjection_BakeWidth" + $CamShortName);
					intField -v 1024 ("NinjaProjection_BakeHeight" + $CamShortName);
					checkBox -l "apply material" -v 0 ApplyProjectionBakedMater;
					button -l "Bake Texture " -w 120 -c ("NinjaProjection_BakeTexture " + $CamShortName);
				setParent..;//rowColumnLayout


				//button -l "Bake Texture " -w 240 -c ("NinjaProjection_BakeTexture " + $CamShortName);
				//button -l "Apply Baked Texture Material " -w 240 -c ("NinjaProjection_ApplyBakeTexture " + $CamShortName);
				button -l "Render Projection View" 	-w 240 -h 25 -c ("NinjaProjection_Render " + $Camera[0]);


	setParent..;//columnLayout


}

global proc NinaProjection_RenameCamera(string $CamShortName)
{
	$NewName = `textFieldButtonGrp -q -tx ("icon_PcamName_" + $CamShortName)`;
	textFieldButtonGrp -e -tx $NewName ("icon_PcamName_" + $CamShortName);
	rename $CamShortName $NewName;

	NinjaProjection_RefreshCameraList();

}

global proc NinjaProjection_CreateCamera()
{
	$pCamName = `textField -q -tx Ninja_pCamName`;

	string $NinjaProjectionCam[];

	$NinjaProjectionCam = `camera -name $pCamName`;
	float $perspRotation[] = `xform -q -ro persp`;
	float $perspPosition[] = `xform -q -t persp`;
	xform -r -ro  $perspRotation[0] $perspRotation[1] $perspRotation[2] $NinjaProjectionCam[0];
	xform -t $perspPosition[0] $perspPosition[1] $perspPosition[2] $NinjaProjectionCam[0];
	NinjaProjection_RefreshCameraList;
	textScrollList -e -si $NinjaProjectionCam sceneCameraList;
	NinjaProjection_BuildCameraEdit;
}

global proc Ninja_Projection()//Legacy Procedure
{

	if ((`window -ex Ninja_Projection_UI`) == true) deleteUI Ninja_Projection_UI;
	$Ninja_UV_Window = `window -title "Ninja Projection v1.0" -width 250 Ninja_Projection_UI`;

		Build_Ninja_Projection_UI 1;

	showWindow Ninja_Projection_UI;
	//TextureViewWindow;

}//end quickmapper UI

global proc NinjaUV_SelectByFaceAngle()
{
	string $Sel[] = `ls -sl -fl -l`;
	string $Objects[] = `ls -hl -l`;
	string $FaceArray[] = {};
	string $SelectArray[] = {};
	//string $ReferenceAngle = `textField -q -tx textField_NinjaMeshTargetFace`;


	for ($f = 0;$f < `size $Sel`; $f++)
		{
			if ( stringArrayContains($Sel[$f],$FaceArray) == 0)
			{
				string $buf[] = {};
				$numTokens = `tokenize $Sel[$f] "." $buf`;
				$FaceObject = $buf[0];

				//get face normal
				string $FaceNormal[] = `polyInfo -fn $Sel[$f]`;
				string $Normal[] = stringToStringArray($FaceNormal[0], " ");
				float $NormalX = $Normal[2];
				float $NormalY = $Normal[3];
				float $NormalZ = $Normal[4];
				vector $faceNormal = << $NormalX, $NormalY, $NormalZ >>;  // vector creation
				$matrix = `xform -q -ws -m $FaceObject`; //position of the object in world space
				float $worldspaceVec[] = pointMatrixMult($faceNormal, $matrix);

				$Angle = `intField -q -v int_NinjaUVAngleSelect`;

				select $FaceObject;
				ConvertSelectionToFaces;
				doMenuComponentSelection($buf[0], "facet");
				polySelectConstraint -m 2 -o 1 -ob $Angle 0 -oa $worldspaceVec[0] $worldspaceVec[1] $worldspaceVec[2] -type 0x0008;
				string $SelFaces[] = `ls -sl -fl -l`;

				//print $SelFaces;
				$FaceArray = stringArrayCatenate($FaceArray, $SelFaces);
				polySelectConstraint -m 0;

          }

        }
	//print $FaceArray;
	select $FaceArray;
	for ($o = 0;$o < `size $Objects`; $o++)
		{
			doMenuComponentSelection($Objects[$o], "facet");
        }

}

global proc NinjaUV_FindOverlappingUVs()
{
	string $UVShell_Array[] = eval ("NinjaUV_CollectShells");

	string $OverlappingUVs = {};

	for ($s = 0; $s < `size $UVShell_Array`; $s++)
		{
			string $Single_Shell[];
			tokenize $UVShell_Array[$s] "," $Single_Shell;


		}


}

global proc float NinjaUV_GetUVEdgeDist(string $UVA, string $UVB)
{
	float $PointA[] = `polyEditUV -q $UVA`;
	float $PointB[] = `polyEditUV -q $UVB`;

  	float $Xdist = ($PointA[0] - $PointB[0]);
	float $Ydist = ($PointA[1] - $PointB[1]);

	$Distance = `sqrt (($Xdist*$Xdist) + ($Ydist*$Ydist))`;

	return $Distance;
}

global proc float NinjaUV_CalcuateUVArea()
{
	$Selection = `ls -sl -fl -l`;
	//$TempMesh = `duplicate -rr $Selection`;
	$TempHist = `polyTriangulate -ch 1 $Selection`;

	$Faces = `ls -sl -fl -l`;
	float $CalculatedAreas[] = {};
	for ($a = 0; $a < `size $Faces`; $a++)
	{
		$TriangleToUV = `polyListComponentConversion -toUV $Faces[$a]`;
		$UVs = `ls -fl -l $TriangleToUV`;

		float $DistA =  eval ("NinjaUV_GetUVEdgeDist " +  $UVs[0] + " " + $UVs[1]);
		float $DistB =  eval ("NinjaUV_GetUVEdgeDist " +  $UVs[0] + " " + $UVs[2]);
		float $DistC =  eval ("NinjaUV_GetUVEdgeDist " +  $UVs[1] + " " + $UVs[2]);

		$HalfPerimerter = (($DistA + $DistB + $DistC) /2);
		$Area = `sqrt ( $HalfPerimerter * (($HalfPerimerter - $DistA) * ($HalfPerimerter - $DistB) * ($HalfPerimerter - $DistC)) )`;
		$CalculatedAreas[$a] = $Area;
		//print $Area;
    }

	float $TotalArea = 0;
	for ($t = 0; $t < `size $CalculatedAreas`; $t++)
	{
		$TotalArea = ($TotalArea + $CalculatedAreas[$t]);
    }

	print (($TotalArea * 100) + " percent is being used");
	delete $TempHist;
	//delete $TempMesh;
	select $Selection;
	return $TotalArea;
}

global proc float NinjaUV_GetFaceEdgeDist(string $UVA, string $UVB)
{
	float $PointA[] = `xform -q -ws -t $UVA`;
	float $PointB[] = `xform -q -ws -t $UVB`;

  	float $Xdist = ($PointA[0] - $PointB[0]);
	float $Ydist = ($PointA[1] - $PointB[1]);
	float $Zdist = ($PointA[2] - $PointB[2]);

	$Distance = `sqrt (($Xdist*$Xdist) + ($Ydist*$Ydist) + ($Zdist*$Zdist))`;

	return $Distance;
}

global proc float NinjaUV_CalcuateFaceArea()
{
	$Selection = `ls -sl -fl -l`;
	$TempMesh = `duplicate -rr $Selection`;
	polyTriangulate -ch 1 $TempMesh;

	$Faces = `ls -sl -fl -l`;
	float $CalculatedAreas[] = {};
	for ($a = 0; $a < `size $Faces`; $a++)
	{
		$TriangleToUV = `polyListComponentConversion -toUV $Faces[$a]`;
		$UVs = `ls -fl -l $TriangleToUV`;

		float $DistA =  eval ("NinjaUV_GetFaceEdgeDist " +  $UVs[0] + " " + $UVs[1]);
		float $DistB =  eval ("NinjaUV_GetFaceEdgeDist " +  $UVs[0] + " " + $UVs[2]);
		float $DistC =  eval ("NinjaUV_GetFaceEdgeDist " +  $UVs[1] + " " + $UVs[2]);
		$HalfPerimerter = (($DistA + $DistB + $DistC) /2);
		$Area = `sqrt ( $HalfPerimerter * (($HalfPerimerter - $DistA) * ($HalfPerimerter - $DistB) * ($HalfPerimerter - $DistC)) )`;
		$CalculatedAreas[$a] = $Area;
		//print $Area;
    }

	float $TotalArea = 0;
	for ($t = 0; $t < `size $CalculatedAreas`; $t++)
	{
		$TotalArea = ($TotalArea + $CalculatedAreas[$t]);
    }

	print $TotalArea;
	//print (($TotalArea * 100) + " percent is being used");
	delete $TempMesh;
	select $Selection;
	return $TotalArea;
}

global proc NinjaUV_CalculateUVStreching()
{
	$Selection = `ls -sl -fl -l`;
	ConvertSelectionToEdges;
	$Edges = `ls -sl -fl -l`;

 	float $RatioArray[] = {};

	for ($a = 0; $a < `size $Edges`; $a++)
	{
		$EdgeToUV = `polyListComponentConversion -toUV $Edges[$a]`;
		$UVs = `ls -fl -l $EdgeToUV`;

		float $EdgeDistA =  eval ("NinjaUV_GetFaceEdgeDist " +  $UVs[0] + " " + $UVs[1]);
		float $UVDistA =  eval ("NinjaUV_GetUVEdgeDist " +  $UVs[0] + " " + $UVs[1]);

		$Ratio = ($EdgeDistA / $UVDistA);
		$RatioArray[$a] = $Ratio;
		//print ($Ratio + "\n");
    }

	float $SortedRatioArray[] = `sort $RatioArray`;
	float $Min = $SortedRatioArray[0];
	float $Max = $SortedRatioArray[(`size $SortedRatioArray` -1)];


	$RatioRange = ($Max - $Min);
	print ($Min + "\n" + $Max) ;

	//print $RatioArray;
	polyColorPerVertex -r 0 -g 1 -b 0 -a 1 -cdo $Selection;
	for ($b = 0; $b < `size $Edges`; $b++)
	{
		$EdgeToVerts = `polyListComponentConversion -toVertex $Edges[$b]`;
		string $Verts[] = `ls -fl -l $EdgeToVerts`;
		float $Difference = ($RatioArray[$b] - $Min);
		$Difference = `abs $Difference`;
		//print $Difference;
		if ($Difference > ($RatioRange /2))
		{
			polyColorPerVertex -r 1 -g 0 -b 0 -a 1 -cdo $Verts;
        }
    }

}


global proc NinjaUV_RandomizeTileUVs ()
{
	float $TileU = `intField -q -v RandTileU`;
	float $TileV = `intField -q -v RandTileV`;

	ConvertSelectionToUVs;
	$StartSelection = `ls -sl -fl -l`;
	string $Shells[] = NinjaUV_CollectShells();

	progressBar -edit -pr 0 RandomizeUV_progress;
	progressBar -edit -maxValue (`size $Shells`) RandomizeUV_progress;
	for ($a = 0; $a < `size $Shells`; $a++)
	{
		int $RandU = `rand 0 ($TileU )`;
		int $RandV = `rand 0 ($TileV )`;

		float $MoveU = 0.0;
		float $MoveV = 0.0;

		$MoveU = ((1.0 / $TileU) * $RandU);
       	$MoveV = ((1.0 / $TileV) * $RandV);

		string $Single_Shell[];
		tokenize $Shells[$a] "," $Single_Shell;
		polyNormalizeUV -normalizeType 1 -preserveAspectRatio off $Single_Shell;
		polyEditUV -pu 0 -pv 0 -su (1/$TileU) -sv (1/$TileV) -u $MoveU -v $MoveV $Single_Shell;

		progressBar -edit -step 1 RandomizeUV_progress;
    }

	select $StartSelection;
}

global proc NinjaUV_RandomizeUVs ()
{
	float $RandMaxU = `floatField -q -v RandMaxU`;
	float $RandMaxV = `floatField -q -v RandMaxV`;

	ConvertSelectionToUVs;
	$StartSelection = `ls -sl -fl -l`;
	string $Shells[] = NinjaUV_CollectShells();
	progressBar -edit -pr 0 RandomizeUV_progress;
	progressBar -edit -maxValue (`size $Shells`) RandomizeUV_progress;

	for ($a = 0; $a < `size $Shells`; $a++)
	{
		float $RandU = `rand ($RandMaxU * -1) ($RandMaxU * 1)`;
		float $RandV = `rand ($RandMaxV * -1) ($RandMaxV * 1)`;

		string $Single_Shell[];
		tokenize $Shells[$a] "," $Single_Shell;

		polyEditUV -u $RandU -v $RandV $Single_Shell;
		progressBar -edit -step 1 RandomizeUV_progress;
    }
	select $StartSelection;
}

global proc NinjaUV_CopyPasteUV(string $Action)
{
	global string $CopyUVs[];
	if ($Action == "Copy")
	{
		ConvertSelectionToUVs;
		$CopyUVs = `ls -sl -fl -l`;

    }

	if ($Action == "Paste")
	{
		ConvertSelectionToUVs;
		$SelUV = `ls -sl -fl -l`;
		//$SelUV = `sort $SelUV`;
		for ($p = 0; $p < `size $SelUV`; $p++)
		{
			float $NewU[] = `polyEditUV -r 0 -q -u $CopyUVs[$p]`;
			float $NewV[] = `polyEditUV -r 0 -q -v $CopyUVs[$p]`;

			//pause -sec 1;
			polyEditUV -r 0 -u $NewU[0] -v $NewV[1] $SelUV[$p];
			//select $SelUV[$p];

        }
		select $SelUV;
		//NinjaUV_QuickFix;
    }
}

global proc NinjaUV_MirrorUV(string $direction)
{
	PolySelectConvert 4;
	float $UVextents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax

	$UVCenterX = (($UVextents[0] + $UVextents[1]) /2);
	$UVCenterY = (($UVextents[2] + $UVextents[3]) /2);

	if ($direction == "-U" )
	{
		polyEditUV -pu $UVextents[0] -pv 0.5 -su -1 -sv 1;
    }

	if ($direction == "U" )
	{
		polyEditUV -pu $UVextents[1] -pv 0.5 -su -1 -sv 1;
    }

	if ($direction == "-V")
	{
		polyEditUV -pu .5  -pv $UVextents[2] -su 1 -sv -1;
    }

	if ($direction == "V" )
	{
		polyEditUV -pu .5 -pv $UVextents[3] -su 1 -sv -1;
    }

	if ($direction == "CenterU" )
	{
		polyEditUV -pu $UVCenterX -pv $UVCenterY -su -1 -sv 1;
    }

	if ($direction == "CenterV" )
	{
		polyEditUV -pu $UVCenterX  -pv $UVCenterY -su 1 -sv -1;
    }
}

global proc NinjaUV_LiveMappingStart()
{
	global int $LiveMappingJobID;

	$ButtonState = `button -q -l  button_LiveMapping`;
	if ($ButtonState == "Start Live Mapping")
		{
			//$UVSymmetrySelectJobID = `scriptJob -e SelectionChanged ("NinjaUV_SymmetrySelect " + $SelUVs[0]) -p frame_UV_MirrorUV`;
			$LiveMappingJobID = `scriptJob -e SelectionChanged ("NinjaUV_LiveMapping") -p frame_UV_MirrorUV`;
			button -e -l "Stop Live Mapping" -bgc 1 0 0 button_LiveMapping;
		}

	if ($ButtonState == "Stop Live Mapping")
		{

			button -e -l "Start Live Mapping" -bgc 0 1 0 button_LiveMapping;
			scriptJob -k $LiveMappingJobID;
		}

}
global proc NinjaUV_LiveMapping()
{
	$SelObj = `ls -hl -l`;
	$CutEdges = `filterExpand -sm 32 -fp 1`;
	$Selection = `ls -sl -fl -l`;
	if (`size $CutEdges` != 0)
	{
		NinjaUV_NinjaMapping;
		doMenuComponentSelection($SelObj[0], "edge");

    }

	select $Selection;
}

global proc NinjaUV_SymmetryStart()
{
	global int $NinjaUV_UIWidth;
	global int $UVSymmetryJobID;
	global int $UVSymmetrySelectJobID;
	string $SelUVs[] = `filterExpand -sm 35`;
	$ButtonState = `button -q -l  button_StartSymmetry`;
	if (`size $SelUVs` != 0)
	{
		//PolySelectConvert 4;//convert to uv's

		global string $LeftUVArray[];
		global string $RightUVArray[];

		$LeftUVArray = {};
		polySelectBorderShell 0;
		string $UVShellSelection[] = `ls -sl -fl -l`;

		float $UVMirrorPoint[] = `polyEditUV -q -u $SelUVs[0]`;//xmin xmax ymin ymax
		for ($s = 0; $s < (`size $UVShellSelection`); $s++)
			{

				float $UVExtents[] = `polyEditUV -q -u $UVShellSelection[$s]`;//xmin xmax ymin ymax
				if ($UVExtents[0] < $UVMirrorPoint[0])
					{
						stringArrayInsertAtIndex(0, $LeftUVArray, $UVShellSelection[$s]);
					}
				else
					{
						stringArrayInsertAtIndex(0, $RightUVArray, $UVShellSelection[$s]);
					}
			}

		//print $LeftUVArray;
		select $SelUVs;

		if ($ButtonState == "Start Symmetry Mapping")
		{

			$UVSymmetrySelectJobID = `scriptJob -e SelectionChanged ("NinjaUV_SymmetrySelect " + $SelUVs[0]) -p frame_UV_MirrorUV`;
			$UVSymmetryJobID = `scriptJob -e idle ("NinjaUV_Symmetry") -p frame_UV_MirrorUV`;
			button -e -l "Stop Symmetry Mapping" -w $NinjaUV_UIWidth -bgc 1 0 0 button_StartSymmetry;
		}
    }

		if ($ButtonState == "Stop Symmetry Mapping")
		{
			scriptJob -k $UVSymmetrySelectJobID;
			scriptJob -k $UVSymmetryJobID;
			button -e -l "Start Symmetry Mapping" -w $NinjaUV_UIWidth -bgc  0 1 0 button_StartSymmetry;
		}


}

global proc NinjaUV_SymmetrySelect(string $MirrorPoint)
{
	global string $LeftUVArray[];
	global string $SymmetryUVs[];
	$SymmetryUVs = {};
	$SelUV = `ls -sl -fl -l`;
	float $SymmetryPointU[] =  `polyEditUV -q -u $MirrorPoint`;//xmin xmax ymin ymax
	float $SymmetryPointV[] =  `polyEditUV -q -u $MirrorPoint`;//xmin xmax ymin ymax

	$SelectBuffer = 0.01;
	for ($a = 0; $a < `size $SelUV`; $a++)
		{

			float $SelUVExtentU[] = `polyEditUV -q -u $SelUV[$a]`;//xmin xmax ymin ymax
			float $SelUVExtentV[] = `polyEditUV -q -v $SelUV[$a]`;//xmin xmax ymin ymax
			float $Udist = ($SelUVExtentU[0] - $SymmetryPointU[0]);

			float $SelDistance = sqrt($Udist * $Udist);
			for ($b = 0; $b < `size $LeftUVArray`; $b++)
				{

					float $LeftUVExtentU[] = `polyEditUV -q -u $LeftUVArray[$b]`;//xmin xmax ymin ymax
					float $LeftUVExtentV[] = `polyEditUV -q -v $LeftUVArray[$b]`;//xmin xmax ymin ymax
				 	float $Udist = ($LeftUVExtentU[0] - $SymmetryPointU[0]);
					float $LeftDistance = sqrt($Udist * $Udist);


					//Calculate the Buffer Distance
					$UDifference = ($LeftDistance - $SelDistance);
					$UBufferDist = sqrt($UDifference * $UDifference);

					$VDifference = ($LeftUVExtentV[1] - $SelUVExtentV[1]);
					$VBufferDist = sqrt($VDifference * $VDifference);

					if ( $UBufferDist <= $SelectBuffer  && $VBufferDist <= $SelectBuffer)
					 {
						stringArrayInsertAtIndex(0, $SymmetryUVs, $LeftUVArray[$b]);
					 }
				}
		}

	$SymmetryUVs = `stringArrayRemoveDuplicates $SymmetryUVs`;

}

global proc NinjaUV_Symmetry()
{
	global string $LastUVCommand;
	global string $SymmetryUVs[];
	global int $UVSymmetryJobID;
	global int $UVSymmetrySelectJobID;

	string $Command = `undoInfo -q -un`;

	if (`size $Command` != 0 && ($LastUVCommand != $Command) && startsWith ($Command, "polyEditUV") && `size $SymmetryUVs` != 0 ) //&& `columnLayout -q -vis Ninja_UV` == 1
	{
		string $CommandArray[] = stringToStringArray ($Command, " ");
		float $Udist = $CommandArray[2];
		float $Vdist = $CommandArray[4];
		polyEditUV -u ($Udist *-1) -v $Vdist  $SymmetryUVs;//move uvs when symmetry uv's are selected
		//polyEditUV -u ($Udist * -2) -v (-$Vdist + $Vdist)  $SymmetryUVs;//move uvs when symmetry uv's are selected
		$LastUVCommand = $Command;

    }
}


global proc NinjaUV_ColorUVShells()
{
	$StartSelection = `ls -fl -fl -l`;
	string $ColorSets[] = `polyColorSet -q -allColorSets`;
	string $NinjaUVColorSet = "";
	for ($c = 0; $c < `size $ColorSets`; $c++)
		{
			if ($ColorSets[$c] == "NinjaUVColorizeShell")
			{
				polyColorSet -currentColorSet -colorSet "NinjaUVColorizeShell" ;
				$NinjaUVColorSet = "NinjaUVColorizeShell";
			}
		}


	if ($NinjaUVColorSet == "")
	{
		polyColorSet -create -clamped 0 -rpt RGBA -colorSet "NinjaUVColorizeShell";
	}

	string $UVShell_Array[] = eval ("NinjaUV_CollectShells");
	for ($s = 0; $s < `size $UVShell_Array`; $s++)
		{
			string $Single_Shell[];
			tokenize $UVShell_Array[$s] "," $Single_Shell;
			select -r $Single_Shell;
			$Faces = `polyListComponentConversion -toFace  $Single_Shell`;
			$Faces = `ls -fl -l $Faces`;//flatten edge array
			//ConvertSelectionToFaces;
			int $randomRed = `rand 0 10`;
			int $randomGreen = `rand 0 10`;
			int $randomBlue = `rand 0 10`;
			polyColorPerVertex -r ($randomRed * .1) -g ($randomGreen * .1) -b ($randomBlue * .1) -a 1 -cdo $Faces;
		}

	select $StartSelection;
}

global proc string[] NinjaUV_RandomUVShellsShaders()
{
	//delete "NinjaRandomColorShader*";
	string $DeleteArray[] = {};
	$ObjSelection = `ls -sl -fl -l`;
	polyOptions  -displayMapBorder 0 -colorMaterialChannel "ambientDiffuse" -sizeBorder 5.0 -activeObjects;
	$RandomColors = `checkBox -q -v cb_Assign_RandomColors`;

	if ($RandomColors == 1)
	{
		for ($i = 0; $i < `size $ObjSelection`; $i++)
			{
				select $ObjSelection[$i];
				string $UVShell_Array[] = eval ("NinjaUV_CollectShells");
				for ($s = 0; $s < `size $UVShell_Array`; $s++)
					{
						string $Single_Shell[];
						tokenize $UVShell_Array[$s] "," $Single_Shell;
						select -r $Single_Shell;

						ConvertSelectionToFaces;
						string $ShellFaces[] = `ls -sl -fl -l`;


						int $randomRed;
						int $randomGreen;
						int $randomBlue;

						$randomRed = `rand 0 10`;
						$randomGreen = `rand 0 10`;
						$randomBlue = `rand 0 10`;

						//create and assign shader
						$ColorShader = `shadingNode -name "NinjaRandomColorShader" -asShader surfaceShader`;
						string $NewSG_Name = `sets -renderable true -noSurfaceShader true -empty -name ($ColorShader + "SG")`;//create a Shading Group node
						connectAttr -force ($ColorShader  + ".outColor") ($NewSG_Name + ".surfaceShader");//connects material node to Shading Group node
						setAttr ($ColorShader + ".outColor") -type double3 ($randomRed * .1) ($randomGreen *.1) ($randomBlue * .1);
						sets -e -forceElement $NewSG_Name $ShellFaces;//assign material to faces

						//add shaders to delete array to delete after bake
						stringArrayInsertAtIndex (0,$DeleteArray, $ColorShader);
						stringArrayInsertAtIndex (0,$DeleteArray, $NewSG_Name);
					}

			}//end for i
	}

	else
	{
		ConvertSelectionToFaces;
		string $ShellFaces[] = `ls -sl -fl -l`;

		$RGB = `colorSliderGrp -q -rgb UV_ShellColor`;

		$randomRed = ($RGB[0] * 10);
		$randomGreen = ($RGB[1] * 10);
		$randomBlue = ($RGB[2] * 10);

		//create and assign shader
		$ColorShader = `shadingNode -name "NinjaRandomColorShader" -asShader surfaceShader`;
		string $NewSG_Name = `sets -renderable true -noSurfaceShader true -empty -name ($ColorShader + "SG")`;//create a Shading Group node
		connectAttr -force ($ColorShader  + ".outColor") ($NewSG_Name + ".surfaceShader");//connects material node to Shading Group node
		setAttr ($ColorShader + ".outColor") -type double3 ($randomRed * .1) ($randomGreen *.1) ($randomBlue * .1);
		sets -e -forceElement $NewSG_Name $ShellFaces;//assign material to faces

		//add shaders to delete array to delete after bake
		stringArrayInsertAtIndex (0,$DeleteArray, $ColorShader);
		stringArrayInsertAtIndex (0,$DeleteArray, $NewSG_Name);
	}
	//delete $DeleteArray;
	select $ObjSelection;
	return $DeleteArray;
}

global proc NinjaUV_UnColorUVShells()
{
	$ObjSelection = `ls -sl -fl -l`;
	polyOptions  -displayMapBorder 0 -colorMaterialChannel "ambientDiffuse" -activeObjects;
	for ($i = 0; $i < `size $ObjSelection`; $i++)
		{

			select $ObjSelection[$i];
			string $ColorSets[] = `polyColorSet -q -allColorSets`;
			for ($c = 0; $c < `size $ColorSets`; $c++)
				{
					if ($ColorSets[$c] == "NinjaUVColorizeShell")
					{
						polyColorSet -delete -colorSet "NinjaUVColorizeShell" $ObjSelection;

                    }//end if
                }//end for
        }//end for
}//end proc

global proc NinjaUV_SelectSimilarShells()
{
	ConvertSelectionToUVs;
	$Sel_UVs = `ls -sl -fl`;
	float $MasterShellSize[] = `polyEvaluate -bc2 $Sel_UVs`; //xmin xmax ymin ymax
	float $MasterUsize = ($MasterShellSize[1] - $MasterShellSize[0]);
	float $MasterVSize = ($MasterShellSize[3] - $MasterShellSize[2]);

	int $Shell_Count = `size $Sel_UVs`;
	$Sel_Mesh = `ls -hl`;
	select $Sel_Mesh;
	ConvertSelectionToUVs;
	string $Shells[] = NinjaUV_CollectShells();
	//print $Shells;
	string $SimilarShellArray[] = {};

	for ($a = 0; $a < `size $Shells`; $a++)
	{
		string $Single_Shell[];
		tokenize $Shells[$a] "," $Single_Shell;
		//select -r $Single_Shell;

		select $Single_Shell;
		float $ShellSize[] = `polyEvaluate -bc2 $Single_Shell`; //xmin xmax ymin ymax
		float $Usize = ($ShellSize[1] - $ShellSize[0]);
		float $VSize = ($ShellSize[3] - $ShellSize[2]);


		if (`size $Single_Shell` == $Shell_Count)
		{

			if ($Usize <= ($MasterUsize + .01) && $VSize <= ($MasterVSize + .01))
			{
				appendStringArray($SimilarShellArray,$Single_Shell, `size $Single_Shell`);
            }

			if ($MasterUsize <= ($Usize + .01) &&  $MasterVSize <= ( $VSize + .01))
			{
				appendStringArray($SimilarShellArray,$Single_Shell, `size $Single_Shell`);
            }

        }


    }

	select $SimilarShellArray;
}



global proc string[] NinjaUV_FindUniqueShells ()
{
	string $Sel[] = `selectedNodes`;
	string $OriginalSel[] = `selectedNodes`;
	string $TestCCount = "";
	string $UVCountArray[] = {};
	string $UniqueShells[] = {};
	stringArrayInsertAtIndex(0, $UVCountArray , $Sel[0]);
		//test uv count
		for ($a = 0; $a < `size $Sel`; $a++)
			{
				//print $Sel[$a];
				$AObjectUVCount = `polyEvaluate -uvcoord $Sel[$a]`;
				for ($b = 0; $b < `size $Sel`; $b++)
					{
						//if ($Sel[$a] != $Sel[$b] )
						//{

							$TestCCount = "";
							$BObjectUVCount = `polyEvaluate -uvcoord $Sel[$b]`;

									for ($c = 0; $c < `size $UVCountArray`; $c++)
									{
										$CObjectUVCount = `polyEvaluate -uvcoord $UVCountArray[$c]`;
										if ($CObjectUVCount[0] == $BObjectUVCount[0])
											{
												$TestCCount = "EqualCount";
												//$ShellC = $UVCountArray[$c];
                                        	}

                                    }

							if ($TestCCount != "EqualCount")
									{
										stringArrayInsertAtIndex(0, $UVCountArray ,$Sel[$b]);
										$UVCountArray = stringArrayRemoveDuplicates($UVCountArray);
                                  	}


                        //}//end if

					}//end for b


            }//end for a

	//$UniqueShells = $UVCountArray;

	/*
	//string $EqualUVCount[] = {};
	string $UniqueSize[] = {};
	//print $UVCountArray;
	for ($a = 0; $a < `size $UVCountArray`; $a++)
		{
			//print $a;
			$AObjectUVCount = `polyEvaluate -uvcoord $UVCountArray[$a]`;
			for ($b = 0; $b < `size $Sel`; $b++)
				{

					$BObjectUVCount = `polyEvaluate -uvcoord $Sel[$b]`;
					if ($AObjectUVCount[0] == $BObjectUVCount[0])
						{
							//print $Sel[$b];
							stringArrayInsertAtIndex(0, $EqualUVCount ,$Sel[$b]);
						}

	           }


			//select $EqualUVCount;
			//error;
			string $TestSize = "";
			sort $EqualUVCount;
			stringArrayInsertAtIndex(0, $UniqueSize ,$EqualUVCount[0]);
			for ($d = 0; $d < `size $EqualUVCount`; $d++)
				{
					//stringArrayInsertAtIndex(0, $UniqueSize , $EqualUVCount[0]);
					//select $EqualUVCount[$d];
					//ConvertSelectionToUVs;
					float $DSize[] = `polyEvaluate -b2 $EqualUVCount[$d]`;//xmin xmax ymin ymax
					for ($e = 0; $e < `size $EqualUVCount`; $e++)
					{
						//select $EqualUVCount[$e];
						//ConvertSelectionToUVs;
						float $ESize[] = `polyEvaluate -b2 $EqualUVCount[$e]`;//xmin xmax ymin ymax
						if ($DSize[0] == $ESize[0] && $DSize[1] == $ESize[1] && $DSize[2] == $ESize[2] && $DSize[3] == $ESize[3])
							{

								//print ($EqualUVCount[$d] + "x" + $EqualUVCount[$e]);
								for ($f = 0; $f < `size $UniqueSize`; $f++)
									{
										//select $UniqueSize[$f];
										//ConvertSelectionToUVs;
										float $FSize[] = `polyEvaluate -b2 $UniqueSize[$f]`;//xmin xmax ymin ymax

										if ($FSize[0] == $ESize[0] && $FSize[1] == $ESize[1] && $FSize[2] == $ESize[2] && $FSize[3] == $ESize[3])
											{
												print ($EqualUVCount[$e] + "   " + $UniqueSize[$f] + " Add " + $EqualUVCount[$e] );
												//print $ESize;
												//print $UniqueSize[$f];
												//print $FSize;
												$TestSize = "NonEqualSize";
											}
										else
										{
											//$TestSize = "EqualSize";
                                        }
                                    }

								if ($TestSize == "NonEqualSize")
								{
									stringArrayInsertAtIndex(0, $UniqueSize ,$EqualUVCount[$e]);
									//print $EqualUVCount[$e];
									$UniqueSize = stringArrayRemoveDuplicates($UniqueSize);
									sort $UniqueSize;
									//$TestSize = "";
	                            }


							}


                    }


                }
			//error;
			//refresh;
			$EqualUVCount = {};
			//pause -sec 1;

        }

	select $OriginalSel;
	print $UniqueSize;
	//error;
	*/
	//print $UVCountArray;
	//error;
	return $UVCountArray;
}


/*
global proc string[] NinjaUV_FindUniqueShells(string $Objects[])
{

	string $Sel[] = $Objects;
	//string $OriginalSel[] = `selectedNodes`;
	string $UniqueUVSizeArray[] = {};
	string $TestCSize = "";

	stringArrayInsertAtIndex(0, $UniqueUVSizeArray , $Sel[0]);
		for ($a = 0; $a < `size $Sel`; $a++)
			{

				select $Sel[$a];
				ConvertSelectionToUVs;
				float $ASize[] = `polyEvaluate -b2`;//xmin xmax ymin ymax
				for ($b = 0; $b < `size $Sel`; $b++)
					{

						if ($Sel[$a] != $Sel[$b] )
						{
							select $Sel[$b];
							ConvertSelectionToUVs;
							float $BSize[] = `polyEvaluate -b2`;//xmin xmax ymin ymax

								for ($c = 0; $c < `size $UniqueUVSizeArray`; $c++)
									{
										//print $UVSizeArray[$c];
										select $UniqueUVSizeArray[$c];
										ConvertSelectionToUVs;
										//pause -seconds 1;
										float $CSize[] = `polyEvaluate -b2`;//xmin xmax ymin ymax
										if ($BSize[0] == $CSize[0] && $CSize[1] == $CSize[1] && $CSize[2] == $CSize[2] && $CSize[3] == $CSize[3])
										{

											$TestCSize = "EqualSize";

										}

									}

							if ($TestCSize != "EqualSize")
								{
									stringArrayInsertAtIndex(0, $UniqueUVSizeArray ,$Sel[$b]);
									$UniqueUVSizeArray = stringArrayRemoveDuplicates($UniqueUVSizeArray);

								}
							$EqualSize = "";
						}
            		}


             }

	return $UniqueUVSizeArray;
}
*/

global proc NinjaUV_CalculateAtlas()
{
	$TextureSize = `floatField -q -v Atlas_TextureSize `;

	$Sel = `ls -sl -fl`;
	$TotalObjects = `size $Sel`;
	int $Tiles ;

	float $HTiles_float = `sqrt $TotalObjects`;
	int $HTiles_int = `sqrt $TotalObjects`;
	int $HTiles;
	if ($HTiles_float == $HTiles_int)
	{
		$Tiles =  $HTiles_int;
    }

	else
	{
		$Tiles = ($HTiles_int + 1);
    }

	$AtlasSize = ($Tiles * $TextureSize);

	floatField -e -v $AtlasSize Atlas_Size ;

}


global proc string NinjaUV_TextureAtlas()
{
	mentalRayLoad;
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
		$Format = "3";
    }

	$Tex_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$Tex_Height = `intField -q -v NinjaUV_BakeAO_Height`;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory Atlas");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $Atlas_Name = substituteAllString ($TexturePath, ".tga", "_Atlas");
	textField -e -text ($Atlas_Name + "." + $Extension) "Bake_Path";//this is the export path

	$Dup = `checkBox -q -v Atlas_Duplicate`;
	if ($Dup == 1)
	{
		duplicate -rr;

    }

	$Group = `checkBox -q -v Atlas_Group`;
	if ($Group == 1)
	{
		group -w -r -n "GRP_NinjaAtlas";
		xform -os -piv 0 0 0;
		$Children = `listRelatives -c`;
		select $Children;
    }


	string $Sel[] = `ls -sl -fl -l`;
	string $BaseNames[] = `ls -sl -fl -l`;
	string $OriginalSel[] = `ls -sl -fl -l`;
	int $TotalObjects = `size $Sel`;


	//duplicate and combine mesh to Base Mesh
	string $BaseMesh[] = `duplicate -rr $BaseNames`;
	if (`size $BaseMesh` != 0)
		{
			select $BaseMesh;
			NinjaUV_Attach;
			rename "TextureAtlas_BaseMesh";
			$BaseMesh = `ls -sl -fl -l`;
        }

	//////////////////////////////////////////Calculate Atlas Grid

	float $HTiles_float = `sqrt $TotalObjects`;
	int $HTiles_int = `sqrt $TotalObjects`;
	int $HTiles;
	if ($HTiles_float == $HTiles_int)
	{
		$HTiles =  $HTiles_int;
    }

	else
	{
		$HTiles = ($HTiles_int + 1);
    }
	////////////////////////////////////////////

	//////////Layout UV Atlas///////////////////
	//print $HTiles;
	int $count = -1;
	string $TextureTiles[] = {};
	for ($v = 0; $v < $HTiles; $v++)
		{

			for ($u = 0; $u < $HTiles; $u++)
			{
				$count = ($count + 1);
				if (`objExists $Sel[$count]`)
				{
					select $Sel[$count];
					ConvertSelectionToUVs;
					polyEditUV -u $u -v $v;

                }
			}
        }

	//Combine AtlasMesh
	string $AtlasMesh[] = `duplicate -rr $Sel`;
	if (`size $AtlasMesh` != 0)
		{
			select $AtlasMesh;
			NinjaUV_Attach;
			rename "TextureAtlas_AtlasMesh";
			$AtlasMesh = `ls -sl -fl -l`;
        }

	//scale UV's
	print $HTiles;
	ConvertSelectionToUVs;
	float $Scale = (1.00 / $HTiles);
	polyEditUV -pu 0 -pv 0 -sv $Scale -su $Scale;

	/////////////Bake Texture
	int $Samples = `radioButtonGrp -q -select BakeSamples `;


		string $SelObj[] = `ls -sl -fl`;
		string $AtlasPlane[];

		surfaceSampler -target $AtlasMesh
					   -uvSet map1
					   -searchOffset 0
					   -maxSearchDistance 0
					   -searchCage ""
					   -source $BaseMesh
					   -mapOutput diffuseRGB
					   -mapWidth $Tex_Width
					   -mapHeight $Tex_Height
					   -max 1 -mapSpace tangent
					   -mapMaterials 1 -shadows 1
					   -filename $Atlas_Name
					   -fileFormat $Extension
					   -superSampling ($Samples - 1)
					   -filterType 0
					   -filterSize 3
					   -overscan 1
					   -searchMethod 0
					   -useGeometryNormals 1
					   -ignoreMirroredFaces 0
					   -flipU 0
					   -flipV 0;


		int $Total_Atlas;
		if (`objExists ("Mat_NinjaAtlas*")` == 1)
			{
				select "Mat_NinjaAtlas*";
				string $SelMat_Atlas[] = `ls -sl -fl`;
				$Total_Atlas = `size $SelMat_Atlas`;
			}

		else
		{
			$Total_Atlas = 0;
		}

		//Create Shader
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaAtlas" + $Total_Atlas)` ;//create a material node
		$SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaAtlas" + $Total_Atlas )`;//create a Shading Group node
		$Texture_Name = `shadingNode -name ("Tex_NinjaAtlas" + $Total_Atlas) -asTexture file`;//create texture node
		$UV_Name = `shadingNode -name ("UV_NinjaAtlas" + $Total_Atlas)  -asUtility place2dTexture`;//create uv node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Atlas_Name + "." + $Extension) ;//assign texture to texture node
		sets -e -forceElement $SG_Name $AtlasPlane;//assign material to object
		delete $SelObj ;
		sets -e -forceElement $SG_Name $Sel;//assign material to objec


	//rescale UV to fit into 0-1
	select $OriginalSel;
	ConvertSelectionToUVs;
	polyEditUV -pu 0 -pv 0 -sv (1.0 / $HTiles) -su (1.0 / $HTiles);

	select $OriginalSel;
	delete $AtlasMesh $BaseMesh;
	system ("imconvert -sample 250 250 " + ($Atlas_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Atlas_Name + "." + $Extension);

}//end Texture Atlas

global proc NinjaUV_OpenAtlasTexture()
{
	$Dir = `textField -q -tx AtlasDirectory`;
	//$Dir = substituteAllString($Dir, "/", "\\");
	system ("load " + ($Dir + "NinjaAtlas.tga"));

}


global proc NinjaUV_ObjectTileLayout()
{

	string $Sel[] = `selectedNodes`;
	string $OriginalSel[] = `selectedNodes`;
	float $TotalObjects = `size $Sel`;
	int $HTiles = `sqrt $TotalObjects`;
	$HTiles = ($HTiles + 1);
	int $count = -1;
	string $SimilarCountShells[] = {};
	string $UVSizeArray[] = {};
	string $SimilarSizeShells[] = {};

	string $UniqueUVArray[] = {};

	$StackShells = 0;
	//$StackShells = `checkBox -q -v StackSimilarShells`;
	if ($StackShells == 1)
	{
		string $UVCountArray[] = `eval ("NinjaUV_FindUniqueShells")`;
		$Sel = $UVCountArray;
		$TotalObjects = `size $Sel`;
		$HTiles = `sqrt $TotalObjects`;
		$HTiles = ($HTiles + 1);

		//////////Layout the uv's
		for ($v = 0; $v < $HTiles; $v++)
		{
			for ($u = 0; $u < $HTiles; $u++)
			{
				$count = ($count + 1);
				if (`objExists $Sel[$count]`)
				{
					//check for same uv count to move together
					for ($o = 0; $o < `size $OriginalSel`; $o++)
					{
						$AObjectUVCount = `polyEvaluate -uvcoord $OriginalSel[$o]`;
						$BObjectUVCount = `polyEvaluate -uvcoord $Sel[$count]`;

							if ($AObjectUVCount[0] == $BObjectUVCount[0])
							{
								stringArrayInsertAtIndex(0, $SimilarCountShells ,$OriginalSel[$o]);
								//select -add $Sel[$count];
                            }

                    }

						select $SimilarCountShells;
						ConvertSelectionToUVs;
						polyEditUV -u $u -v $v;
						$SimilarCountShells = {};

				}//end if

			}//end for u
		}//end for v

	}

	else
	{
		//////////Layout the uv's
		for ($v = 0; $v < $HTiles; $v++)
		{
			for ($u = 0; $u < $HTiles; $u++)
			{
				$count = ($count + 1);
				if (`objExists $Sel[$count]`)
				{
					select $Sel[$count];
					ConvertSelectionToUVs;
					polyEditUV -u $u -v $v;

				}//end if

			}//end for u
		}//end for v
	}

	select $OriginalSel;
	ConvertSelectionToUVs;
	polyEditUV -pu 0 -pv 0 -sv (1.0 / $HTiles) -su (1.0 / $HTiles);
	select $OriginalSel;
}

global proc string  NinjaUV_FlattenMesh()
{
 	string $Selobj[] = `ls -sl -fl -l` ;
	string $DupMesh[];
	if (`size $Selobj` > 0)
		{
			for ($a = 0 ;$a < `size $Selobj`; $a++)
			{
				$DupMesh = `duplicate -n "Ninja_FlattenMesh" $Selobj[$a]` ;
				polySoftEdge -a 0 -ch 1 $DupMesh[0];
				FreezeTransformations;
				DeleteHistory;
				PolySelectConvert 4;
				polySelectBorderShell 1;
				SplitVertex;
				select -r $DupMesh ;
				FreezeTransformations;
				DeleteHistory;
				int $VtxNum[] = `polyEvaluate -v`;

				for ($A=0;$A<$VtxNum[0];$A++)
				{
					string $VTXname = $DupMesh[0] + ".vtx[" + $A + "]" ;
					string $UVName = $DupMesh[0] + ".map[" + $A + "]";
					select $VTXname;
					float $UVnum[] = `polyEvaluate -bc2 `;
					move ($UVnum[0]-0.5) ($UVnum[2]-0.5) 0 $VTXname;
				}
			}
	}
	return $DupMesh[0];
}

global proc NinjaUV_ArrangeShells(string $Direction)
{

	if ($Direction == "h")
		{
			NinjaUV_AlignShells Right ;

        }

	if ($Direction == "v")
		{
			NinjaUV_AlignShells Top ;

        }

	$Selection = `ls -sl -fl -l`;
	string $Shells[] = NinjaUV_CollectShells();
	float $StartWidth;
	float $StartHeight;
	float $Hdistance = 0;
	float $Vdistance = 0;
	float $Padding = `floatField -q -v Layout_PaddingValue`;

	for ($s = 0; $s < `size $Shells`; $s++)
	{

		string $Single_Shell[];
		tokenize $Shells[$s] "," $Single_Shell;
		select -r $Single_Shell;
		float $Extents[] = `polyEvaluate -bc2`;//umin umax vmin vmax

		if ($s == 0)
		{
			$StartWidth = `abs ($Extents[1] - $Extents[0])`;
			$StartHeight = `abs ($Extents[3] - $Extents[2])`;
        }

		if ($Direction == "h")
			{
				$ShellWidth = `abs ($Extents[1] - $Extents[0])`;
				polyEditUV -u  ($Hdistance + $ShellWidth + $Padding - $StartWidth - $Padding);
				$Hdistance = ($Hdistance + $ShellWidth + $Padding);
            }

		if ($Direction == "v")
			{
				$ShellHeight = `abs ($Extents[3] - $Extents[2])`;
				polyEditUV -v  ($Vdistance + $ShellHeight + $Padding - $StartHeight - $Padding);
				$Vdistance = ($Vdistance + $ShellHeight + $Padding);
            }


	}

	if ($Direction == "grid")
	{
		string $Single_Shell[];
		tokenize $Shells[0] "," $Single_Shell;
		select -r $Single_Shell;
		float $Extents[] = `polyEvaluate -bc2`;//umin umax vmin vmax

		float $ShellWidth = `abs ($Extents[1] - $Extents[0])`;
		float $ShellHeight = `abs ($Extents[3] - $Extents[2])`;

		int $TotalShells = `size $Shells`;
		float $HTiles = `sqrt $TotalShells`;

		float $VTiles;

		$HTiles = `abs ($HTiles + .5)`;
		$VTiles = $HTiles;


		$HorzGrid = `intField -q -v LayoutGrid_HorizontalValue`;
		if ($HorzGrid != 0)
		{
			$HTiles = $HorzGrid;
			$VTiles = ($TotalShells / $HorzGrid);
			$VTiles = `abs ($VTiles + .5)`;
			//print $VTiles;
			//error;
        }

		int $count = 0;
		for ($v = 0; $v < $VTiles; $v++)
			{
				for ($u = 0; $u < $HTiles; $u++)
				{
					if ($count < $TotalShells)
					{
						string $Single_Shell[];
						tokenize $Shells[$count] "," $Single_Shell;
						select -r $Single_Shell;
						polyEditUV -u (($u * $ShellWidth) + ($u * $Padding )) -v (($v * $ShellHeight) + ($v * $Padding ));
						$count = ($count + 1);

                    }
				}//end for u
			}//end for v

	}//end if grid


	select $Selection;

}


global proc NinjaUV_SetFromToText(string $FromTo)
{

	$SelUVSet = `textScrollList -q -si UVSet_List`;
	if ($FromTo == "From")
	{
		textField -e -text $SelUVSet  FromUVSetName;
    }
	if ($FromTo == "To")
	{
		textField -e -text $SelUVSet  ToUVSetName;
    }
}


global proc NinjaUV_CopyUVSets()
{

	string $Sel[] = `ls -sl -fl -l`;
	$FromUVSet = `textField -q -text FromUVSetName`;
	$ToUVSet =`textField -q -text  ToUVSetName`;

	for ($i = 0; $i < (`size $Sel`); $i++)
		{
			int $FromUVSetExists = 0;
			int $ToUVSetExists = 0;
			string $UVSets[] = `polyUVSet -q -allUVSets $Sel[$i]`;
			for ($j = 0; $j < (`size $UVSets`); $j++)
				{
					if ($UVSets[$j] == $FromUVSet)
					{
						$FromUVSetExists = 1;
                    }//end if

					if ($UVSets[$j] == $ToUVSet)
					{
						$ToUVSetExists = 1;
                    }//end if
                }//end for j

			if ($FromUVSetExists == 1 && $ToUVSetExists == 1)
				{
					polyCopyUV -uvSetNameInput $FromUVSet -uvSetName $ToUVSet -ch 1 $Sel[$i];

                }

        }//end for i
	NinjaUV_GetUVSets();
	select $Sel;
}

global proc NinjaUV_AddUVSets()
{
	string $NewUVSetName = `textField -q -text NewUVSetName`;
	string $Sel[] = `ls -sl -fl -l`;
	for ($i = 0; $i < (`size $Sel`); $i++)
		{
			int $UVSetExists = 0;
			string $UVSets[] = `polyUVSet -q -allUVSets $Sel[$i]`;
			for ($j = 0; $j < (`size $UVSets`); $j++)
				{
					if ($UVSets[$j] == $NewUVSetName)
					{
						$UVSetExists = 1;

                    }//end if

                }//end for j

			if ($UVSetExists == 0)
				{
					polyCopyUV -uvSetNameInput "map1" -uvSetName $NewUVSetName -createNewMap 1 -ch 1 $Sel[$i];
                }

        }//end for i
NinjaUV_GetUVSets();
select $Sel;
}

global proc NinjaUV_DeleteUVSets()
{
	//string $NewUVSetName = `textField -q -text NewUVSetName`;
	string $Sel[] = `ls -sl -fl -l`;
	string $SelUvSet[] = `textScrollList -q -si UVSet_List`;
	for ($i = 0; $i < (`size $Sel`); $i++)
		{
			int $UVSetExists = 0;
			string $UVSets[] = `polyUVSet -q -allUVSets $Sel[$i]`;
			for ($j = 0; $j < (`size $UVSets`); $j++)
				{

					//print ($UVSets[$j] + " xxxxxx " + $NewUVSetName);
					if ($UVSets[$j] == $SelUvSet[0])
					{
						$UVSetExists = 1;

                    }//end if

                }//end for j

			if ($UVSetExists == 1)
				{
					polyUVSet -uvSet $SelUvSet[0] -d $Sel[$i];

                }

        }//end for i
NinjaUV_GetUVSets();
select $Sel;
}

global proc NinjaUV_GetUVSets()
{
	string $Sel[] = `ls -sl -fl -l`;
	string $UVSets[] = `polyUVSet -q -allUVSets $Sel`;
	$UVSets = `stringArrayRemoveDuplicates $UVSets`;
	textScrollList -e -ra UVSet_List;
	for ($i = 0; $i < (`size $UVSets`); $i++)
		{
			textScrollList -e -append $UVSets[$i] UVSet_List;

        }//end for
}


global proc NinjaUV_SetUVSets()
{
	//string $NewUVSetName = `textField -q -text NewUVSetName`;
	string $Sel[] = `ls -sl -fl -l`;
	string $SelUvSet[] = `textScrollList -q -si UVSet_List`;
	for ($i = 0; $i < (`size $Sel`); $i++)
		{
			int $UVSetExists = 0;
			string $UVSets[] = `polyUVSet -q -allUVSets $Sel[$i]`;
			for ($j = 0; $j < (`size $UVSets`); $j++)
				{
					if ($UVSets[$j] == $SelUvSet[0])
					{
						$UVSetExists = 1;
                    }//end if

                }//end for j

			if ($UVSetExists == 1)
				{
					polyUVSet -currentUVSet -uvSet $SelUvSet[0] $Sel[$i];

                }

        }//end for i
	select $Sel;
}

///////////////////////////////////////////////////////////////////////////////////////////////////Collect Shells
global proc NinjaUV_IsolateUVs()
{
	PolySelectConvert 4;
	textureEditorIsolateSelect 0;
	textureEditorIsolateSelect 1;
	textureWindowShaderFacesMode( "polyTexturePlacementPanel1", "textureWindow",  1);
}

///////////////////////////////////////////////////////////////////////Poly Tools///////////////////////////////////////////////////////////////

global proc NinjaUV_Attach()
{
	string $selected_objects[] = `ls -sl -o -dag -fl -l -ni -type "transform"`;
	//string $selected_objects[] = `ls -sl -fl -l`;
	if (`size $selected_objects` > 1)
	{
		select $selected_objects;
		delete -ch;
		string $newmesh[] = `polyUnite -ch 1 -o 1 `;
		delete -ch;
		for ($c = 0; $c < `size $selected_objects`; $c++)
			{

				if(`objExists $selected_objects[$c]` == 1  && $selected_objects[$c] != $newmesh[0]	)
				{
					delete $selected_objects[$c];
				}

			}
		select $newmesh[0];
	}
}

global proc NinjaUV_DeleteEmptyUVSets()
{
	$SelObject = `ls -sl -fl -l`;
	ConvertSelectionToUVs;
	$UVs = `ls -sl -fl -l`;
	$UVSets = `polyUVSet -q -auv`;

	for ($i = 0; $i < `size $UVSets`; $i++)
	{
		polyUVSet -currentUVSet -uvSet $UVSets[$i];
		select $UVs;
		$sel = `ls -sl -fl -l`;

		if (`size $sel` <= 1)
		{
			polyUVSet -delete -uvs $UVSets[$i];
        }
    }

	select $SelObject;
}

global proc NinjaUV_DetachByShells()
{
	$Mesh = `ls -sl -fl`;
	string $Shells[] = NinjaUV_CollectShells();
	//print $Shells;

for ($s = 0; $s < `size $Shells`; $s++)
	{

		string $Single_Shell[];
		tokenize $Shells[$s] "," $Single_Shell;
		select -r $Single_Shell;
		ConvertSelectionToFaces;
		doMenuComponentSelection($Mesh[0], "facet");
		NinjaUV_DetachFaces;
	}
}

global proc NinjaUV_DetachFaces()
{
	$ObjectName =  `ls -hl`;
	$DupObject =  `duplicate -rr $ObjectName`;
	string $SelectedFaceIndex[] = {};
	string $FaceSelection[] = `filterExpand -ex 1 -sm 34`;
	string $DupFaceSelection[] = {};
	for ($f = 0; $f < `size $FaceSelection`; $f++)
		{
			string $buf[] = {};
			int $numTokens = `tokenize $FaceSelection[$f] "." $buf`;
			$SelectedFaceIndex[$f] = $buf[1];
        }

 	delete $FaceSelection;

	select -cl;
	for ($s = 0; $s < `size $SelectedFaceIndex`; $s++)
		{
			$DupFaceSelection[$s] = ($DupObject[0] + "." + $SelectedFaceIndex[$s]);
        }

		select $DupFaceSelection;
		InvertSelection;
		delete;
		select $DupObject;

}

global proc NinjaUV_Extract()
{
	$ObjectName =  `ls -hl`;
	$DupObject =  `duplicate -rr $ObjectName`;
	string $SelectedFaceIndex[] = {};
	string $FaceSelection[] = `filterExpand -ex 1 -sm 34`;
	string $DupFaceSelection[] = {};
	for ($f = 0; $f < `size $FaceSelection`; $f++)
		{
			string $buf[] = {};
			int $numTokens = `tokenize $FaceSelection[$f] "." $buf`;
			$SelectedFaceIndex[$f] = $buf[1];
        }

 	select -cl;
	for ($s = 0; $s < `size $SelectedFaceIndex`; $s++)
		{

			$DupFaceSelection[$s] = ($DupObject[0] + "." + $SelectedFaceIndex[$s]);

        }

		select $DupFaceSelection;
		InvertSelection;
		delete;
		select $DupObject;

}

global proc NinjaUV_CutAndSeperate()
{
	$SelObject = `ls -hl`;
 	DetachComponent;
	polySeparate $SelObject;
	$Sel = `ls -sl -l`;
	$Group = `firstParentOf($Sel[0])`;
	select $Group;
	ungroup;
	DeleteHistory;
	delete $Group;
	$Sel = `ls -sl -l`;
	for ($s = 0; $s < `size $Sel`; $s++)
		{
			rename $Sel[$s] $SelObject[0];
        }

}

global proc string[] NinjaUV_CollectShells()
{
	PolySelectConvert 4;//convert selection to uv's
	$Selection =`ls -sl -fl -l`;
	string $UVs[] = `ls -sl -fl -l`;//base uv's
	string $Shell_array[] = {};

	while (`size $UVs` > 0)
		{
			select $UVs[0];
			//contrain selection to shell
			polySelectConstraint -t 0;
			polySelectConstraint -sh 1 -bo 0 -m 2;

			//string $Shell[] = `ls -sl -fl -l`;//store and flatten uv selection
			string $Shell_string = stringArrayToString (`ls -sl -fl -l`,",");//converts array to string
			stringArrayInsertAtIndex(0 , $Shell_array, $Shell_string);
			$UVs = stringArrayRemoveExact(`ls -sl -fl -l`, $UVs);
		}//end while

	//print (`size $Shell_array`);
	//print $Shell_array[0];
	polySelectConstraint -sh 0 -bo 0 -m 0;
	return $Shell_array;//returns an array of strings that needs to be converted to An Array

}


///////////////////////////////////////////////////////////////////////////////////////////////////Quick Fix

global proc NinjaUV_NinjaUV_QuickFixBorder()
{
	PolySelectConvert 4;
	polySelectBorderShell 1;
	NinjaUV_QuickFix;
}

global proc NinjaUV_NinjaUV_QuickFixInterior()
{
	Ninja_UV_SelectInteriorUVs;
	NinjaUV_QuickFix;
}

global proc NinjaUV_QuickRelax()
{
	untangleUV -r uniform -pb 0 -ps 0 -pu 1 -rt 0 -mri 1;
}

global proc NinjaUV_QuickFix()
{
	$Unfold_Accuracy = `floatField -q -v Unfold_Iterations`;

	string $Selected[] = `ls -sl -fl`;
	string $obj_name[];
	tokenize $Selected[0] "." $obj_name;//get object name
	string $Mesh_Name;

	if (`size $obj_name` != 0)
	{
		$Mesh_Name = $obj_name[0];
	}

	if (`size $obj_name` == 0)
	{
		$Mesh_Name = $Selected[0];
	}

	int $Total_Uvs[] = `polyEvaluate -uv $Mesh_Name`;
	$selection = `ls -sl -fl`;
	PolySelectConvert 4;
	string $sel_Uvs[] = `ls -sl -fl`;

	if (`size $sel_Uvs` == $Total_Uvs[0])
	{
		select -d $sel_Uvs[0];
    }

	unfold -i $Unfold_Accuracy -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  0 -us off;
	//polyOptUvs -i 1000 -ss 0.001 -gb 0 -gmb 0.0 -pub 0 -ps  0 -oa  0 -us off;
	select -r $selection;

}


///////////////////////////////////////////////////////////////////////////////////////////////////Find Texture
global proc NinjaUV_FindTexture()
{
	string $sel_face[] = `ls -sl -fl`;
	$TextureName = NinjaUV_GetFaceTexture($sel_face[0]);
	$Xsize =getAttr ($TextureName + ".outSizeX");
	$Ysize =getAttr ($TextureName + ".outSizeY");
	select $TextureName;
	//confirmDialog -button "close" -message ("Texture Name = " + $TextureName + "  " + "Size = " + $Xsize + " " + $Ysize);
	floatField -e -v $Xsize Tex_ScaleU ;
	floatField -e -v $Ysize Tex_ScaleV ;

	NinjaUV_SetPixelRatio;
	select $sel_face;
}

///////////////////////////////////////////////////////////////////////////////////////////////////Get Face Texture
global proc string NinjaUV_GetFaceTexture(string $face)

{

	ConvertSelectionToFaces;
	string $Selected[] = `ls -sl -l`;
	string $shape_name[];
	tokenize $Selected[0] "." $shape_name;//get object name

	string $obj_name;
	if (`size $shape_name` > 1)
	{

		//$parent = `ls -hl -l`;
		 $parent = `listRelatives -s -path -p $Selected[0]`;
		 $obj_name = $parent[0];
    }

	else
	{
		string $childeren[] = `listRelatives -s -path $Selected[0]`;
		$obj_name = $childeren[0];
    }

	string $ShadingGroupName = "";
	string $SelectedFace = $face;
	string $shadingGroups[] = `ls -type shadingEngine`;
	string $currentShape[];
	for ($f = 0; $f < `size $shadingGroups`; $f++)
		{
			if ( `sets -isMember $shadingGroups[$f] $SelectedFace` ) //find shading group assigned to face
			{
				//print ("SG = " + $shadingGroups[$f]);
				$ShadingGroupName = $shadingGroups[$f];
				break;
			}//end if

			else
			{
				//string $currentShape[] = `listRelatives -s -path $obj_name`;
				$SGN = `listConnections -destination true -source false -plugs false -type "shadingEngine" $obj_name`;
				$ShadingGroupName = $SGN[0];

			}//end else

		}//end $f

	$material = `connectionInfo -sourceFromDestination ($ShadingGroupName + ".surfaceShader" )`; //find material attached to shading group
	$materialName = substituteAllString($material, ".outColor", "");//remove outColor
	string $TextureInput = `textField -q -tx TextureInputConnection`;
	print $TextureInput;
	$Texture = `connectionInfo -sourceFromDestination  ($materialName + "." + $TextureInput)`; //find texture attaced to material
	$TextureName = substituteAllString($Texture, ".outColor", "");//remove outColor
	//select $Selected;
	return $TextureName;

}//end proc

///////////////////////////////////////////////////////////////////////////////////////////////////Border Mapping
global proc NinjaUV_EdgeMap()
{
	global float $Unfold_Accuracy;
	global string $Mapping_Set;
	string $Left_Edge[];
	string $Right_Edge[];
	string $Selected_Edges[];
	$selected = `ls -sl -fl`;
	//print $selected;
	$Target_Object = `ls -hl`;
	//print $Target_Object[0];
	if (`size $Target_Object` == 0)
		{
			$Target_Object = `ls -sl -fl`;
		}

	if (`size $selected` != 2)
		{
			error "only select 2 edges";
		}

	if (`size $selected` == 2)
		{
			$Mesh_Name = `ls -hl`;
			$Target_Object = `ls -hl`;
			global string $L_Border;
			global string $R_Border;

			$Selected_Edges = `ls -sl -fl`;
			select $Selected_Edges[0];
			SelectEdgeLoop;
			$Left_Edge = `ls -sl -fl`;
			NinjaUV_AutoCreateUVPath($L_Border, $Mesh_Name[0]);
			select $Selected_Edges[1];
			SelectEdgeLoop;
			$Right_Edge = `ls -sl -fl`;
			NinjaUV_AutoCreateUVPath($R_Border, $Mesh_Name[0]);
		}

	loft -name ("BK_Border_Mesh" + "_" + $Target_Object[0])  -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 1 -rsn true ("UV_R_Border" + "_" + $Target_Object[0]) ("UV_L_Border" + "_" + $Target_Object[0]);

	//scale
	$Map_Scale = (1 / (`floatField -q -v Map_ScaleU`));
	$MSU = `floatField -q -v Map_ScaleU`;
	$MSV = `floatField -q -v Map_ScaleV`;

	if ($MSV < $MSU)
	{
		$Map_Scale = (1 / (`floatField -q -v Map_ScaleV`));
	}
	polyOptUvs -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub 1 -ps  0 -oa  0 -us on -s $Map_Scale;//unfold Scale
	//end scale

	select ("BK_Border_Mesh" + "_" + $Target_Object[0]);
	select -add $Target_Object;
	transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 1 -transferColors 0 -sampleSpace 0 -sourceUvSet map1 -targetUvSet $Mapping_Set -flipUVs 0 -colorBorders 0 ;//transfer mesh
	DeleteHistory;
	//error;
	//cut edge
	string $CutEdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	if (`size $CutEdgeList` != 0)
		{
			select -cl;
			for ($i = 0; $i < (`size $CutEdgeList`); $i++)
				{
					select -add ($Target_Object[0] + "." + $CutEdgeList[$i]);

				}//end for
			$CutEdges = `ls -sl -fl -l`;
			select $Target_Object;
			select -add $CutEdges;
			//error;
			polyMapCut -ch 0 $CutEdges;
			//error;
		}

	//error;
	select $Target_Object;
	NinjaUV_QuickUnfold();

	select $Target_Object;
	NinjaUV_QuickScale();
	//Set to zero
	PolySelectConvert 4;
	NinjaUV_SetUToZero();
	NinjaUV_SetVToZero();

	delete ("UV_L_Border" + "_" + $Target_Object[0]);
	delete ("UV_R_Border" + "_" + $Target_Object[0]);
	delete ("BK_Border_Mesh" + "_" + $Target_Object[0]) ;

	select $Target_Object;
	doMenuComponentSelection(shortNameOf ($Target_Object[0]), "edge");
	select -add $Selected_Edges;

}//end proc


//////////////////////////////////////////////////////////////////Selection///////////////////////////////////////////////////////////////
global proc Ninja_UV_SelectInteriorUVs()
{

	PolySelectConvert 4;
	polySelectBorderShell 0;
	$selUV = `ls -sl -fl`;

	SelectUVBorder;
	$BorderUV= `ls -sl -fl`;
	select $selUV ;
	select -d $BorderUV;
	//InvertSelection;
}


global proc string[] Ninja_UV_SelectHardEdge()
{
	string $SelObject[] = `ls -sl -fl`;
	ConvertSelectionToEdges;
	doMenuComponentSelection($SelObject[0], "edge");
	polySelectConstraint -m 3 -t 0x8000 -sm 1 -w 2;
	string $HardEdges[] = `ls -sl -fl`;
	select -add $HardEdges;
	resetPolySelectConstraint;
	return $HardEdges;
}


global proc Ninja_UV_SelectBorderEdge()
{
	string $SelObject[] = `ls -sl -fl`;
	ConvertSelectionToEdges;
	doMenuComponentSelection($SelObject[0], "edge");
	polySelectConstraint -m 2 -t 0x8000 -bo true -sh false -cr false;
	string $BorderEdges[] = `ls -sl -fl`;
	select -add $BorderEdges;
	resetPolySelectConstraint;
	//return $BorderEdges;
}

global proc float NinjaUV_GetEdgeAngle(string $PA, string $PB)
	{

		float $PointA[] = `polyEditUV -q $PA`;
		float $PointB[] = `polyEditUV -q $PB`;

		float $DistU;
		float $DistV;
		if ($PointA[0] < $PointB[0])
			 {
				//$Left_Point = $PointA;
				$DistU = ($PointB[0] - $PointA[0]);
				$DistV = ($PointB[1] - $PointA[1]);
			 }

			 else
			 {
				$DistU = ($PointA[0] - $PointB[0] );
				$DistV = ($PointA[1] - $PointB[1]);
			 }

			$Angle = `atan2d $DistV $DistU`;
			$Angle = `abs $Angle`;

		return $Angle;
	}




global proc string[]  NinjaUV_SmartEdgeLoop()
{
	global string $StraightenUVSelection[];
	string $NinjaUV_SmartEdgeLoop_Info[];
	//string $Master_Selected_Edges[];
	string $Selected_Edges[] = `ls -sl -fl -l`;
	string $Looped_Edges[] = {};
	string $Shared_Edges[] = {};
	string $Direction;
	select $Selected_Edges[0];
	string $TestedEdge[] = {};

	do
		{
			$Selected_Edges = `ls -sl -fl`;
			float $UV_Bounds[] = `polyEvaluate -bc2`;
			$Uextents = ($UV_Bounds[1] - $UV_Bounds[0]);
			$Vextents = ($UV_Bounds[3] - $UV_Bounds[2]);
				if ($Vextents > $Uextents)
					{
						$Direction = "Vertical";
					}
				if ($Uextents > $Vextents)
					{
						$Direction = "Horizontal";
					}

			$UVS = `polyListComponentConversion -toUV $Selected_Edges[0]`;
			$UVS = `ls -fl -l $UVS`;//flatten the UVs

			//print $Direction;
			PolySelectTraverse 1;
			select -d $TestedEdge;
			$Connected_Edges = `ls -sl -fl -l`;
			$TestedEdge = stringArrayCatenate ($Connected_Edges, $TestedEdge);
			$TestedEdge = stringArrayRemoveDuplicates($TestedEdge);

				for ($c = 0; $c < `size $Connected_Edges`; $c++)
						{
							$UVS = `polyListComponentConversion -toUV $Connected_Edges[$c]`;
							$UVS = `ls -fl -l $UVS`;
							$Angle = -1	;
							if (`size $UVS` == 2)
							{
								$Angle = eval ("NinjaUV_GetEdgeAngle " + $UVS[0] + " " + $UVS[1]);
                            }

							if ($Angle >= 45 && $Angle != -1 && $Direction == "Vertical")
								{
									stringArrayInsertAtIndex(0, $Looped_Edges, $Connected_Edges[$c]);
								}

							if ($Angle < 45 && $Angle != -1 && $Direction == "Horizontal")
								{
									stringArrayInsertAtIndex(0, $Looped_Edges, $Connected_Edges[$c]);
								}

							if ($Angle == -1)
								{
									stringArrayInsertAtIndex(0, $Shared_Edges, $Connected_Edges[$c]);
                                }

						}//end for c

			$Looped_Edges = stringArrayRemoveDuplicates($Looped_Edges);
			select $Looped_Edges;
		}

		while ((`size $Selected_Edges`) != (`size $Looped_Edges`));

	select -r $Looped_Edges;
	$NinjaUV_SmartEdgeLoop_Info = $Looped_Edges;
	stringArrayInsertAtIndex ((`size $NinjaUV_SmartEdgeLoop_Info`), $NinjaUV_SmartEdgeLoop_Info, $Direction);
return $NinjaUV_SmartEdgeLoop_Info;//array that contains all the looped edges and the last is the direction of the edges
}//end proc


//////////////////////////////////////////////////////////////////Edge ///////////////////////////////////////////////////////////////
global proc NinjaUV_Edge_AddEdges()
{
	string $EdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $selEdges[] =  `filterExpand -sm 32`;

	for ($i = 0; $i < (`size $selEdges`); $i++)
		{
			string $buffer[];
			tokenize $selEdges[$i] "." $buffer;
			if (stringArrayContains($buffer[1], $EdgeList) == 0  )
			{
				textScrollList -e -append $buffer[1] EdgeSpline_list;
            }

        }//end for

	NinjaUV_Edge_SaveEdgeList();
}//end proc

global proc NinjaUV_Edge_RemoveEdges()
{
	$EdgeList = `textScrollList -q -si EdgeSpline_list`;
	for ($i = 0; $i < (`size $EdgeList`); $i++)
		{
			textScrollList -e -ri $EdgeList[$i] EdgeSpline_list;
        }

	NinjaUV_Edge_SaveEdgeList();

}//end proc


global proc NinjaUV_Edge_ReplaceEdges()
{
	string $selEdges[] =  `ls -sl -fl`;
	textScrollList -e -ra EdgeSpline_list;

	for ($i = 0; $i < (`size $selEdges`); $i++)
		{
			string $buffer[];
			tokenize $selEdges[$i] "." $buffer;
			textScrollList -e -append $buffer[1] EdgeSpline_list;

        }//end for

	NinjaUV_Edge_SaveEdgeList();
}//end proc


global proc NinjaUV_Edge_ClearEdges()
{
	textScrollList -e -ra EdgeSpline_list;
	NinjaUV_Edge_SaveEdgeList();
}//end proc


global proc NinjaUV_Edge_SelectEdges()
{
	string $Sel[] = `ls -hl`;
	if (`size $Sel` == 0)
	{
		$Sel = `ls -sl -fl -l`;
		doMenuComponentSelection($Sel[0], "edge");

    }

	$EdgeList = `textScrollList -q -si EdgeSpline_list`;
	string $SelEdgeList[] = {};
	for ($i = 0; $i < (`size $EdgeList`); $i++)
		{
			stringArrayInsertAtIndex(0, $SelEdgeList, ($Sel[0] + "." + $EdgeList[$i]));
			//select -add ($Sel[0] + "." + $EdgeList[$i]);
        }

	//print $SelEdgeList;
	select -r $SelEdgeList;


}//end proc

global proc NinjaUV_Edge_SaveEdgeList()
{
	string $Object[] = `ls -hl -l`;
	if (`objExists $Object[0]` != 1)
		{
			 $Object = `ls -sl -fl -l`;
		}

	string $EdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $EdgeListString = stringArrayToString($EdgeList, ", ");

	if (`attributeExists ("UV_CutEdges") $Object[0]` == 0 )
		{
			//select $Object;
			addAttr -longName ("UV_CutEdges") -dt "string" -h false $Object;

		}//end if

	setAttr -type "string" ($Object[0] + (".UV_CutEdges")) $EdgeListString;
}

global proc NinjaUV_Edge_LoadEdgeList()
{
	string $EdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $Sel[] = `ls -hl`;
	if (`size $Sel` == 0)
	{
		$Sel = `ls -sl -fl -l`;
	}
	string $EdgeListString = `getAttr ($Sel[0] + (".UV_CutEdges"))`;
	string $buf[] = {};
	int $numTokens = `tokenize $EdgeListString "," $buf`;

	string $NewEdgeList[] = {};
	textScrollList -e -ra EdgeSpline_list;
	for ($i = 0; $i < (`size $buf`); $i++)
		{
			textScrollList -e -append $buf[$i] EdgeSpline_list;
        }//end for
	NinjaUV_Edge_SelectAllEdgeList;
}


global proc NinjaUV_Edge_SelectAllEdgeList()
{
	string $Sel[] = `ls -hl`;

	if (`size $Sel` == 0)
		{
			 $Sel = `ls -sl -fl -l`;
        }
	doMenuComponentSelection($Sel[0], "edge");
	string $EdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $SelectEdges[] = {};
	for ($i = 0; $i < (`size $EdgeList`); $i++)
		{
			stringArrayInsertAtIndex (0, $SelectEdges, ($Sel[0] + "." + $EdgeList[$i]) );
			//select -add ($Sel[0] + "." + $EdgeList[$i]);
		}
	select $SelectEdges;
}

global proc NinjaUV_AutoSelectCutEdges()
{
	$StartSelection = `ls -sl -fl -l`;
	ConvertSelectionToEdges;
	polySelectConstraint -m 2 -bo true -sh false -cr false;
	$BorderEdges = `ls -sl -fl -l`;
	//reset Edge Contraints
	polySelectConstraint -m 0 -bo falase -sh false -cr false;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NinjaUV_AutoCreateUVPath
global proc NinjaUV_AutoCreateUVPath(string $Path_Type, string $Mesh_Name)
{
	if (`objExists ("UV_" + $Path_Type + "_" + $Mesh_Name)`)
	{
		confirmDialog -message "Spline Already Exitsts";
	}//end if

	else
	{
		$Selected_Edges = `ls - sl -fl`;
		for ($d = `size $Selected_Edges`; $d >= 1; $d--)
			{
				duplicateCurve -name "BK_Temp_UV_Curve" -ch 1 -rn 0 -local 0  $Selected_Edges[$d - 1];
			}
		select -r "BK_Temp_UV_Curve*";
		$Selected_Curves = `ls -sl -fl`;
		if (`size $Selected_Edges` > 1)
			{
				attachCurve -ch 1 -rpo 0 -kmk 1 -m 0 -bb 1 -bki 0 -p 0.1  -name ("UV_" + $Path_Type + "_" + $Mesh_Name) $Selected_Curves;
				DeleteHistory;
				delete $Selected_Curves;
			}
		else
			{
			rename `shortNameOf ($Selected_Curves[0])` ("UV_" + $Path_Type + "_" + $Mesh_Name);
			}
		//rebuildCurve -ch 1 -rpo 1 -rt 1 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 0 -d 1 -tol 0.01 ("UV_" + $Path_Type);

	}//end else
}//end proc

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NinjaUV_CreateUVPath

global proc NinjaUV_CreateUVPath(string $Path_Type)
{
$Mesh_Name = `ls -hl`;

	if (`objExists ("UV_" + $Path_Type + "_" + $Mesh_Name[0])`)
	{
		confirmDialog -message "Spline Already Exitsts";
	}

	else
	{
		$Selected_Edges = `ls -sl -fl`;
		for ($d = `size $Selected_Edges`; $d >= 1; $d--)
			{
				duplicateCurve -name "BK_Temp_UV_Curve" -ch 1 -rn 0 -local 0  $Selected_Edges[$d - 1];
			}
		select -r "BK_Temp_UV_Curve*";
		$Selected_Curves = `ls -sl -fl`;
		attachCurve -ch 1 -rpo 0 -kmk 1 -m 0 -bb 1 -bki 0 -p 0.1  -name ("UV_" + $Path_Type + "_" + $Mesh_Name[0]) $Selected_Curves;
		DeleteHistory;
		delete $Selected_Curves;
	}
}

///////////////////////////////////////////////////
global proc NinjaUV_CreateBKPath()
{
$Mesh_Name = `ls -hl`;

		$Selected_Edges = `ls -sl -fl`;
		for ($d = `size $Selected_Edges`; $d >= 1; $d--)
			{
				duplicateCurve -name "BK_Temp_UV_Curve" -ch 1 -rn 0 -local 0  $Selected_Edges[$d - 1];
			}
		select -r "BK_Temp_UV_Curve*";
		$Selected_Curves = `ls -sl -fl`;
		attachCurve -ch 1 -rpo 0 -kmk 1 -m 0 -bb 1 -bki 0 -p 0.1  -name ("BK_Path_" + $Mesh_Name[0]) $Selected_Curves;
		DeleteHistory;
		delete $Selected_Curves;

}

///////////////////////////////////////////////////////////////////////////////////////////////////NinjaUV_AlignCamToFace
global proc NinjaUV_AlignCamToFace()
{
	$selected = `ls -sl -fl`;
	$Cam_UV = `polyProjection -ch 1 -type Planar -ibd off -md b $selected`;
	$FX = `getAttr ($Cam_UV[0] + ".rotateX")`;
	$FY = `getAttr ($Cam_UV[0] + ".rotateY")`;
	$FZ = `getAttr ($Cam_UV[0] + ".rotateZ")`;

	if ($FX < 0)
	{
	//$FX = ($FX * -1);
	}

	delete $Cam_UV;
	$camera = `modelPanel -q -camera modelPanel4`;
	setAttr ($camera + ".rotateX") $FX;
	setAttr ($camera + ".rotateY") $FY;
	setAttr ($camera + ".rotateZ") $FZ;
	FrameSelected;
}

///////////////////////////////////////////////////////////////////////////////////////////////////Get Texture Sizes
global proc NinjaUV_GetTextureSize(string $Tex_Type)
{
	//string $sel_face[] ={};
	$sel_face = `ls -sl -fl -l`;
	$TextureNode = NinjaUV_GetFaceTexture($sel_face[0]);
	//print $TextureNode;
	//print ("TextureName = " + $TextureNode);
	//print $Tex_Type;

	string $Selected[] = `ls -sl -fl -l`;
	string $obj_name[];
	tokenize $Selected[0] "." $obj_name;//get object name

	int $Xsize = 0;
	int $Ysize = 0;

	int $ColorTestTexture = 0;
	$ColorTestTexture = catchQuiet (`getAttr ($TextureNode + ".fileTextureName")`);
	//print (" Has Texture = " + $ColorTestTexture);

	if ($TextureNode != "" && $ColorTestTexture == 0)
		{
			//print (`getAttr ($TextureName + ".fileTextureName")`);
			if ($Tex_Type == "diffuse" )
			{
				$Xsize = getAttr ($TextureNode + ".outSizeX");
				$Ysize = getAttr ($TextureNode + ".outSizeY");
			}

			if ($Xsize != 0 && $Ysize != 0)
			{
				floatField -e -v $Xsize Tex_ScaleU ;
				floatField -e -v $Ysize Tex_ScaleV ;
				NinjaUV_SetPixelRatio();

            }

		}

}//end get texture size


//////////////////////////////////////////////////////////////////////////////////////////Straighten STUFF////////////////////////////////////////////////////////////////////////////////////////
//																																															//
//																																															//
//																																															//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////NinjaUV_QuickStraighten


global proc NinjaUV_FlattenBorder()
{
	PolySelectConvert 4;
	SelectUVShell ;
	string $UV_Shell[] = `ls -sl -fl`;
	SelectUVBorder;
	string $UV_Border[] =`ls -sl -fl`;

	NinjaUV_StraightenUV Edge;
	select $UV_Shell;
	select -d $UV_Border;
	NinjaUV_QuickFix;

}//end proc





global proc NinjaUV_StraightenUVSelection(string $Direction, string $Parent)
{
	global int $NinjaUV_UIWidth;
	ConvertSelectionToUVs;
	$SelectedUVs =`ls -sl -fl -l`;
	string $Shells[] = NinjaUV_CollectShells();
	int $AngleTest = `intSliderGrp -q -v ("UVStraighten_Angle" + $Parent)`;

	$startTime = `timerX`;
	text -e -l "Straighten Process: Collecting Data " -w $NinjaUV_UIWidth ("UVStraighten_process" + $Parent);
	for ($x = 0; $x < `size $Shells`; $x++)
	{
		string $UVEdgeListArrayV[] = {};
		string $UVEdgeListArrayH[] = {};
		string $Single_Shell[] = stringToStringArray($Shells[$x], ",");//convert the Shells into an Array
		string $Edges[] = {};
		if (`size $SelectedUVs` < `size $Single_Shell`)
		{
			$Edges = `polyListComponentConversion -toEdge  $SelectedUVs`;
		}

		else
		{
			$Edges = `polyListComponentConversion -toEdge  $Single_Shell`;
        }
		$Edges = `ls -fl -l $Edges`;//flatten edge array

		/////////Collect Edges
		progressBar -edit -pr 0 ("UVStraighten_progressbar" + $Parent);
		progressBar -edit -maxValue `size $Edges` ("UVStraighten_progressbar" + $Parent);
		for ($e = 0; $e < `size $Edges`; $e++)
		{
			$EdgeToUV = `polyListComponentConversion -toUV $Edges[$e]`;
			$EdgeToUV = `ls -fl -l $EdgeToUV`;

			//Check EdgeToUV to see if there are UVs in the orignial selection and in the Current UVShell
			string $UVEdgeArray[] = {};
			for ($c = 0; $c < `size $EdgeToUV`; $c++)
				{
     				if (stringArrayContains($EdgeToUV[$c], $SelectedUVs) && stringArrayContains($EdgeToUV[$c], $Single_Shell))
					{
						stringArrayInsertAtIndex(0, $UVEdgeArray, $EdgeToUV[$c]);
                    }
				}


			//Check if there are only 2 points and Add the 2 points as a string to an Array
			if (`size $UVEdgeArray` == 2 )
			{
				string $UVEdge = stringArrayToString($UVEdgeArray,",");
				$Angle = eval ("NinjaUV_GetEdgeAngle " + $UVEdgeArray[0] + " " + $UVEdgeArray[1]);
				if ($Angle <= 90 && $Angle >= (90 - $AngleTest) )
					{

						stringArrayInsertAtIndex(0, $UVEdgeListArrayV, $UVEdge);
					}

				if ($Angle >= 0 && $Angle <= $AngleTest)
					{
						stringArrayInsertAtIndex(0, $UVEdgeListArrayH, $UVEdge);
					}

            }//end if

			//Check if there are 3 or 4 points
			else //4 points and 3 poitns mean shared uV's in the same Shell
			{
				$EdgeToFace = `polyListComponentConversion -toFace $Edges[$e]`;
				$EdgeToFace = `ls -fl -l $EdgeToFace`;
				//select $EdgeToFace;

				//iterate thru each face
				for ($f = 0; $f < `size $EdgeToFace`; $f++)
				{
					$FaceToUV = `polyListComponentConversion -toUV $EdgeToFace[$f]`;
					$FaceToUV = `ls -fl -l $FaceToUV`;
					//will have 4 uv's

					string $UVEdgeArrayPoints[] = {};
					//iterate thru each faceUV
					for ($p = 0; $p < `size $FaceToUV`; $p++)
					{
						//Compare FaceToUV and $UVEdgeArray
						if (stringArrayContains($FaceToUV[$p], $UVEdgeArray))
						{
							stringArrayInsertAtIndex(0, $UVEdgeArrayPoints, $FaceToUV[$p]);
						}

                    }

					if (`size $UVEdgeArrayPoints` == 2)
						{
							string $UVEdge = stringArrayToString($UVEdgeArrayPoints,",");
							$Angle = eval ("NinjaUV_GetEdgeAngle " + $UVEdgeArrayPoints[0] + " " + $UVEdgeArrayPoints[1]);
							if ($Angle <= 90 && $Angle >= (90 - $AngleTest) )
								{

									stringArrayInsertAtIndex(0, $UVEdgeListArrayV, $UVEdge);
								}

							if ($Angle >= 0 && $Angle <= $AngleTest)
								{
									stringArrayInsertAtIndex(0, $UVEdgeListArrayH, $UVEdge);
								}

						}//end if

                }

            }//end if
			progressBar -edit -step 1 ("UVStraighten_progressbar" + $Parent);
			$totalTime = `timerX -startTime $startTime`;
			text -e -l ("Straighten Process: Collecting Data " + $totalTime) -w $NinjaUV_UIWidth ("UVStraighten_process" + $Parent);
        }//end for e


		if ($Direction == "Horizontal" || $Direction == "Both")
		{
			//Straigten U Horizontal
			if (`size $UVEdgeListArrayH` != 0)
			{
				progressBar -edit -pr 0 ("UVStraighten_progressbar" + $Parent);
				progressBar -edit -maxValue `size $UVEdgeListArrayH` ("UVStraighten_progressbar" + $Parent);
			}
			$UVEdgeListArrayH = `sort $UVEdgeListArrayH`;
			while (`size $UVEdgeListArrayH` != 0)
			{
				string $TestedEdges[] = {};
				string $Selected_UVs[] = `ls -sl -fl -l`;
				//print `size $UVEdgeListArrayH`;
				string $SingleUVEdgeA[] = stringToStringArray($UVEdgeListArrayH[0], ",");//convert the EdgeListArray into an Array
				string $EdgeLoopListU[] = $SingleUVEdgeA;
				string $RemoveArrayU[] = {};
				stringArrayInsertAtIndex(0, $RemoveArrayU, $UVEdgeListArrayH[0]);

				//find the EdgeLoop
				int $SizeStart = 0;
				int $SizeEnd = 10000000000;
				do
				{
					$SizeStart = `size $Selected_UVs`;
					for ($b = 0; $b < `size $UVEdgeListArrayH`; $b++)
						{

							if (stringArrayContains($UVEdgeListArrayH[$b], $TestedEdges) == 0)
								{
									string $SingleUVEdgeB[] = stringToStringArray($UVEdgeListArrayH[$b], ",");
									if (stringArrayContains($SingleUVEdgeB[0], $EdgeLoopListU) || stringArrayContains($SingleUVEdgeB[1], $EdgeLoopListU))
									{
										//check if point Does Not Exist in the Edge loop array then add it to the edge loop
										for ($p = 0; $p < `size $SingleUVEdgeB`; $p++)
										{
											if (stringArrayContains($SingleUVEdgeB[$p], $EdgeLoopListU) == 0)
											{
												stringArrayInsertAtIndex(0, $EdgeLoopListU, $SingleUVEdgeB[$p]);//add only the non existing point to the list
												stringArrayInsertAtIndex(0, $TestedEdges, $UVEdgeListArrayH[$b]);
												stringArrayInsertAtIndex(0, $RemoveArrayU, $UVEdgeListArrayH[$b]);
												break;

											}//end if
										}//end for

								   }
								}


						}//end for b
						$UVEdgeListArrayH = stringArrayRemoveExact($RemoveArrayU, $UVEdgeListArrayH);
						$SizeEnd = `size $EdgeLoopListU`;
						$Selected_UVs = $EdgeLoopListU;

				}//end do

				while ($SizeStart != $SizeEnd);
				select $EdgeLoopListU;
				NinjaUV_StraightenV;
				$totalTime = `timerX -startTime $startTime`;
				progressBar -edit -step `size $EdgeLoopListU` ("UVStraighten_progressbar" + $Parent);
				text -e -l ("Straighten Process: Straigten Horizontal " + $totalTime) ("UVStraighten_process" + $Parent);
			}//end while
		}//end if Straighten Horizontal


		if ($Direction == "Vertical" || $Direction == "Both")
		{
			//Straighten V Vertical
			if (`size $UVEdgeListArrayV` != 0)
			{
				progressBar -edit -pr 0 ("UVStraighten_progressbar" + $Parent);
				progressBar -edit -maxValue `size $UVEdgeListArrayV` ("UVStraighten_progressbar" + $Parent);
			}
			$UVEdgeListArrayV = `sort $UVEdgeListArrayV`;
			while (`size $UVEdgeListArrayV` != 0)
			{

				string $RemoveArrayV[] = {};
				string $TestedEdges[] = {};
				string $Selected_UVs[] = `ls -sl -fl -l`;
				string $SingleUVEdgeA[] = stringToStringArray($UVEdgeListArrayV[0], ",");//convert the EdgeListArray into an Array
				string $EdgeLoopListV[] = $SingleUVEdgeA;
				stringArrayInsertAtIndex(0, $RemoveArrayV, $UVEdgeListArrayV[0]);

				int $SizeStart = 0;
				int $SizeEnd = 10000000000;
				do
				{
					$SizeStart = `size $Selected_UVs`;
					for ($b = 0; $b < `size $UVEdgeListArrayV`; $b++)
						{
							if (stringArrayContains($UVEdgeListArrayV[$b], $TestedEdges) == 0)
								{
									string $SingleUVEdgeB[] = stringToStringArray($UVEdgeListArrayV[$b], ",");
									if (stringArrayContains($SingleUVEdgeB[0], $EdgeLoopListV) || stringArrayContains($SingleUVEdgeB[1], $EdgeLoopListV))
										{
											//check if point Does Not Exist in the Edge loop array then add it to the edge loop
											for ($p = 0; $p < `size $SingleUVEdgeB`; $p++)
												{
													if (stringArrayContains($SingleUVEdgeB[$p], $EdgeLoopListV) == 0)
													{
														stringArrayInsertAtIndex(0, $EdgeLoopListV, $SingleUVEdgeB[$p]);//add only the non existing point to the list
														stringArrayInsertAtIndex(0, $TestedEdges, $UVEdgeListArrayV[$b]);
														stringArrayInsertAtIndex(0, $RemoveArrayV, $UVEdgeListArrayV[$b]);
														break;

													}//end if
												}//end for
										}

								}

						}//end for b

						$UVEdgeListArrayV = stringArrayRemoveExact($RemoveArrayV, $UVEdgeListArrayV);
						$SizeEnd = `size $EdgeLoopListV`;
						$Selected_UVs = $EdgeLoopListV;

				}//end do

				while ($SizeStart != $SizeEnd);
				select $EdgeLoopListV;
				NinjaUV_StraightenU;
				$totalTime = `timerX -startTime $startTime`;
				progressBar -edit -step `size $EdgeLoopListV` ("UVStraighten_progressbar" + $Parent);
				text -e -l ("Straighten Process: Straigten Vertical " + $totalTime) ("UVStraighten_process" + $Parent);
			}//end while
		}// end if Straigten Vertical

	}//end for shell


	$totalTime = `timerX -startTime $startTime`;
	text -e -l ("Straighten Process: Done " + $totalTime) -w $NinjaUV_UIWidth ("UVStraighten_process" + $Parent);
}//end proc


global proc NinjaUV_StraightenU()
{
	float $UV_Extents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
	float $UV_Center = (($UV_Extents[0] + $UV_Extents[1]) / 2 );//find U center
	polyEditUV -relative false -u $UV_Center;//move uv's to mid
}


global proc NinjaUV_StraightenV()
{
	float $UV_Extents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
	float $UV_Center = (($UV_Extents[2] + $UV_Extents[3]) / 2 );
	polyEditUV -relative false -v $UV_Center;//edit interior edges
}


global proc NinjaUV_CalculateUVSize(string $Direction)
{
	PolySelectConvert 4;
	string $SelUV[] = `ls -sl -fl -l`;
	float $UV_Bounds[] = `polyEvaluate -bc2`; //xmin xmax ymin ymax

	if ($Direction == "U")
	{
		float $DistDiff = ($UV_Bounds[0] - $UV_Bounds[1]);
		$UDist = (sqrt($DistDiff * $DistDiff));
		floatField -e -v $UDist UV_Move_AmountBar;
    }

	if ($Direction == "V")
	{
		float $DistDiff = ($UV_Bounds[2] - $UV_Bounds[3]);
		$VDist = (sqrt($DistDiff * $DistDiff));
		floatField -e -v $VDist UV_Move_AmountBar;
    }

	if ($Direction == "Pixel")
	{
		NinjaUV_GetTextureSize color;
	}
}

/////////////////////////////////////////////////////////////////////////////
global proc NinjaUV_SetUVToMid()
{

	NinjaUV_SetUToZero();
	NinjaUV_SetVToZero();
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	$UV_Bounds = `polyEvaluate -bc2`; //xmin xmax ymin ymax
	$OffsetU = (($UV_Bounds[0] + $UV_Bounds[1]) /2);
	$OffsetV = (($UV_Bounds[2] + $UV_Bounds[3]) /2);
	polyEditUV  -u ($OffsetU * -1)  -v ($OffsetV * -1) ;//moves the center to 0 0
	polyEditUV  -u .5  -v .5;
	select $SelUV;
}


global proc NinjaUV_SetUToZero()
{
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	$UV_Bounds = `polyEvaluate -bc2`; //xmin xmax ymin ymax

	float $CenterOffset = 0;
	$SnapOrgin = `radioButtonGrp -q -select Snap_Point`;
	if ($SnapOrgin == 2)
	{
		float $DistDiff = ($UV_Bounds[0] - $UV_Bounds[1]);
		$CenterOffset = (sqrt($DistDiff * $DistDiff) /2 );
    }

	$Offset_OrginU = ($UV_Bounds[0] * -1);
	polyEditUV  -u ($Offset_OrginU - $CenterOffset);
	select $SelUV;
}
///////////////////////////////////////////////////////////////////////////
global proc NinjaUV_SetVToZero()
{
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	$UV_Bounds = `polyEvaluate -bc2`;//xmin xmax ymin ymax

	float $CenterOffset = 0;
	$SnapOrgin = `radioButtonGrp -q -select Snap_Point`;
	if ($SnapOrgin == 2)
	{
		float $DistDiff = ($UV_Bounds[2] - $UV_Bounds[3]);
		$CenterOffset = (sqrt($DistDiff * $DistDiff) /2 );
		//print $CenterOffset;
    }

	$Offset_OrginV = ($UV_Bounds[2] * -1);
	polyEditUV  -v ($Offset_OrginV - $CenterOffset);
	select $SelUV;
}

global proc NinjaUV_SetUToOne()
{
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	$UV_Bounds = `polyEvaluate -bc2`;//xmin xmax ymin ymax

	float $CenterOffset = 0;
	$SnapOrgin = `radioButtonGrp -q -select Snap_Point`;
	if ($SnapOrgin == 2)
	{
		float $DistDiff = ($UV_Bounds[0] - $UV_Bounds[1]);
		$CenterOffset = (sqrt($DistDiff * $DistDiff) /2 );
		//print $CenterOffset;
    }

	$Offset_OrginU = (1 - $UV_Bounds[1]);
	polyEditUV  -u ($Offset_OrginU + $CenterOffset);
	select $SelUV;
}

global proc NinjaUV_SetVToOne()
{
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	$UV_Bounds = `polyEvaluate -bc2`;//xmin xmax ymin ymax

	float $CenterOffset = 0;
	$SnapOrgin = `radioButtonGrp -q -select Snap_Point`;
	if ($SnapOrgin == 2)
	{
		float $DistDiff = ($UV_Bounds[2] - $UV_Bounds[3]);
		$CenterOffset = (sqrt($DistDiff * $DistDiff) /2 );
		//print $CenterOffset;
    }

	$Offset_OrginV = (1 - $UV_Bounds[3]);
	polyEditUV  -v ($Offset_OrginV + $CenterOffset) ;
	select $SelUV;
}

global proc NinjaUV_ResetToZero()
{
	PolySelectConvert 4;
	$SelUV = `ls- sl -fl`;
	string $UVShells[] = eval ("NinjaUV_CollectShells");
	for ($s = 0; $s < `size $UVShells`; $s++)
		{

			string $Single_Shell[] = {};
			tokenize $UVShells[$s] "," $Single_Shell;
			select -cl;
			select $Single_Shell;
			float $UV_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax

				int $Xmin = $UV_Bounds[0];
				int $Ymin = $UV_Bounds[2];

				if ($UV_Bounds[0] < 0)
				{
					$Xmin = ($Xmin - 1);
				}

				if ($UV_Bounds[2] < 0)
				{
					$Ymin = ($Ymin - 1);
				}

				print $Xmin;
				print $Ymin;

				//$Offset_OrginV = (1 - $UV_Bounds[3]);
				polyEditUV -u ($Xmin * -1) -v ($Ymin * -1);

       }
	select $SelUV;
}

///////////////////////////////////////////////////////////////////////////////
global proc NinjaUV_NormalizeU ()
{
	float $NS = `floatField -q -v Normalize_Scale`;
	//print $NS;
	NinjaUV_SetUToZero();
	NinjaUV_SetVToZero();
	PolySelectConvert 4;
	$UV_Bounds = `polyEvaluate -bc2`;
	$Offset_OrginU = ((1 / $UV_Bounds[1]) * $NS);
	polyEditUV -pu 0 -pv 0 -su $Offset_OrginU;
	polyEditUV -pu 0 -pv 0 -sv $Offset_OrginU;
}
///////////////////////////////////////////////////////////////////////
global proc NinjaUV_NormalizeV()
{
	float $NS = `floatField -q -v Normalize_Scale`;
	NinjaUV_SetUToZero();
	NinjaUV_SetVToZero();
	PolySelectConvert 4;
	$UV_Bounds = `polyEvaluate -bc2`;
	$Offset_OrginV = ((1 / $UV_Bounds[3])* $NS);
	polyEditUV -pu 0 -pv 0 -su $Offset_OrginV;
	polyEditUV -pu 0 -pv 0 -sv $Offset_OrginV;
}
////////////////////////////////////////////////////////////////////////////

global proc NinjaUV_CutAndFix(string $Type)
{
 	global string $UVEdgeSelection[];
	$UVEdgeSelection =`filterExpand -sm 32`;

	select $UVEdgeSelection;
	polyMapCut;
	ConvertSelectionToUVs;
	if ($Type == "Shell")
	{
		polySelectBorderShell 0;
		string $UVShell[] = `ls -sl -fl -l`;
		//SelectUVBorder;
		//string $BorderUVs[] = `ls -sl -fl -l`;
		//string $DiffUV[] = stringArrayRemoveExact ($BorderUVs, $UVShell);
		//print $DiffUV;
		select  $UVShell;
		//select -d $DiffUV[0];

	}
	//NinjaUV_QuickUnfold;
	NinjaUV_QuickFix();
}


global proc NinjaUV_SewNearestEdge()
{

	string $UVShells[] = NinjaUV_CollectShells();
	string $SewEdges[] = {};
	string $Edges[] = {};
	string $SewEdge;
	float $MoveXDist;
	float $MoveYDist;
	for ($s = 0; $s < `size $UVShells`; $s++)
		{
			float $TestDistance = 1000000000000000;
			string $Single_Shell[] = {};
			tokenize $UVShells[$s] "," $Single_Shell;
			select -r $Single_Shell;
			$UVShellToFaces = `polyListComponentConversion -toFace $Single_Shell`;
			$UVShellToFaces = `ls -fl -l $UVShellToFaces`;

			ConvertSelectionToEdges;
			$Edges = `ls -sl -fl -l`;

			for ($e = 0; $e < `size $Edges`; $e++)
			{
				$EdgeToUV = `polyListComponentConversion -toUV $Edges[$e]`;
				$EdgeToUV = `ls -fl -l $EdgeToUV`;

				if (`size $EdgeToUV` == 4)
				{
					select $EdgeToUV;
					float $UVextents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax

					float $Xdist = ($UVextents[1] - $UVextents[0]);
					float $Ydist = ($UVextents[3] - $UVextents[2]);

					$Distance = `sqrt (($Xdist*$Xdist) + ($Ydist*$Ydist))`;

					if ($Distance < $TestDistance)
					{
						$TestDistance = $Distance;
						$SewEdge = $Edges[$e];
						$MoveXDist = $Xdist;
						$MoveYDist = $Ydist;
					}

				}
			}//end for e

			select $Single_Shell;
			//polyEditUV -u $MoveXDist -v $MoveYDist ;
			stringArrayInsertAtIndex(0,$SewEdges, $SewEdge);
        }
	polyMapSewMove -nf 10 -lps 0 -ch 1 $SewEdges;

}

global proc NinjaUV_SewBestEdge()
{

	string $UVShells[] = NinjaUV_CollectShells();
	string $SewEdges[] = {};
	string $Edges[] = {};
	string $SewEdge;
	float $MoveXDist;
	float $MoveYDist;
	for ($s = 0; $s < `size $UVShells`; $s++)
		{
			float $TestDistance = 1000000000000000;
			string $Single_Shell[] = {};
			tokenize $UVShells[$s] "," $Single_Shell;
			select -r $Single_Shell;
			//$UVShellToFaces = `polyListComponentConversion -toFace $Single_Shell`;
			//$UVShellToFaces = `ls -fl -l $UVShellToFaces`;
			float $ShellExtents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax

			ConvertSelectionToEdges;
			$Edges = `ls -sl -fl -l`;
			float $EdgeExtents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
			float $EdgeXdist = ($EdgeExtents[1] - $EdgeExtents[0]);
			float $EdgeYdist = ($EdgeExtents[3] - $EdgeExtents[2]);

			if ($ShellExtents[1] == $EdgeExtents[1])
				{
					$EdgeXdist = ($EdgeXdist * -1);
                }

			select $Single_Shell;
			polyEditUV -u $EdgeXdist -v $EdgeYdist;


			ConvertSelectionToEdges;
			$Edges = `ls -sl -fl -l`;

			for ($e = 0; $e < `size $Edges`; $e++)
			{
				$EdgeToUV = `polyListComponentConversion -toUV $Edges[$e]`;
				$EdgeToUV = `ls -fl -l $EdgeToUV`;

				if (`size $EdgeToUV` == 4)
				{
					//pause -sec 1;
					select $Edges[$e];
					float $UVextents[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax

					float $Xdist = ($UVextents[1] - $UVextents[0]);
					float $Ydist = ($UVextents[3] - $UVextents[2]);

					//$Distance = `sqrt (($Xdist*$Xdist) + ($Ydist*$Ydist))`;

					//if ($Distance < $TestDistance)
					//{
					//	$TestDistance = $Distance;
					//	$SewEdge = $Edges[$e];
					//	$MoveXDist = $Xdist;
					//	$MoveYDist = $Ydist;
					//}

					if ($Xdist == 0)
					{
						$SewEdge = $Edges[$e];
						polyMapSewMove -nf 10 -lps 0 -ch 1 $SewEdge;
                    }

				}
			}//end for e

			//select $Single_Shell;
			//polyEditUV -u $MoveXDist -v $MoveYDist ;
			//stringArrayInsertAtIndex(0,$SewEdges, $SewEdge);

        }

	//select $SewEdges;
	//error;
	//polyMapSewMove -nf 10 -lps 0 -ch 1 $SewEdges;

}


global proc NinjaUV_ScaleUV (string $Direction)
{
	$UV_Scale = (`floatField -q -v UV_ScaleValue`);
	$PivotLocation = `radioButtonGrp  -q -select UVScaleLocation `;
	float $OX;
	float $OY;


	if ($PivotLocation == 1)
		{
			PolySelectConvert 4;
			float $UV_pos[] =`polyEvaluate -bc2`;// xmin xmax ymin ymax,
			$OX = $UV_pos[0];
			$OY = $UV_pos[2];

		}


	if ($PivotLocation == 2)
		{
			$SelShape = `ls -sl -o -dag -ni -type "mesh"`;
			float $UVPivot[] = `getAttr ($SelShape[0] + ".uvPivot")`;
			$OX = $UVPivot[0];
			$OY = $UVPivot[1];
		}

	if ($Direction == "U")
		{
			polyEditUV -pu $OX -pv $OY -su $UV_Scale;
		}

	if ($Direction == "V")
		{
			polyEditUV -pu $OX -pv $OY -sv $UV_Scale;
		}

	if ($Direction == "UV")
		{
			polyEditUV -pu $OX -pv $OY -sv $UV_Scale -su $UV_Scale;
		}
}



///////////////////////////////////////////////////////////////////////////////////////////////////Move UV
global proc NinjaUV_MoveUV(string $direction, string $UIField)
{

	float $MoveAmount;
	if ($UIField != "Nil")
	{
		$MoveAmount = `floatField -q -v $UIField`;
    }

	PolySelectConvert 4;
	$Sel = `ls -sl -fl -l`;

	if ($direction == "UP")
		{
			polyEditUV  -v $MoveAmount ;
		}
	if ($direction == "Down")
		{
			polyEditUV  -v ($MoveAmount * -1) ;
		}
	if ($direction == "Left")
		{
			polyEditUV  -u ($MoveAmount * -1) ;
		}
	if ($direction == "Right")
		{
			polyEditUV  -u $MoveAmount ;
		}

	if ($direction == "UP_Left")
		{
			polyEditUV  -v $MoveAmount ;
			polyEditUV  -u ($MoveAmount * -1);
		}
	if ($direction == "UP_Right")
		{
			polyEditUV  -v $MoveAmount ;
			polyEditUV  -u $MoveAmount ;
		}
	if ($direction == "Down_Left")
		{
			polyEditUV  -v ($MoveAmount * -1);
			polyEditUV  -u ($MoveAmount * -1);
		}
	if ($direction == "Down_Right")
		{
			polyEditUV  -v ($MoveAmount * -1);
			polyEditUV  -u $MoveAmount ;
		}

	if ($direction == "Zero")
		{
			NinjaUV_SetUToZero();
			NinjaUV_SetVToZero();
		}//end proc


	select $Sel;
} //end proc

///////////////////////////////////////////////////////////////////////////////////////////////////Align UV
global proc NinjaUV_AlignShells(string $Direction)
{
		SelectUVShell;
		float $UV_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
		$Selection =`ls -sl -fl`;

		string $UVs[] = `ls -sl -fl`;//base uv's
		string $Test_UVs[] = `ls -sl -fl` ;
		string $Shell[];
		string $Shell_string;
		string $Shell_array[];

		for ($s = 0; $s < `size $UVs`; $s++)
		{
			$test_UV = stringArrayContains ($UVs[$s], $Test_UVs);// checks to see if the UV is in the array after removing shell
			if ($test_UV == 1)
				{
					select -r $UVs[$s];
					SelectUVShell ;
					string $Shell[] = `ls -sl -fl`;//flattens uv selection
					string $Shell_string = stringArrayToString ($Shell,",");//converts array to string
					$new_UVs = stringArrayRemove ($Shell, $Test_UVs);//removes shells from base uvs
					$Test_UVs = $new_UVs;//updates UV array to remove shell
					stringArrayInsertAtIndex(0 , $Shell_array, $Shell_string);

					//work on shell
					//
					if ($Direction == "Top")
						{
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Bounds_Dist = ($UV_Bounds[3] - $Shell_Bounds[3]);
							polyEditUV  -v $Bounds_Dist;
						}//end if top

					if ($Direction == "Bot")
						{
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Bounds_Dist = ($UV_Bounds[2] - $Shell_Bounds[2]);
							polyEditUV  -v $Bounds_Dist;
						}//end if top

					if ($Direction == "Left")
						{
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Bounds_Dist = ($UV_Bounds[0] - $Shell_Bounds[0]);
							polyEditUV  -u $Bounds_Dist;
						}//end if top

					if ($Direction == "Right")
						{
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Bounds_Dist = ($UV_Bounds[1] - $Shell_Bounds[1]);
							polyEditUV  -u $Bounds_Dist;
						}//end if top

					if ($Direction == "Cen")
						{
							NinjaUV_SetUToZero;
							NinjaUV_SetVToZero;
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Shell_UCen = (($Shell_Bounds[0] + $Shell_Bounds[1])/2);
							float $Shell_VCen = (($Shell_Bounds[2] + $Shell_Bounds[3])/2);

							float $UBounds_Dist = (($UV_Bounds[0] + $UV_Bounds[1])/2);
							float $VBounds_Dist = (($UV_Bounds[2] + $UV_Bounds[3])/2);

							polyEditUV  -u ($Shell_UCen * -1);
							polyEditUV  -v ($Shell_VCen * -1);

							polyEditUV  -u $UBounds_Dist;
							polyEditUV  -v $VBounds_Dist;
						}//end if top

					if ($Direction == "CenU")
						{
							NinjaUV_SetUToZero;

							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							float $Shell_UCen = (($Shell_Bounds[0] + $Shell_Bounds[1])/2);
							//float $Shell_VCen = (($Shell_Bounds[2] + $Shell_Bounds[3])/2);

							float $UBounds_Dist = (($UV_Bounds[0] + $UV_Bounds[1])/2);
							//float $VBounds_Dist = (($UV_Bounds[2] + $UV_Bounds[3])/2);

							polyEditUV  -u ($Shell_UCen * -1);
							//polyEditUV  -v ($Shell_VCen * -1);

							polyEditUV  -u $UBounds_Dist;
							//polyEditUV  -v $VBounds_Dist;
						}//end if top

					if ($Direction == "CenV")
						{
							//NinjaUV_SetUToZero;
							NinjaUV_SetVToZero;
							float $Shell_Bounds[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
							//float $Shell_UCen = (($Shell_Bounds[0] + $Shell_Bounds[1])/2);
							float $Shell_VCen = (($Shell_Bounds[2] + $Shell_Bounds[3])/2);

							//float $UBounds_Dist = (($UV_Bounds[0] + $UV_Bounds[1])/2);
							float $VBounds_Dist = (($UV_Bounds[2] + $UV_Bounds[3])/2);

							//polyEditUV  -u ($Shell_UCen * -1);
							polyEditUV  -v ($Shell_VCen * -1);

							//polyEditUV  -u $UBounds_Dist;
							polyEditUV  -v $VBounds_Dist;
						}//end if top


				}//end if test uv
		}//end for s
	select $Selection;
}//end NinjaUV_AlignShells

global proc NinjaUV_AlignUVShellEdge(string $Direction)
{
	PolySelectConvert 4;
	string $Sel_UVs[] = `ls -sl -fl`;

	float $Start_PointU[];
	float $Start_PointV[];
	float $End_PointU[];
	float $End_PointV[];
	select $Sel_UVs[0];
 	float $PointA[] = `polyEditUV  -q`;
	select $Sel_UVs[1];
	float $PointB[] = `polyEditUV  -q`;

	float $DistU;
	float $DistV;
	float $Left_Point[];

 	if ($PointA[0] < $PointB[0])
	 {
		$Left_Point = $PointA;
		$DistU = ($PointB[0] - $PointA[0]);
		$DistV = ($PointB[1] - $PointA[1]);

	 }

	 else
	 {
		$Left_Point = $PointB;
		$DistU = ($PointA[0] - $PointB[0] );
		$DistV = ($PointA[1] - $PointB[1]);
	 }


	 $angle = `atan2d $DistV $DistU`;
	 //$angle = `abs $angle`;
	 if ($angle > 0  )
	 {
		$angle = ($angle * -1);
	 }

	 if ($angle < 0 && $DistV < 0)
	 {
		$angle = ($angle * -1);
	 }

	 //print ("angle= " + $angle);
	 SelectUVShell;
	 polyEditUV -pu $Left_Point[0] -pv $Left_Point[1] -a $angle ;

	  if ($Direction == "Vertical")
	 {
		polyEditUV -pu $Left_Point[0] -pv $Left_Point[1] -a -90 ;
     }
	 select $Sel_UVs;

}

////////////////////////////////////////////////////////////////////////Smart Align
global proc Smart_NinjaUV_AlignShells()
{
	$Sel_obj = `ls -sl -l -fl`;
	string $A_edges[];
	$Total_A_edges = `size $A_edges`;
	string $B_edges[];
	$Total_B_edges = `size $B_edges`;
	float $BE[];
	float $AE[];
	string $Shared_Edges_Array[] = {};
	$edge_buffer = .1;
	string $Adjusted_UVs[] = {};

	for ($o = 0; $o < `size $Sel_obj`; $o++)//cycle thru each obj
		{
			select -r $Sel_obj[$o];
			PolySelectConvert 2;
			ConvertSelectionToShellBorder;
			$A_edges =`ls -sl -fl`;
			$Total_A_edges = `size $A_edges`;

			for ($ob = 1; $ob < (`size $Sel_obj`); $ob++)//cycle thru each obj + 1
				{
					select -r $Sel_obj[$ob];
					PolySelectConvert 2;
					ConvertSelectionToShellBorder;
					$B_edges =`ls -sl -fl`;
					$Total_B_edges = `size $B_edges`;
					//print $o;
					//print $ob;

					if ($o != $ob)//check to make sure obj is not checking edges on itself
						{
							for ($a = 0; $a < $Total_A_edges; $a++)
								{
									$AE = `xform -q -bb -ws $A_edges[$a]`;//finds bounding box of testing edge (xmin ymin zmin xmax ymax zmax)
									for ($b = 0; $b < $Total_B_edges; $b++)
										{
										$BE =`xform -q -bb -ws $B_edges[$b]`;//finds bounding box of edge  (xmin ymin zmin xmax ymax zmax)

										if (	($AE[0] - $edge_buffer) <= $BE[0] &&  ($AE[0] + $edge_buffer >= $BE[0] )//checks x min
											 &&	($AE[1] - $edge_buffer) <= $BE[1] &&  ($AE[1] + $edge_buffer >= $BE[1] )//checks y min
											 &&	($AE[2] - $edge_buffer) <= $BE[2] &&  ($AE[2] + $edge_buffer >= $BE[2] )//checks z min
											 &&	($AE[3] - $edge_buffer) <= $BE[3] &&  ($AE[3] + $edge_buffer >= $BE[3] )//checks x max
											 &&	($AE[4] - $edge_buffer) <= $BE[4] &&  ($AE[4] + $edge_buffer >= $BE[4] )//checks y min
											 &&	($AE[5] - $edge_buffer) <= $BE[5] &&  ($AE[5] + $edge_buffer >= $BE[5] )//checks z min

										   )

										   {

												select -r $A_edges[$a];
												PolySelectConvert 4;
												string $Sel[] = `ls -sl -fl`;
												float $UV_Bounds_A[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
												float $Target_U = $UV_Bounds_A[0];
												float $Target_V = $UV_Bounds_A[2];
												select -r $B_edges[$b];
												PolySelectConvert 4;

												float $UV_Bounds_B[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
												float $Start_U = $UV_Bounds_B[0];
												float $Start_V = $UV_Bounds_B[2];

												$u_dist = $Target_U - $Start_U;
												$v_dist = $Target_V - $Start_V;
												SelectUVShell;
												string $Shell[] = `ls -sl -fl`;
												polyEditUV -u $u_dist -v $v_dist;

											}//end if

										}//end for b
								}//end for a
						}//end if o != ob
				}//end for ob
		}//end for o
	select -r $Sel_obj;
}//end proc

////////////////////////////////////////////////////////////////////////Snap Align
global proc Snap_Align(string $SL)
{
	$Selected_UVs = `ls -sl -fl`;

	//Find the smallest shell
	select $Selected_UVs[0];
	SelectUVShell;
	$UV_Extents =`polyEvaluate -bc2`;//get the uv extents xmin xmax ymin ymax
	$DistU = $UV_Extents[1] - $UV_Extents[0];
	$DistV = $UV_Extents[3] - $UV_Extents[2];
	$AreaA = ($DistU * $DistV);

	select $Selected_UVs[1];
	SelectUVShell;
	$UV_Extents =`polyEvaluate -bc2`;//get the uv extents xmin xmax ymin ymax
	$DistU = $UV_Extents[1] - $UV_Extents[0];
	$DistV = $UV_Extents[3] - $UV_Extents[2];
	$AreaB = ($DistU * $DistV);

	float $Target_location[];
	float $Start_location[];

	if ($SL == "S")

    {
		if ($AreaA > $AreaB)
		{
			$Target_location = `polyEditUV -q -u $Selected_UVs[0]`;
			$Start_location =  `polyEditUV -q -u $Selected_UVs[1]`;
			select $Selected_UVs[1];
		}

		else
		{
			$Target_location = `polyEditUV -q -u $Selected_UVs[1]`;
			$Start_location = `polyEditUV -q -u $Selected_UVs[0]`;
			select $Selected_UVs[0];
		}
	}


	if ($SL == "L")

    {
		if ($AreaA < $AreaB)
		{
			$Target_location = `polyEditUV -q -u $Selected_UVs[0]`;
			$Start_location =  `polyEditUV -q -u $Selected_UVs[1]`;
			select $Selected_UVs[1];
		}

		else
		{
			$Target_location = `polyEditUV -q -u $Selected_UVs[1]`;
			$Start_location = `polyEditUV -q -u $Selected_UVs[0]`;
			select $Selected_UVs[0];
		}
	}

	SelectUVShell;
	$u_dist = $Target_location[0] - $Start_location[0];
	$v_dist = $Target_location[1] - $Start_location[1];
	polyEditUV -pu $Start_location[0] -pv $Start_location[1] -u $u_dist -v $v_dist;
}

global proc StoreNinjaUV_MatchUVs()
{
	global string $NinjaUV_MatchUVs_Target[];
	$NinjaUV_MatchUVs_Target = `ls -sl -fl`;
	print $NinjaUV_MatchUVs_Target;
}

global proc ClearNinjaUV_MatchUVs()
{
	global string $NinjaUV_MatchUVs_Target[];
	$NinjaUV_MatchUVs_Target = {};
}

global proc NinjaUV_MatchUVs()
{

	global string $NinjaUV_MatchUVs_Target[];

	ConvertSelectionToUVs;
	if (`size $NinjaUV_MatchUVs_Target` != 0)
	{
		select -d $NinjaUV_MatchUVs_Target;
    }

	string $TargetUV[] =`ls -sl -fl -l`;
	string $selUV[] =`ls -sl -fl -l`;

	progressBar -edit -pr 0 MatchUV_progress;
	progressBar -edit -maxValue ( (`size $selUV` ) * (`size $selUV`))MatchUV_progress;
	//if (`size $NinjaUV_MatchUVs_Target` != 0)
	//{
	//	progressBar -edit -maxValue ( (`size $NinjaUV_MatchUVs_Target` ) * (`size $NinjaUV_MatchUVs_Target`))MatchUV_progress;
    //}

	$buffer = `floatField -q -v NinjaUV_MatchUVs_buffer`;
	if (size($selUV) == 0)
	{
		error "Please select the UV point";
	}

	else
	{
		if ((`size $NinjaUV_MatchUVs_Target`) != 0)
			{
				$TargetUV = $NinjaUV_MatchUVs_Target;
			}

		for ($i = 0 ; $i < (`size $TargetUV`)  ; $i++)
			{
				float $TargetUvPos[] = `polyEditUV -query $TargetUV[$i]`;
				for ($j = 0 ; $j < (`size $selUV`)  ; $j++)
					{
						float $SelUvPos[] = `polyEditUV -query $selUV[$j]`;
						//test u
						if ( (($SelUvPos[0] + $buffer) > $TargetUvPos[0])  &&  (($SelUvPos[0] - $buffer) < $TargetUvPos[0]) && (($SelUvPos[1] + $buffer) > $TargetUvPos[1])  &&  (($SelUvPos[1] - $buffer) < $TargetUvPos[1]))
						{
							polyEditUV -relative false -uValue $TargetUvPos[0] $selUV[$j];
							polyEditUV -relative false -vValue $TargetUvPos[1] $selUV[$j];

						}//end if
					progressBar -edit -step 1 MatchUV_progress;
					}//end for j
			progressBar -edit -step 1 MatchUV_progress;
			}//end for i
	}//end else

	select $selUV ;
	if (`size $NinjaUV_MatchUVs_Target` != 0)
	{
		select -add $NinjaUV_MatchUVs_Target;
    }

}
///////////////////////////////////////////////////////////////////////////////////////////////////Multi Ninja_UV Map
global proc Multi_Ninja_UV_map()
{
	$Base_Object = `ls -hl`;
	DeleteHistory;
	$Selected = `ls -sl -fl`;
	$Total_Faces = `size $Selected`;
	for ($f = 0; $f < $Total_Faces; $f++)
		{
			select $Selected[$f];
			$Cam_UV = `polyProjection -ch 1 -type Planar -ibd off -md b $Selected[$f]`;
			$FX = `getAttr ($Cam_UV[0] + ".rotateX")`;
			$FY = `getAttr ($Cam_UV[0] + ".rotateY")`;
			$FZ = `getAttr ($Cam_UV[0] + ".rotateZ")`;

			if ($FX < 0)
			{
				$FX = ($FX * -1);
			}

			//undo;
			delete $Cam_UV;
			$camera = `modelPanel -q -camera modelPanel4`;
			setAttr ($camera + ".rotateX") $FX;
			setAttr ($camera + ".rotateY") $FY;
			setAttr ($camera + ".rotateZ") $FZ;
			doMenuComponentSelection($Base_Object[0], "facet");
			NinjaUV_FindSameMaterial();
			Calculate_Camera ();
		}//end for
	perspective;
	select $Selected;
	doMenuComponentSelection($Base_Object[0], "facet");
}//end proc

global proc NinjaUV_TubeMapping()
{

	$UnfoldIterations = `floatField -q -v Unfold_Iterations`;
	$CutEdges = `filterExpand -sm 32 -fp 1`;
	NinjaUV_UniformMapping;
	if (`size $CutEdges` != 0)
	{
		select $CutEdges;

    }
	ConvertSelectionToUVs;
	$selUVs = `ls -sl -fl -l`;
	string $UArray[] = {};
	string $VArray[] = {};
	int $AngleTest = `intSliderGrp -q -v UVStraighten_AngleMapParent`;

	for ($v = 0; $v < (`size $selUVs`); $v++)
		{
			float $UV[] = `polyEditUV -q $selUVs[$v]`;
			if ($UV[0] == 0)
			{
				stringArrayInsertAtIndex (0, $UArray, "0");
            }

			if ($UV[1] == 0)
			{
				stringArrayInsertAtIndex (0, $VArray, "0");
            }

        }
	polySelectBorderShell 0;
	if (`size $UArray` > `size $VArray`)
	{
		$UnfoldV = `unfold -i $UnfoldIterations -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us off`;
		//$UnfoldV = `polyOptUvs -i $UnfoldIterations -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 `;
    }

	else
	{
		$UnfoldU = `unfold -i $UnfoldIterations -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us off`;
		//$UnfoldU = `polyOptUvs -i $UnfoldIterations -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 `;
    }

	intSliderGrp -e -v 45 UVStraighten_AngleMapParent;
	NinjaUV_StraightenUVSelection Both MapParent;
	intSliderGrp -e -v $AngleTest UVStraighten_AngleMapParent;
	select $selUVs;

	NinjaUV_QuickScale;
	polySelectBorderShell 0;
	NinjaUV_MoveUV Zero Nil;

}

global proc NinjaUV_UniformMapping()
{
	NinjaUV_DeleteEmptyUVSets();
	$CurrentUVset = `polyUVSet -q -currentUVSet`;
	string $CutEdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $Sel_Edges[] = `filterExpand -sm 32 -fp 1`;
	string $Sel_Faces[] = `filterExpand -sm 34 -fp 1`;
	string $SelObject[] = `ls -hl -l`;

	if (`size $SelObject` == 0)
	{
		$SelObject = `ls -sl -fl -l`;
    }

	if (`size $Sel_Faces` != 0 )
	{
		//$SelObject = $Sel_Faces;
		//select $SelObject;
	}

	for ($i = 0; $i < (`size $SelObject`); $i++)
	{
		select $SelObject[$i];
		ConvertSelectionToFaces;
		string $SelObjectFaces[] = `ls -sl -fl -l`;

		if (`size $Sel_Faces` != 0 )
		{
			$SelObjectFaces = {};
			for ($f = 0; $f < (`size $Sel_Faces`); $f++)
				{
					if (startsWith ($Sel_Faces[$f], $SelObject[$i]))
					{
						stringArrayInsertAtIndex (0, $SelObjectFaces, $Sel_Faces[$f]);
                    }
                }
        	select $SelObjectFaces;
		}


		string $CutEdges[] = {};
		if (`size $Sel_Edges` != 0)
			{
				//filter edges
				for ($e = 0; $e < (`size $Sel_Edges`); $e++)
				{
					if (startsWith ($Sel_Edges[$e], $SelObject[$i]))
					{
						stringArrayInsertAtIndex (0, $CutEdges, $Sel_Edges[$e]);
                    }
                }
				//$CutEdges = $Sel_Edges;
			}

		else
		{
			if (`size $CutEdgeList` != 0  )
			{
				for ($i = 0; $i < (`size $CutEdgeList`); $i++)
				{
					select -add ($SelObject[$i] + "." + $CutEdgeList[$i]);
				}//end for
					$CutEdges = `ls -sl -fl`;
			}//end if
		}//end else



		$Unitize = `polyForceUV -unitize -cm on -uvSetName "Ninja_unitize"`;//unitize to a new UVset
		$UnitizeUVSet = `polyUVSet -currentUVSet -uvSet "Ninja_unitize"` ;//set to NinjaUVset

		ConvertSelectionToEdges;
		if (`size $CutEdges` != 0)
			{
				select -d $CutEdges;
			}

		$SewUVs = `polyMapSewMove -nf 10 -lps 0 -ch 1`;

		select $SelObjectFaces;


		$CopyUVs = `polyCopyUV -uvSetNameInput "Ninja_unitize" -uvSetName $CurrentUVset  -ch 1`;
		//error;
		$DeleteUVset = `polyUVSet -delete -uvSet "Ninja_unitize"`;

		//select $SelObjectFaces;
		//PolySelectConvert 4;//convert to uvs
		//$WelUVs = `polyMergeUV -d 0.01 -ch 1`;


		NinjaUV_QuickScale();
		NinjaUV_MoveUV Zero Nil;
	}
}//end proc

global proc NinjaUV_AutoMapping()
{
	NinjaUV_DeleteEmptyUVSets();
	string $CutEdgeList[] = `textScrollList -q -ai EdgeSpline_list`;
	string $Sel_Edges[] = `filterExpand -sm 32`;
	string $Sel_Faces[] = `filterExpand -sm 34`;
	string $Sel[] = `ls -hl -l`;
	if (`size $Sel` == 0)
	{
		$Sel = `ls -sl -fl -l`;
    }

	string $CutEdges[] = {};
	if (`size $Sel_Edges` != 0)
		{
			$CutEdges = $Sel_Edges;
        }

	else
	{
		if (`size $CutEdgeList` != 0  )
			{
				for ($i = 0; $i < (`size $CutEdgeList`); $i++)
				{
					select -add ($Sel[0] + "." + $CutEdgeList[$i]);

				}//end for
			$CutEdges = `ls -sl -fl`;

			}
	}
	//error;
	if (`size $Sel_Faces` != 0 )
		{
			$Sel = $Sel_Faces;
    	}

	select $Sel;
	//error;
	ConvertSelectionToFaces;

	polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0 ;
	if (`size $CutEdges` != 0)
		{
			select $CutEdges;
			polyMapCut ;
   		}


	select $Sel;
	ConvertSelectionToEdges;
	if (`size $CutEdges` != 0)
		{
			//polyMapCut $CutEdges;
			select -d $CutEdges;
   		}

	polyMapSewMove -nf 10 -lps 0 -ch 1;
	select $Sel;

	$RunQuickUnfold = `checkBox -q -v AutoUnfold_ShellMapping`;
	if ($RunQuickUnfold == 1)
	{
		//NinjaUV_QuickScale;
		NinjaUV_QuickUnfold;
    }


	$RunNinjaUV_QuickFix = `checkBox -q -v NinjaUV_QuickFix_ShellMapping`;
	if ($RunNinjaUV_QuickFix == 1)
	{
		NinjaUV_QuickFix();
    }


	polyLayoutUV -l 2 -sc 1 -se 0 -rbf 0 -fr 1 -ps 0.2 -lm 0 -ch 1;
	NinjaUV_QuickScale();
	polyLayoutUV -l 2 -sc 0 -se 0 -rbf 0 -fr 1 -ps 0.2 -lm 0 -ch 1;
	NinjaUV_MoveUV Zero Nil;
}//end proc

global proc string[] NinjaUV_SelectByAngle(float $Angle)
{
	string $Sel[] = `ls -sl -fl -l`;
	string $Objects[] = `ls -hl -l`;
	string $FaceArray[] = {};

	for ($f = 0;$f < `size $Sel`; $f++)
		{
			if ( stringArrayContains($Sel[$f],$FaceArray) == 0)
			{
				string $buf[] = {};
				$numTokens = `tokenize $Sel[$f] "." $buf`;
				$FaceObject = $buf[0];

				string $FaceNormal[] = `polyInfo -fn $Sel[$f]`;
				string $Normal[] = stringToStringArray($FaceNormal[0], " ");

				float $NormalX = $Normal[2];
				float $NormalY = $Normal[3];
				float $NormalZ = $Normal[4];

				vector $faceNormal = << $NormalX, $NormalY, $NormalZ >>;  // vector creation
				$matrix = `xform -q -ws -m $FaceObject`; //position of the object in world space
				float $worldspaceVec[] = pointMatrixMult($faceNormal, $matrix);

				//$Angle = `intField -q -v int_NinjaMeshAngleSelect`;
				//$Angle = `floatSliderGrp -q -v slider_NinjaMeshAngleSelect`;


				//print $buf[0];
				select $FaceObject;
				ConvertSelectionToFaces;
				doMenuComponentSelection($buf[0], "facet");

				polySelectConstraint -m 2 -o 1 -ob $Angle 0 -oa $worldspaceVec[0] $worldspaceVec[1] $worldspaceVec[2] -type 0x0008;

				string $SelFaces[] = `ls -sl -fl -l`;
				//print $SelFaces;
				$FaceArray = stringArrayCatenate($FaceArray, $SelFaces);

				polySelectConstraint -m 0;

            }

        }
	//print $FaceArray;
	select $FaceArray;
	for ($o = 0;$o < `size $Objects`; $o++)
		{
			doMenuComponentSelection($Objects[$o], "facet");
        }

	return $FaceArray;

}

global proc NinjaUV_AngleMapping()
{
	$Sel = `ls -sl -fl -l`;
	ConvertSelectionToFaces;
	$Faces = `ls -sl -fl -l`;
	$Angle = 15;

	string $MappedFaceArray[] = {};

	for ($f = 0;$f < `size $Faces`; $f++)
		{
			if ( stringArrayContains($Faces[$f],$MappedFaceArray) == 0)
			{
				select $Faces[$f];
				string $SelFaces[] = eval ("NinjaUV_SelectByAngle 45");

				//select $SelFaces;
				polyProjection -ch 0 -type Planar -ibd on -md b $SelFaces;
				$MappedFaceArray = stringArrayCatenate($MappedFaceArray, $SelFaces);
            }
	    }

}

global proc Start_Interactive()
{
	 global int $InteractiveMappingJobNumber;
	 $InteractiveMappingJobNumber = `scriptJob -e "SelectionChanged" "Interactive_Mapping()" -p Ninja_UV_UI`;
	 scriptJob -e "SelectionChanged" "Ninja_UV_Map_it()";
}

global proc Kill_Interactive()
{
	 global int $InteractiveMappingJobNumber;
	 $InteractiveMappingJobNumber = `scriptJob -kill $InteractiveMappingJobNumber`;
	 //scriptJob -e "SelectionChanged" "Ninja_UV_Map_it()";
}

global proc Interactive_Mapping()
{
	$Selection = `ls -sl -fl`;
	$Obj = `ls -hl`;
	delete -ch $Obj;
	string $Sel_Faces[] = `filterExpand -sm 34`;
	if (`size $Sel_Faces` > 0)
	{
		Ninja_UV_Map_it();
	}
	select $Selection;

}


global proc NinjaUV_PreviewUVs()
{

	$DeleteHistory = `checkBox -q -v cb_UVDeleteHistory`;

	$Sel = `ls -sl -fl -l`;
	$MayaLocation = `internalVar -uad`;
	sysFile -md ($MayaLocation + "/NinjaDojo/UVPreview/");
	$CurrentUVset = `polyUVSet -q -currentUVSet`;
	checkBox -e -value 0 NinjaUV_QuickUnfold_Auto_unfold;

	polyCopyUV -uvSetNameInput $CurrentUVset -uvSetName "NinjaUV_Preview" -createNewMap 1 -ch 0;
	$PreviewUVSet = `polyUVSet -currentUVSet -uvSet "NinjaUV_Preview"`;

	//test HV
	select $Sel;
	radioButtonGrp  -e -select 2 Map_HV1;
	NinjaUV_NinjaMapping;
	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }
	polyNormalizeUV -ch 0 -normalizeType 1 -preserveAspectRatio on ;
	uvSnapshot -aa -n ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewHV.xpm") -xr 50 -yr 50 -r 255 -g 255 -b 255 -o -ff xpm;

	iconTextButton -e -image ("square.xpm") iconButton_HV;
	iconTextButton -e -image ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewHV.xpm") iconButton_HV;

	//text VH
	select $Sel;
	radioButtonGrp  -e -select 2 Map_HV;
	NinjaUV_NinjaMapping;
	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }
	polyNormalizeUV -ch 0 -normalizeType 1 -preserveAspectRatio on ;

	uvSnapshot -aa -n ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewVH.xpm") -xr 50 -yr 50 -r 255 -g 255 -b 255 -o -ff xpm;
	iconTextButton -e -image ("polySphere.xpm") iconButton_VH;
	iconTextButton -e -image ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewVH.xpm") iconButton_VH;

	//text Both
	select $Sel;
	radioButtonGrp  -e -select 1 Map_HV;
	NinjaUV_NinjaMapping;
	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }
	polyNormalizeUV -ch 0 -normalizeType 1 -preserveAspectRatio on ;

	uvSnapshot -aa -n ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewBoth.xpm") -xr 50 -yr 50 -r 255 -g 255 -b 255 -o -ff xpm;
	iconTextButton -e -image ("polySphere.xpm") iconButton_Both;
	iconTextButton -e -image ($MayaLocation + "/NinjaDojo/UVPreview/UVPreviewBoth.xpm") iconButton_Both;

	select $Sel;
	$DeleteUVSet = `polyUVSet -delete -uvSet "NinjaUV_Preview"`;

	checkBox -e -value 1 NinjaUV_QuickUnfold_Auto_unfold;


}

global proc NinjaUV_ForceMapping(string $UnfoldType)
{

	$Sel = `ls -sl -fl -l`;

	if (`size $Sel` != 0)
	{
		checkBox -e -value 0 NinjaUV_QuickUnfold_Auto_unfold;
		if ($UnfoldType == "HV")
		{
			radioButtonGrp  -e -select 2 Map_HV1;
			NinjaUV_NinjaMapping;
		}

		if ($UnfoldType == "VH")
		{
			radioButtonGrp  -e -select 2 Map_HV;
			NinjaUV_NinjaMapping;
		}

		if ($UnfoldType == "Both")
		{
			radioButtonGrp  -e -select 1 Map_HV;
			NinjaUV_NinjaMapping;
		}

		select $Sel;
		checkBox -e -value 1 NinjaUV_QuickUnfold_Auto_unfold;

    }
}

global proc NinjaUV_ApplyMapping(string $MapType)
{
	ConvertSelectionToFaces;
	$SelFaces = `ls -sl -fl -l`;
	//selectMode -component ;
	//$SelObjects = `ls -hl -fl -l`;

	if ($MapType == "Planar")
	{
		polyProjection -ch 1 -type Planar -ibd on -kir  -md b $SelFaces;
    }

	if ($MapType == "Cylindrical")
	{
		polyProjection -ch 1 -type Cylindrical -ibd on -sf on $SelFaces;
    }

	if ($MapType == "Sphere")
	{
		polyProjection -ch 1 -type Spherical -ibd on -sf on $SelFaces;
    }

	if ($MapType == "Auto")
	{



			performPolyAutoProj 0;


    }
}

global proc float[] NinjaUV_getCameraRotation()
{
	//Get Current Camera Name
	string $panel = `getPanel -wf`;
	string $camera;
		if (startsWith ($panel, "modelPanel") == 1)
			{
				$camera = `modelPanel -q -camera $panel`;
			}

		else
			{
				print ("Selected Panel is not a valid camera using persp");
				$camera = "persp";
			}

	//Freeze Camera and get its rotation values
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $camera;
	float $cam_X = getAttr ($camera + ".rotateX");
	float $cam_Y = getAttr ($camera + ".rotateY");
	float $cam_Z = getAttr ($camera + ".rotateZ");

	float $CameraRotation[] = {$cam_X, $cam_Y, $cam_Z};
	return 	$CameraRotation;
}

global proc NinjaUV_NinjaMapping()
{
	global string $UVEdgeSelection[];
	$DeleteHistory = `checkBox -q -v cb_UVDeleteHistory`;
	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }

	$UVEdgeSelection = {};
	string $Total_Selection[] = `ls -sl -fl`;
	string $nodes[] = `selectedNodes`;
	string $Sel_Edges[] = `filterExpand -sm 32`;
	string $Sel_Faces[] = `filterExpand -sm 34`;
	string $Sel_UVs[] = `filterExpand -sm 35`;
	$UVEdgeSelection =`filterExpand -sm 32`;
	//Get texture size and set settings
	$ASS = `checkBox -q -value AutoSetSize`;
	if ($ASS == 1)
		{
			NinjaUV_GetTextureSize("diffuse");//gets the diffuse texture size
		}

	if (`size $Sel_Faces` == 0 && `size $Sel_UVs` == 0)
	{
		select $nodes;
		ConvertSelectionToFaces;
		$Sel_Faces = `ls - sl`;
    }

	if (`size $Sel_Faces` == 0 && `size $Sel_UVs` != 0)
	{
		ConvertSelectionToFaces;
		$Sel_Faces = `ls - sl`;
    }

	$Total_nodes = `size $nodes`;
	$MSU = (`floatField -q -v Map_ScaleU`);
	$MSV = (`floatField -q -v Map_ScaleV`);
	$HE = (`checkBox -q -v Hold_Edge`);
	$M_HV =(`radioButtonGrp  -q  -select Map_HV`);
	$M_HV1 =(`radioButtonGrp  -q  -select Map_HV1`);

	//Get Current Camera Name
	string $panel = `getPanel -wf`;
	string $camera;
		if (startsWith ($panel, "modelPanel") == 1)
			{
				$camera = `modelPanel -q -camera $panel`;
			}

		else
			{
				print ("Selected Panel is not a valid camera using persp");
				$camera = "persp";
			}

	//Freeze Camera and get its rotation values
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $camera;
	float $cam_X = getAttr ($camera + ".rotateX");
	float $cam_Y = getAttr ($camera + ".rotateY");
	float $cam_Z = getAttr ($camera + ".rotateZ");

	$UpAxis = `upAxis -q -axis`;
	//print $UpAxis;
	string $base_mapper[];
	$MapType = `radioButtonGrp -q -select Map_Gizmo`;
	if ($MapType == 1)
		{
			$base_mapper = `polyProjection -type Planar -md x $Sel_Faces`;

			$X_loc = getAttr ($base_mapper[0]+ ".projectionCenterX");
			$Y_loc = getAttr ($base_mapper[0]+ ".projectionCenterY");
			$Z_loc = getAttr ($base_mapper[0]+ ".projectionCenterZ");
			$Total_Mappers = `size $base_mapper`;

			//Set UV Gizmo Rotation if Y is up

			if ($UpAxis == "y")
			{
				int $Y_rotations = ($cam_Y /360 );
				float $Y_multiplier =(($cam_Y /360) - $Y_rotations);
				float $Y_rotation = ($Y_multiplier * 360);
				if ($Y_rotation < 0)
					{
						$Y_rotation = (360 + $Y_rotation);
					}

				int $X_rotations = ($cam_X /360 );
				float $X_multiplier =(($cam_X /360) - $X_rotations);
				float $X_rotation = ($X_multiplier * 360);
				if ($X_rotation < 0)
				{
					$X_rotation = (360 + $X_rotation);
				}

				for ($m = $Total_Mappers; $m >= 1; $m--)
				{
					if ($Y_rotation >= 0 && $Y_rotation <= 45)
						{
							//print "front";
							setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;
						}

					if ($Y_rotation >= 315 && $Y_rotation <= 360)
						{
							//print "front";
							setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;

						}

					if ($Y_rotation >= 45 && $Y_rotation <= 135)
						{
							//print "right";
							setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateY") 90;
							setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;

						}

					if ($Y_rotation >= 135 && $Y_rotation <= 225)
						{
							//print "back";
							//print "front";
							setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateY") 180;
							setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;

						}

					if ($Y_rotation >= 225 && $Y_rotation <= 315)
						{
							//print "left";
							setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							setAttr ($base_mapper[$m - 1] + ".rotateY") -90;
							setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;

						}

					if ($X_rotation >= 225 && $X_rotation <= 315)
								{
									//print "top";
									setAttr ($base_mapper[$m - 1] + ".rotateX") -90;
								}
					if ($X_rotation >= 45 && $X_rotation <= 135)
								{
									//print "bottom";
									setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
								}

					setAttr ($base_mapper[$m - 1] + ".projectionCenterX") $X_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionCenterY") $Y_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionCenterZ") $Z_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionWidth") $MSU;
					setAttr ($base_mapper[$m - 1] + ".projectionHeight") $MSV;

				}//end for $m

            }//end if up is y

			//Set UV Gizmo Rotation if Z is up
			if ($UpAxis == "z")
			{
				for ($m = $Total_Mappers; $m >= 1; $m--)
				{
				if ($cam_Z >= -45 && $cam_Z <= 45)
					{
						//print "front";
						setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
						setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
						setAttr ($base_mapper[$m - 1] + ".rotateZ") 0;
					}



				if ($cam_Z >= 45 && $cam_Z <= 135)
					{
						//print "right";
						setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
						setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
						setAttr ($base_mapper[$m - 1] + ".rotateZ") 90;

					}

				if ($cam_Z >= 135 && $cam_Z <= 180)
					{
						//print "back";
						setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
						setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
						setAttr ($base_mapper[$m - 1] + ".rotateZ") 180;

					}

				if ($cam_Z <= -135 && $cam_Z >= -225)
					{
						//print "back";
						setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
						setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
						setAttr ($base_mapper[$m - 1] + ".rotateZ") 180;

					}


				if ($cam_Z >= -135 && $cam_Z <= -45)
					{
						//print "left";
						setAttr ($base_mapper[$m - 1] + ".rotateX") 90;
						setAttr ($base_mapper[$m - 1] + ".rotateY") 0;
						setAttr ($base_mapper[$m - 1] + ".rotateZ") 270;

					}


				if ($cam_X > -45 && $cam_X < 45)
							{
								//print " top";
								setAttr ($base_mapper[$m - 1] + ".rotateX") 0;

							}

				if ($cam_X > 135 && $cam_X < 225 )
							{
								//print " bottom";
								setAttr ($base_mapper[$m - 1] + ".rotateX") 0;
							}

					setAttr ($base_mapper[$m - 1] + ".projectionCenterX") $X_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionCenterY") $Y_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionCenterZ") $Z_loc;
					setAttr ($base_mapper[$m - 1] + ".projectionWidth") $MSU;
					setAttr ($base_mapper[$m - 1] + ".projectionHeight") $MSV;

				}//end for
            }//end if up is z

		}//end if Mapping is Planar

	if ($MapType == 2)//best fit
		{
			$base_mapper = `polyProjection -ch 1 -type Planar -ibd on -md b $Sel_Faces`;
			$X_loc = getAttr ($base_mapper[0]+ ".projectionCenterX");
			$Y_loc = getAttr ($base_mapper[0]+ ".projectionCenterY");
			$Z_loc = getAttr ($base_mapper[0]+ ".projectionCenterZ");
			$Total_Mappers = `size $base_mapper`;

		}

	//Cuts selected edges
	if (`size $Sel_Edges` != 0)
		{
			polyMapCut -ch 0 -name "NUV_CutEdge" $Sel_Edges ;
		}

	//Unfold
	select -r $Sel_Faces;
	NinjaUV_QuickUnfold();

	//Fix edges
	$FixEdges = `checkBox -q -value Fix_CutEdges`;
	if (`size $Sel_Edges` > 0  && $FixEdges == 1)
		{
			select -r $Sel_Edges;
			NinjaUV_QuickFix();//fix cut edges
		}


	string $unitScale = `currentUnit -q -l`;
	if ($unitScale == "m")
		{
			$MSU = (.01 /(`floatField -q -v Map_ScaleU`));//get the U scale Value in meters
		}

	if ($unitScale == "cm")
		{
			$MSU = (1 / (`floatField -q -v Map_ScaleU`));//get the U scale Value in cm
		}


	float $TexScaleU = `floatField -q -v Tex_ScaleU` ;
	float $TexScaleV = `floatField -q -v Tex_ScaleV`;

	$UnfoldBoth = `radioButtonGrp -q -sl Map_HV`;
	if ($UnfoldBoth == 1)
	{
		//scale uv's
		select $Sel_Faces;
		//unfold -i 0 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  0 -us on -s $MSU;
        //if ($TexScaleU != $TexScaleV)
		//{
			NinjaUV_QuickScale();// scale uv's

        //}
		//NinjaUV_QuickFix();
    }

	$LayoutUV = `checkBox -q -v cb_LayoutUVs`;
	if ($LayoutUV == 1)
	{
		polyMultiLayoutUV -lm 1 -sc 1 -rbf 0 -fr 1 -ps 0.8 -l 2 -psc 0 -su 1 -sv 1 -ou 0 -ov 0;
    }

	else
	{
		// scale uv's
		//unfold -i 0 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  0 -us on -s $MSU;
      	select $Sel_Faces;
		//if ($TexScaleU != $TexScaleV)
		//{
			NinjaUV_QuickScale();// scale uv's

        //}
    }

	///set uvs to start at zero
	$SZ = `checkBox -q -value Set_Zero`;
	if ($SZ == 1)
	{
		select $Sel_Faces;
		polySelectBorderShell 0;
		NinjaUV_SetUToZero();
		NinjaUV_SetVToZero();
	}

	//reselect intial selection
	select $nodes $Sel_Faces $Sel_Edges;

	for ($s = 0; $s < `size $nodes`; $s++)
		{
			doMenuComponentSelection($nodes[$s], "facet");
		}

	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }

}

///////////////////////////////////////////////////////////////////////////////////////////////////Auto Guess unfold
global proc NinjaUV_SetAutoUnfold()
{
	//print "Auto";

	global string $UVEdgeSelection[];
	//print $UVEdgeSelection;
	$selection = `ls -sl -fl`;
	PolySelectConvert 4;

		float $Old_UV_Extents[] =`polyEvaluate -bc2`; //xmin xmax ymin ymax;

		$OriginalX = `abs ($Old_UV_Extents[1] - $Old_UV_Extents[0])`;//get U width
		$OriginalY = `abs ($Old_UV_Extents[3] - $Old_UV_Extents[2])`;//get V Height
		$Zero = 1;

		//print $OriginalX;
		//check for flat uv's
		if ($OriginalX == 0)
			{
				radioButtonGrp -e -select 2 Map_HV1;//select H-V
				$Zero = 0;
			}

		if ($OriginalY == 0)
			{
				radioButtonGrp -e -select 2 Map_HV;//select V-H
				$Zero = 0;
			}

		if ($Zero != 0)
		{


			//if (`size $UVEdgeSelection` != 0)
			//{
				//radioButtonGrp -e -select 1 Map_HV;//select Both

           // }

			//else
			//{
				$MSU = (1 / (`floatField -q -v Map_ScaleU`));//get the U scale Value
				$MSV = (1 / (`floatField -q -v Map_ScaleV`));//get the V scale Value

				//check U

				$UnfoldU = `unfold -i 100 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us off `; //check unfold u
				//$UnfoldU = `polyOptUvs -i 100 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s $MSU `; //checks scale u
				float $New_UV_Extents[] =`polyEvaluate -bc2`; //xmin xmax ymin ymax
				float $NewX = ($New_UV_Extents[1] - $New_UV_Extents[0]);//get new U width
				//delete $UnfoldU;//use delete if using polyopUVs
				undo;

				//check V
				$UnfoldV = `unfold -i 100 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us off ` ; //check unfold v
				//$UnfoldV = `polyOptUvs -i 100 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us on -s $MSV`;//check scale for v
				float $New_UV_Extents[] =`polyEvaluate -bc2`;//xmin xmax ymin ymax;
				float $NewY = `abs ($New_UV_Extents[3] - $New_UV_Extents[2])`;//get new V Height
				//delete $UnfoldV;//use delete if using polyopUVs
				undo;

				//print ("OriginalX = " + $OriginalX + "\n");
				//print ("NewX = " + $NewX + "\n");
				//print ("OriginalY = " + $OriginalY + "\n");
				//print ("NewY = " + $NewY + "\n");

				$ChangeX = ($NewX/$OriginalX);
				$ChangeY = ($NewY/$OriginalY);

				//print ("ChangeX = " + $ChangeX + "\n");
				//print ("ChangeY = " + $ChangeY + "\n");

				if ($ChangeX > $ChangeY)
				{
					radioButtonGrp -e -select 2 Map_HV1;//select H-V
                }

				else
				{
					radioButtonGrp -e -select 2 Map_HV;//select V-H
                }

				if ($ChangeX == $ChangeY)
				{
					radioButtonGrp -e -select 2 Map_HV1;//select H-V
					//radioButtonGrp -e -select 1 Map_HV1;//select None
                }

            //}//end else
		}


select -r $selection;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Compensate non Square textures
global proc Compensate_Texture()
{
	$MSU = `floatField -q -v Map_ScaleU`;
	$MSV = `floatField -q -v Map_ScaleV`;
	$rescale = ($MSV / $MSU);
	polyEditUV -pu 0 -pv 0 -su  (1 * $rescale);
}


global proc Unfold_Selected(string $UV)
{
	PolySelectConvert 4;
	$UnfoldIterations = `floatField -q -v Unfold_Iterations`;
	if ($UV == "U")
	{
		unfold -i $UnfoldIterations -ss 0 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  2 -us off;

	}

	if ($UV == "V")
	{
		unfold -i $UnfoldIterations -ss 0 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  1 -us off;
	}

}

/////////////////////////////////////////////////////////////////////////////////////////Quick Unfold
global proc NinjaUV_QuickUnfold()
{
	$AutoUnfold = `checkBox -q -value NinjaUV_QuickUnfold_Auto_unfold`;//checks if auto unfold is checked or not

	if ($AutoUnfold == 0)
		{
			$Selection = `ls -sl -fl`;
			string $Shells[] = NinjaUV_CollectShells();
			for ($s = 0; $s < `size $Shells`; $s++)
				{
					string $Single_Shell[];
					tokenize $Shells[$s] "," $Single_Shell;
					select -r $Single_Shell;
					Unfold_Shells();
				}
		}

	if ($AutoUnfold == 1)
		{

			$Selection = `ls -sl -fl`;
			string $Shells[] = NinjaUV_CollectShells();
			for ($s = 0; $s < `size $Shells`; $s++)
				{
					string $Single_Shell[];
					tokenize $Shells[$s] "," $Single_Shell;
					select -r $Single_Shell;

					string $Temp_Divisions[] = {};
					if (`size $Single_Shell` <= 4)
					{
						ConvertSelectionToFaces;
						$Temp_Divisions =`polySubdivideFacet -dv 2 -m 0 -ch 1` ;
						PolySelectConvert 4;
					}

					NinjaUV_SetAutoUnfold();
					Unfold_Shells();
					if (`size $Temp_Divisions` != 0)
					{
						delete $Temp_Divisions;
                    }

				}//end for s
		}//end if
}//end quick unfold

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Quick Unfold
global proc Unfold_Shells()
{
	$Unfold_Accuracy = `floatField -q -v Unfold_Iterations`;
	$ASS = `checkBox -q -value AutoSetSize`;
	if ($ASS ==1)
		{
			ConvertSelectionToFaces;//set to face selection
			NinjaUV_GetTextureSize("diffuse");
			PolySelectConvert 4;
		}//end if ass

	int $HoldEdge = (`checkBox -q -v Hold_Edge`);
	$M_HV =(`radioButtonGrp  -q  -select Map_HV`);
	$M_HV1 =(`radioButtonGrp  -q  -select Map_HV1`);


	if ($M_HV1 == 2)//Horz Vert
	{

		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  2 -us off ;//unfold horz
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  1 -us off ;//unfold vert

	}

	if ($M_HV1 == 3)//Horz Strip
	{
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  2 -us off;
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub 1 -ps  0 -oa  1 -us off;
	}

	if ($M_HV1 == 4)//Horz
	{
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  2 -us off;
	}


	if ($M_HV == 1)//Both
	{

		float $mayaVersion = `getApplicationVersionAsFloat` ;
		if ($mayaVersion <= 2012)
		{
			unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  0 -us off;

        }

		if ($mayaVersion <= 2013)
		{
			//unfold -i $Unfold_Accuracy -ss 0 -gb 1 -gmb 1 -pub $HoldEdge -ps  0 -oa  0 -us off;
			unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  2 -us off ;//unfold horz
			unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  1 -us off ;//unfold vert
			unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  0 -us off;
        }

	}

	if ($M_HV == 2)//Vert Horz
	{
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  1 -us off;
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge -ps  0 -oa  2 -us off;

	}

	if ($M_HV == 3)//Vert Strip
	{

		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  1 -us off;
		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub 1 -ps  0 -oa  2 -us off;

	}//end if

	if ($M_HV == 4)//Vert
	{

		unfold -i $Unfold_Accuracy -ss 0 -gb 0 -gmb 0 -pub $HoldEdge  -ps 0 -oa  1 -us off;

	}//end if


	//error;
	$AS = `checkBox -q -value QM_Adjust_Scale`;
	if ($AS == 1)
	{
		NinjaUV_QuickScale();
	}

}//end proc
///////////////////////////////////////////////////////////////////////////////////////////////////Test for Zero UVs
global proc int Test_ZeroUV()
{
	$selection = `ls -sl -fl`;
	int $zero_uv = 0;// 0 is non at zero
	//Test U for Zero UVs//
		$Test_U = `polyOptUvs -i 10 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2`;//unfold horz
		$Test_V = `polyOptUvs -i 10 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1`;//unfold vert
		$Test_UV_Extents =`polyEvaluate -bc2`;
		//undo;

			if ($Test_UV_Extents[0] <= -3.402823466e+038)
					{
						$zero_uv = 1; // 1 = zero uv
					}//end if
			if ($Test_UV_Extents[1] <= -3.402823466e+038)
					{
						$zero_uv = 1; // 1 = zero uv
					}//end if
			if ($Test_UV_Extents[2] <= -3.402823466e+038)
					{
						$zero_uv = 1;// 1 = zero uv
					}//end if

			if ($Test_UV_Extents[3] <= -3.402823466e+038)
					{
						$zero_uv = 1; // 1 = zero uv
					}//end if
	delete $Test_U;
	delete $Test_V;
	select $selection;
	return $zero_uv;
}//end proc


global proc NinjaUV_ScaleToLast()
{
	string $Sel[] = `ls -sl -fl -l`;

	$TargetObject = $Sel[`size $Sel` - 1];
	select $TargetObject;

	PolySelectConvert 4;
	$SelUV = `ls -sl -fl -l`;

	$AS = `checkBox -q -value AutoSetSize`;
	if ($AS == 1)
	{
		ConvertSelectionToFaces;
		NinjaUV_GetTextureSize("diffuse");
		//PolySelectConvert 4;
	}

	select $SelUV[0];
	polySelectBorderShell 0;
	global float $Unfold_Accuracy;
	$Old_UV_Extents =`polyEvaluate -bc2`;
	$OX = ($Old_UV_Extents[1] - $Old_UV_Extents[0]);
	$OY = ($Old_UV_Extents[3] - $Old_UV_Extents[2]);


	$TU = `floatField -q -v Tex_ScaleU`;
	$TV = `floatField -q -v Tex_ScaleV`;

	////scale U
	$Test_U = `unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s .01 `;
	$New_UV_Extents =`polyEvaluate -bc2`;
	$NX = ($New_UV_Extents[1] - $New_UV_Extents[0]);
	$New_XScale_Value = ($NX/$OX);
	float $PRX = $TU / $New_XScale_Value;
	undo;

	///Scale V
	$Test_V =`unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us on -s .01`;
	$New_UV_Extents =`polyEvaluate -bc2`;
	$NY = ($New_UV_Extents[3] - $New_UV_Extents[2]);
	$New_YScale_Value = ($NY/$OY);
	float $PRY = $TV / $New_YScale_Value;
	undo;

	int $PRXint = ($PRX + .5);
	floatField -e -v $PRXint NinjaUV_PixelRatio;

	select $Sel;
	select -d $TargetObject;
	NinjaUV_QuickScale;
	//select $Sel;

}

global proc NinjaUV_QuickScaleGroup()
{
	$Scale = (1 / (`floatField -q -v Map_ScaleU`));//get the U scale Value in cm
	polyOptUvs -i 0 -ss 0.001 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s $Scale;
}

///////////////////////////////////////////////////////////////////////////////////////////////////Quick Scale
global proc NinjaUV_QuickScale()
{

	$DeleteHistory = `checkBox -q -v cb_UVDeleteHistory`;
	if ($DeleteHistory == 1)
	{
		$Obj = `ls -hl`;
		delete -ch $Obj;
    }

	NinjaUV_SetPixelRatio;
	PolySelectConvert 4;
	string $Selection[] =`ls -sl -fl`;
	string $UVs[] = `ls -sl -fl`;//base uv's
	string $Test_UVs[] = `ls -sl -fl` ;
	string $Shell[]={};
	string $Shell_string;
	string $Bad_Array[]={};
	string $zero_uv = "0";
	float $MSU;
	float $MSV;
	$UnfoldIterations = `floatField -q -v Unfold_Iterations`;
	$UV_ExtentsGroup =`polyEvaluate -bc2`;//get the uv extents
	$XMidGroup = (($UV_ExtentsGroup[1] + $UV_ExtentsGroup[0]) / 2);
	$YMidGroup = (($UV_ExtentsGroup[3] + $UV_ExtentsGroup[2]) / 2);

	for ($s = 0; $s < `size $UVs`; $s++)
		{
			$test_UV = stringArrayContains ($UVs[$s], $Test_UVs);// checks to see if the UV is in the array after removing shell
			if ($test_UV == 1)
				{

					//gather shells
					$zero_uv = "0";
					select -r $UVs[$s];
					polySelectBorderShell 0;
					string $Shell[] = `ls -sl -fl`;//stores uv shell selection
					$new_UVs = stringArrayRemove ($Shell, $Test_UVs);//removes shells from base uvs
					$Test_UVs = $new_UVs;//updates UV array to remove shell

					//work on shell
					//
					$ASS = `checkBox -q -value AutoSetSize`; //checks if Find Texture Size is Checked
						if ($ASS ==1)
							{
								ConvertSelectionToFaces;
								NinjaUV_GetTextureSize("diffuse");
								select -r $Shell;
              				}//end if ass = 1

						$Old_UV_Extents =`polyEvaluate -bc2`;//get the uv extents
						$XMid = (($Old_UV_Extents[1] + $Old_UV_Extents[0]) / 2);
						$YMid = (($Old_UV_Extents[3] + $Old_UV_Extents[2]) / 2);
						$XStart = $Old_UV_Extents[0];
						$YStart = $Old_UV_Extents[2];
						$OX = ($Old_UV_Extents[1] - $Old_UV_Extents[0]);
						$OY = ($Old_UV_Extents[3] - $Old_UV_Extents[2]);

						string $UnitScale = `currentUnit -q -l`;
						if ($UnitScale == "m")
							{
								$MSU = (.01 /(`floatField -q -v Map_ScaleU`));//get the U scale Value in meters
								$MSV = (.01 / (`floatField -q -v Map_ScaleV`));//get the V scale Value in meters
							}

						if ($UnitScale == "cm")
							{
								$MSU = (1 / (`floatField -q -v Map_ScaleU`));//get the U scale Value in cm
								$MSV = (1 / (`floatField -q -v Map_ScaleV`));//get the V scale Value in cm
							}

						if ($UnitScale == "in")
							{
								$MSU = (.3937 / (`floatField -q -v Map_ScaleU`));//get the U scale Value in cm
								$MSV = (.3937 / (`floatField -q -v Map_ScaleV`));//get the V scale Value in cm
							}

						if ($UnitScale == "ft")
							{
								$MSU = (0.03281 / (`floatField -q -v Map_ScaleU`));//get the U scale Value in cm
								$MSV = (0.03281 / (`floatField -q -v Map_ScaleV`));//get the V scale Value in cm
							}

						float $New_UV_Y_Extents[];
						float $New_UV_X_Extents[];
						float $New_XScale_Value;
						float $New_YScale_Value;

						string $Temp_Divisions[] = {};
						if (`size $Shell` <= 4)
						{
							ConvertSelectionToFaces;
							$Temp_Divisions =`polySubdivideFacet -dv 2 -m 0 -ch 1` ;
							select -r $UVs[$s];
							polySelectBorderShell 0;
                        }

						//calculate scale U
						$XU = `unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s $MSU`;
						//$XU = `polyOptUvs -i $UnfoldIterations -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s $MSU`;
						$New_UV_X_Extents =`polyEvaluate -bc2 `;
						$NX = ($New_UV_X_Extents[1] - $New_UV_X_Extents[0]);
						$New_XScale_Value = ($NX/$OX);
						undo;//use undo if using unfold
						//delete $XU;

						///calculate Scale V
						$YU = `unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps  0 -oa  1 -us on -s $MSV`;
						//$YU = `polyOptUvs -i $UnfoldIterations -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us on -s $MSU`;
						$New_UV_Y_Extents =`polyEvaluate -bc2 `;//check the V extents of the shell
						$NY = ($New_UV_Y_Extents[3] - $New_UV_Y_Extents[2]);//find the difference in the V extents
						$New_YScale_Value = ($NY/$OY); //calculate the ratio
						undo;//use undo if using unfold
						//delete $YU;

						int $Scale_Location = `radioButtonGrp -q -select QuickScale_Location`;

						//print $New_XScale_Value;
						//print $New_YScale_Value;

						if ($Scale_Location == 1)
							{
								polyEditUV  -pu $XMid -pv $YMid -su $New_XScale_Value -sv $New_YScale_Value;//set x scale
							}

						if ($Scale_Location == 2)
							{
								polyEditUV -pu $XStart -pv $YStart -su $New_XScale_Value -sv $New_YScale_Value;//set x scale
							}


						if ($Scale_Location == 3)
							{
								polyEditUV  -pu $XMidGroup -pv $YMidGroup -su $New_XScale_Value -sv $New_YScale_Value;//set x scale
							}


						if (`size $Temp_Divisions` != 0)
						{
							delete $Temp_Divisions;
                        }

				}//end test uv
			}//end for s
select -r $Selection;
//refresh;
}//end proc



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Pixel Ratio

global proc NinjaUV_SetPixelRatio()
{


	string $UnitScale = `currentUnit -q -l`;
	optionMenu -e -v $UnitScale NinjaUV_UnitScale;

	$PixelRatio = (`floatField -q -v NinjaUV_PixelRatio`);
	$UnitRatio = `floatField -q -v NinjaUV_UnitRatio`;

	$ScaleU = (`floatField -q -v Map_ScaleU`);
	$ScaleV = (`floatField -q -v Map_ScaleV`);

	$TextureU = `floatField -q -v Tex_ScaleU`;
	$TextureV = `floatField -q -v Tex_ScaleV`;

	floatField -e -v (($TextureU / $PixelRatio) * $UnitRatio)  Map_ScaleU;
	floatField -e -v (($TextureV / $PixelRatio) * $UnitRatio)  Map_ScaleV;


}


global proc NinjaUV_SetUnitScale()
{
	$UnitScale = `optionMenu -q -v  NinjaUV_UnitScale`;
	changeLinearUnit($UnitScale);
	float $UnitSize = 1;

		if ($UnitScale == "cm")
		{
			$UnitSize = 1000;
		}

		if ($UnitScale == "cm")
		{
			$UnitSize = 100;
		}

		if ($UnitScale == "m")
		{
			$UnitSize = 1;
		}

		if ($UnitScale == "in")
		{
			$UnitSize = 12;
		}

		if ($UnitScale == "ft")
		{
			$UnitSize = 1;
		}

		if ($UnitScale == "yd")
		{
			$UnitSize = 1;
		}

	floatField -e -v $UnitSize  NinjaUV_UnitRatio;
	NinjaUV_SetPixelRatio;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Detach UV Shell
global proc NinjaUV_DetachShell()
{
	//$Selected_Faces = `ls -sl`;
	polyForceUV -flipHorizontal -local;
	polyForceUV -flipHorizontal -local;
	PolySelectConvert 4;
	$Selected_UV = `ls -sl -fl`;
	polyMergeUV -d 0.01 -ch 1 $Selected_UV;

}


global proc Set_Unfold_Accuracy()
{
	global float $Unfold_Accuracy;
	$Unfold_Accuracy = `floatField -q -v Unfold_Iterations`;
}

global proc NinjaUV_AutoUnfoldOff()
{
	checkBox -e -value 0 NinjaUV_QuickUnfold_Auto_unfold;
}

global proc Open_Ninja_UV_Help()
{
	system ("load http://www.bk3d.com/Scripts/Mel/Ninja_UV/Ninja_UV_help.htm") ;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Calculate Pixel Ratio
global proc NinjaUV_CheckPixelRatio()
{
	PolySelectConvert 4;
	$SelUV = `ls -sl -fl -l`;

	$AS = `checkBox -q -value AutoSetSize`;
	if ($AS == 1)
	{
		ConvertSelectionToFaces;
		NinjaUV_GetTextureSize("diffuse");
		//PolySelectConvert 4;
	}

	select $SelUV[0];
	polySelectBorderShell 0;
	global float $Unfold_Accuracy;
	$Old_UV_Extents =`polyEvaluate -bc2`;
	$OX = ($Old_UV_Extents[1] - $Old_UV_Extents[0]);
	$OY = ($Old_UV_Extents[3] - $Old_UV_Extents[2]);


	$TU = `floatField -q -v Tex_ScaleU`;
	$TV = `floatField -q -v Tex_ScaleV`;

	////scale U
	$Test_U = `unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 2 -us on -s .01 `;
	$New_UV_Extents =`polyEvaluate -bc2`;
	$NX = ($New_UV_Extents[1] - $New_UV_Extents[0]);
	$New_XScale_Value = ($NX/$OX);
	float $PRX = $TU / $New_XScale_Value;
	//delete $Test_U;
	undo;

	///Scale V
	$Test_V =`unfold -i 100 -ss 0 -gb 0 -gmb 0 -pub 0 -ps 0 -oa 1 -us on -s .01 `;
	$New_UV_Extents =`polyEvaluate -bc2`;
	$NY = ($New_UV_Extents[3] - $New_UV_Extents[2]);
	$New_YScale_Value = ($NY/$OY);
	float $PRY = $TV / $New_YScale_Value;
	//delete $Test_V;
	undo;

	//convert meters to unit value
	string $UnitScale = `currentUnit -q -l`;
	$UnitRatio = `floatField -q -v NinjaUV_UnitRatio`;

	if ($UnitScale == "m")
		{
			$PRX = (($PRX * 1) * $UnitRatio);
			$PRY = (($PRY * 1) * $UnitRatio);
		}

	if ($UnitScale == "cm")
		{

			$PRX = (($PRX * 100) * $UnitRatio);
			$PRY = (($PRY * 100) * $UnitRatio);

		}

	if ($UnitScale == "mm")
		{

			$PRX = (($PRX * 1000) * $UnitRatio);
			$PRY = (($PRY * 1000) * $UnitRatio);

		}

	if ($UnitScale == "in")
		{
			$PRX = (($PRX / 39.37) * $UnitRatio);
			$PRY = (($PRY / 39.37) * $UnitRatio);

		}

	if ($UnitScale == "ft")
		{
			$PRX = (($PRX / 3.281) * $UnitRatio);
			$PRY = (($PRY / 3.281) * $UnitRatio);

		}

	if ($UnitScale == "yd")
		{
			$PRX = (($PRX / 1.094) * $UnitRatio);
			$PRY = (($PRY / 1.094) * $UnitRatio);

		}

	int $PRXint = ($PRX + .5);
	int $PRYint = ($PRY + .5);



	$result  = `confirmDialog -button "set pixel ratio" -button "close" -message ("U= " + $PRXint + " pixels / " + $UnitRatio + " " + $UnitScale + "   V= " + $PRYint + " pixels / " + $UnitRatio + " " + $UnitScale)`;
	if ($result == "set pixel ratio")
		{
			floatField -e -v $PRXint NinjaUV_PixelRatio;
		}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Find Same Material


global proc NinjaUV_SelectByShader()
{
	$SelObj = `ls -hl -fl -l`;
	$SelectedFace = `ls -sl -fl -l`;
	string $shadingGroups[] = `ls -type shadingEngine`;
	string $ShadingGroupName;

	string $ShaderFaces[] = {};
	for ($s = 0; $s < `size $shadingGroups`; $s++)
	{
		if ( `sets -isMember $shadingGroups[$s] $SelectedFace[0]` ) //find shading group assigned to face
			{
				$ShadingGroupName = $shadingGroups[$s];
				break;
			}//end if
	}

	select $SelObj;
	ConvertSelectionToFaces;
	$Faces = `ls -sl -fl -l`;

	for ($f = 0; $f < `size $Faces`; $f++)
	{
		if ( `sets -isMember $ShadingGroupName $Faces[$f]` ) //find shading group assigned to face
			{
				stringArrayInsertAtIndex(0, $ShaderFaces, $Faces[$f]);

			}//end if
	}

	select $ShaderFaces;
	for ($o = 0;$o < `size $SelObj`; $o++)
		{
			doMenuComponentSelection($SelObj[$o], "facet");
        }

}


global proc string NinjaUV_GetFaceTexture(string $face)
{
	ConvertSelectionToFaces;
	string $Selected[] = `ls -sl -l`;
	string $shape_name[];
	tokenize $Selected[0] "." $shape_name;//get object name
	//print $shape_name;
	string $obj_name;


	if (`size $shape_name` > 1)
	{
		 $parent = `listRelatives -s -path -p $Selected[0]`;
		 $obj_name = $parent[0];
    }

	else
	{
		string $childeren[] = `listRelatives -s -path $Selected[0]`;
		$obj_name = $childeren[0];
    }

	string $ShadingGroupName = "";
	string $SelectedFace = $face;
	string $shadingGroups[] = `ls -type shadingEngine`;
	string $currentShape[];
	for ($f = 0; $f < `size $shadingGroups`; $f++)
		{
			//print ("SG = " + $shadingGroups[$f]);
			if ( `sets -isMember $shadingGroups[$f] $SelectedFace` ) //find shading group assigned to face
			{
				//print ("SG = " + $shadingGroups[$f]);
				$ShadingGroupName = $shadingGroups[$f];
				break;
			}//end if

			else
			{
				//string $currentShape[] = `listRelatives -s -path $obj_name`;
				$SGN = `listConnections -destination true -source false -plugs false -type "shadingEngine" $obj_name`;
				$ShadingGroupName = $SGN[0];

			}//end else

		}//end $f

	$material = `connectionInfo -sourceFromDestination ($ShadingGroupName + ".surfaceShader" )`; //find material attached to shading group
	$materialName = substituteAllString($material, ".outColor", "");//remove outColor
	string $TextureInput = `textField -q -tx TextureInputConnection`;
	print $TextureInput;
	$Texture = `connectionInfo -sourceFromDestination  ($materialName + "." + $TextureInput)`; //find texture attaced to material
	print $Texture;
	$TextureName = substituteAllString($Texture, ".outColor", "");//remove outColor

	return $TextureName;

}//end proc


global proc NinjaUV_Edit_AO_Bakeset()
{
	NinjaUV_Create_AO_Bakeset;
	showEditor OcclusionBakeSet;
	select -r -ne OcclusionBakeSet;
}


global proc NinjaUV_Edit_LM_Bakeset()
{
	NinjaUV_Create_LM_Bakeset;
	showEditor LightMapBakeSet;
	select -r -ne LightMapBakeSet;
}

global proc NinjaUV_Edit_Color_Bakeset()
{
	NinjaUV_Create_Color_Bakeset;
	showEditor ColorBakeSet;
	select -r -ne ColorBakeSet;
}

global proc NinjaUV_Create_AO_Bakeset()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Format = "3";
    }

	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	$Falloff = `floatField -q -v Ninja_OcclusionFalloff`;

	// check to make sure Mental Ray is setup
 	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}

	if (`objExists "OcclusionBakeSet"` == 0)
	{
		createBakeSet OcclusionBakeSet textureBakeSet;
		setAttr "OcclusionBakeSet.occlusionRays" 256;
		setAttr "OcclusionBakeSet.occlusionFalloff" $Falloff;
		setAttr "OcclusionBakeSet.xResolution" $AO_Width;
		setAttr "OcclusionBakeSet.yResolution" $AO_Height;
		setAttr "OcclusionBakeSet.bakeToOneMap" 1;
		setAttr "OcclusionBakeSet.fileFormat" $Format;
		setAttr "OcclusionBakeSet.fillTextureSeams" 3;
		setAttr OcclusionBakeSet.colorMode 3;
		setAttr "OcclusionBakeSet.backgroundColor" -type double3 1 1 1 ;
		setAttr OcclusionBakeSet.backgroundMode 1;

		//setAttr "OcclusionBakeSet.overrideUvSet" 1;
		//setAttr -type "string" OcclusionBakeSet.uvSetName "aoMap";
	}

}


global proc NinjaUV_Create_LM_Bakeset()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Format = "3";
    }

	$AO_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$AO_Height = `intField -q -v NinjaUV_BakeAO_Height`;

	// check to make sure Mental Ray is setup
 	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}

	if (`objExists "LightMapBakeSet"` == 0)
	{
		createBakeSet LightMapBakeSet textureBakeSet;
		setAttr LightMapBakeSet.colorMode 1;
		setAttr "LightMapBakeSet.xResolution" $AO_Width;
		setAttr "LightMapBakeSet.yResolution" $AO_Height;
		setAttr "LightMapBakeSet.bakeToOneMap" 1;
		setAttr "LightMapBakeSet.fileFormat" $Format;
	}
}

global proc NinjaUV_Create_Color_Bakeset()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Format = "3";
    }

	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	//$Falloff = `floatField -q -v Ninja_OcclusionFalloff`;

	// check to make sure Mental Ray is setup
 	mentalRayLoad;

	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}

	if (`objExists "ColorBakeSet"` == 0)
	{
		createBakeSet ColorBakeSet textureBakeSet;
		//setAttr "ColorBakeSet.occlusionRays" 256;
		//setAttr "ColorBakeSet.occlusionFalloff" $Falloff;
		setAttr "ColorBakeSet.xResolution" $AO_Width;
		setAttr "ColorBakeSet.yResolution" $AO_Height;
		setAttr "ColorBakeSet.bakeToOneMap" 1;
		setAttr "ColorBakeSet.fileFormat" $Format;
		setAttr "ColorBakeSet.fillTextureSeams" 3;
		setAttr ColorBakeSet.colorMode 0;
		setAttr "ColorBakeSet.backgroundColor" -type double3 1 1 1 ;
		setAttr ColorBakeSet.backgroundMode 1;

		//setAttr "ColorBakeSet.overrideUvSet" 1;
		//setAttr -type "string" ColorBakeSet.uvSetName "aoMap";
	}

}

global proc NinjaUV_Create_Atlas_Bakeset()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Format = "3";
    }

	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	//$Falloff = `floatField -q -v Ninja_OcclusionFalloff`;

	// check to make sure Mental Ray is setup
 	mentalRayLoad;

	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}

	if (`objExists "AtlasBakeSet"` == 0)
	{
		createBakeSet AtlasBakeSet textureBakeSet;
		//setAttr "ColorBakeSet.occlusionRays" 256;
		//setAttr "ColorBakeSet.occlusionFalloff" $Falloff;
		setAttr "AtlasBakeSet.xResolution" $AO_Width;
		setAttr "AtlasBakeSet.yResolution" $AO_Height;
		setAttr "AtlasBakeSet.bakeToOneMap" 1;
		setAttr "AtlasBakeSet.fileFormat" $Format;
		setAttr "AtlasBakeSet.fillTextureSeams" 3;
		setAttr "AtlasBakeSet.colorMode" 0;
		setAttr "AtlasBakeSet.backgroundColor" -type double3 1 1 1 ;
		setAttr "AtlasBakeSet.backgroundMode" 1;

		//setAttr "ColorBakeSet.overrideUvSet" 1;
		//setAttr -type "string" ColorBakeSet.uvSetName "aoMap";
	}

}


global proc NinjaUV_BakeDefaultTextureName()
{
	$MayaLocation = `internalVar -uad`;
	textField -e -text ($MayaLocation + "NinjaDojo/NinjaBake/") "Bake_Path";
	textField -e -text "NinjaBake" BakeName;
}


global proc NinjaUV_BakeMatchTextureName()
{
	$Sel = `ls -sl -fl -l`;
	ConvertSelectionToFaces;
	$Selected_Face = `ls -sl -fl`;
	string $Face_Material = NinjaUV_GetFaceTexture($Selected_Face[0]);// gets texture node name
	string $TexturePath = `getAttr ($Face_Material + ".fileTextureName")` ;//get texture name


	string $Texture[];
	tokenize $TexturePath "/" $Texture;
	$TextureName = $Texture[(`size $Texture` - 1)];
	//print $TextureName;
	string $Texture[];
	tokenize $TextureName "." $Texture;
	$TexturePrefix = $Texture[0];

	$TexturePath = substituteAllString($TexturePath,$TextureName, "");//remove textureName
	textField -e -text $TexturePrefix BakeName;
	textField -e -text ($TexturePath) "Bake_Path";
	select $Sel;
}


global proc NinjaUV_BakeMatchTextureSize()
{
	$Sel = `ls -sl -fl -l`;
	ConvertSelectionToFaces;
	$Selected_Face = `ls -sl -fl`;
	string $Face_Material = NinjaUV_GetFaceTexture($Selected_Face[0]);// gets texture node name
	$TexturePath = `getAttr ($Face_Material + ".fileTextureName")` ;//get texture name
	int $Xsize = 0;
	int $Ysize = 0;
	$Xsize = getAttr ($Face_Material + ".outSizeX");
	$Ysize = getAttr ($Face_Material + ".outSizeY");
	//print $Xsize;
	intField -e -v $Xsize NinjaUV_BakeAO_Width;
	intField -e -v $Ysize NinjaUV_BakeAO_Height;
	select $Sel;
}



global proc string NinjaUV_SetBakeDirectory(string $BakeType)
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	$OutputName = `textField -q -text BakeName`;
	$MayaLocation = `internalVar -uad`;
	sysFile -md ($MayaLocation + "/NinjaDojo/NinjaBake");
	string $TexturePath = "";
	string $BakeFiles[] = `getFileList -fld ($MayaLocation + "NinjaDojo/NinjaBake/") -fs ("*." + $Extension)`;
	string $PSDBakeFiles[] = `getFileList -fld ($MayaLocation + "NinjaDojo/NinjaBake/") -fs "*.psd"`;
	textField -e -text ($MayaLocation + "NinjaDojo/NinjaBake/") "Bake_Path";

	//string $TexturePath;
	string $AO_Array[] = {};
	string $LM_Array[] = {};
	string $UV_Array[] = {};
	string $ColorBake_Array[] = {};
	string $Projection_Array[] = {};
	string $Checker_Array[] = {};
	string $Atlas_Array[] = {};
	string $ScreenTiles_Array[] = {};
	string $Multi_Array[] = {};

	for ($b = 0 ;$b < `size $BakeFiles`; $b++)
		{
			if (endsWith ($BakeFiles[$b], "_AO." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $AO_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_LM." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $LM_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_UV." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $UV_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_C." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $ColorBake_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_Checker." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $Checker_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_Projection." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $Projection_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_Atlas." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $Atlas_Array, $BakeFiles[$b]);
            }

			if (endsWith ($BakeFiles[$b], "_ScreenTiles." + $Extension) == 1)
			{
				stringArrayInsertAtIndex(0, $ScreenTiles_Array, $BakeFiles[$b]);
            }


        }

	for ($c = 0 ;$c < `size $PSDBakeFiles`; $c++)
		{
			if (endsWith ($PSDBakeFiles[$c], "_Multi.psd") == 1)
			{
				stringArrayInsertAtIndex(0, $Multi_Array, $PSDBakeFiles[$c]);
            }
		}
	//print $Multi_Array;
	//error;

	if ($BakeType == "AO")
		{
			int $count = `size $AO_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "LM")
		{
			int $count = `size $LM_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }
	if ($BakeType == "UV")
		{
			int $count = `size $UV_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "Color")
		{
			int $count = `size $ColorBake_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "Checker")
		{
			int $count = `size $Checker_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "Atlas")
		{
			int $count = `size $Atlas_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "ScreenTiles")
		{
			int $count = `size $ScreenTiles_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "Projection")
		{
			int $count = `size $Projection_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + "." + $Extension);
        }

	if ($BakeType == "Multi")
		{
			int $count = `size $Multi_Array`;
			$TexturePath = ($MayaLocation + "NinjaDojo/NinjaBake/" + $OutputName + $count + ".psd");
        }

	return $TexturePath;


}

global proc NinjaUV_SetBakeZone(string $U, string $V)
{

	int $UValue = $U;
	int $VValue = $V;

	floatField -e -v ($UValue - 1) bake_Umin;
	floatField -e -v $UValue bake_Umax;

	floatField -e -v ($VValue - 1) bake_Vmin;
	floatField -e -v $VValue bake_Vmax;


}

global proc string NinjaUV_Bake_AO()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
		$Format = "3";
    }

	mentalRayLoad;

	$Sel =`ls -sl -fl -l`;
	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	$Rays = `intField -q -v Ninja_OcclusionRays`;
	$Falloff = `floatField -q -v Ninja_OcclusionFalloff`;
	$FillTexSeams = `floatField -q -v Ninja_OcclusionTextureSeams`;
	$Object_Name = `ls -sl -fl -sn`;
	$BackGroundColor = `colorSliderGrp -q -rgb AO_BackgroundColor`;
	$Samples = `radioButtonGrp  -q -select  BakeSamples` ;

	// check to make sure Mental Ray is setup
 	if( size(`ls initialTextureBakeSet`) < 1)
	{
		createBakeSet( "initialTextureBakeSet", "textureBakeSet" );
	}
	if( size(`ls initialVertexBakeSet`) < 1)
	{
		createBakeSet( "initialVertexBakeSet", "vertexBakeSet" );
	}
	miCreateDefaultNodes();

	if (`objExists "OcclusionBakeSet"` == 0)
	{
		NinjaUV_Create_AO_Bakeset();

    }

	else
	{
		setAttr "OcclusionBakeSet.fileFormat" $Format;
    }

	///////////////////Duplicate and Combine the Meshes
	select $Sel;
	string $Temp_Mesh[] = `duplicate`;

	if (`size $Temp_Mesh` > 1)
		{
			NinjaUV_Attach();
			$Temp_Mesh = `ls -sl -fl -l`;
    	}
	hide $Sel;
	///////////////////End Duplicate and Combine the Meshes



	$UVSetName = `textField -q -tx BakeUVSet`;
	if ($UVSetName != "map1")
	{
		polyCopyUV -uvSetNameInput $UVSetName -uvSetName map1 -ch 1 $Temp_Mesh;
    }
	sets -forceElement OcclusionBakeSet `ls -dag -objectsOnly -geometry -selection`;//assign occlusion bake set to object


	////////////////////////Find Texture on Faces
		select $Temp_Mesh;
		$TexturePath = eval ("NinjaUV_SetBakeDirectory AO");
		$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes
		$Texture_Directory = `dirname $TexturePath`;//this is only the directory
		$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
		string $AO_Name = substituteAllString ($TextureName, ".", "_AO.");
		string $buf[];
		$numTokens = `tokenize $AO_Name "." $buf`;
		string $FileName = $buf[0];
		textField -e -text ($Texture_Directory  +  $FileName + "." + $Extension ) "Bake_Path";//this is the export path
		setAttr -type "string" OcclusionBakeSet.prefix ($Texture_Directory  +  $FileName) ;//set the occlusion texture path
    ////////////////////////End Find Texture on Faces

	//overide settings
	setAttr "OcclusionBakeSet.xResolution" $AO_Width;
	setAttr "OcclusionBakeSet.yResolution" $AO_Height;
	setAttr "OcclusionBakeSet.occlusionRays" $Rays;
	setAttr "OcclusionBakeSet.occlusionFalloff" $Falloff;
	setAttr "OcclusionBakeSet.backgroundColor" -type double3 $BackGroundColor[0] $BackGroundColor[1] $BackGroundColor[2] ;
	setAttr "OcclusionBakeSet.fillTextureSeams" $FillTexSeams;
	setAttr "OcclusionBakeSet.samples" $Samples;

	//Set UV Range
	$Umin = `floatField -q -v bake_Umin`;
	$Umax = `floatField -q -v bake_Umax`;
	$Vmin = `floatField -q -v bake_Vmin`;
	$Vmax = `floatField -q -v bake_Vmax`;
	setAttr "OcclusionBakeSet.uvRange" 2;
	setAttr "OcclusionBakeSet.uMin" $Umin;
	setAttr "OcclusionBakeSet.uMax" $Umax;
	setAttr "OcclusionBakeSet.vMin" $Vmin;
	setAttr "OcclusionBakeSet.vMax" $Vmax;

	//bake the AO Map

	select $Temp_Mesh;
	//sets -e -forceElement initialShadingGroup $Temp_Mesh;//assign intial shading group to Mesh before baking
	//convertLightmap  -camera persp -sh -bo OcclusionBakeSet $Temp_Mesh;
	convertLightmapSetup  -camera persp -keepOrgSG -showcpv;

	delete $Temp_Mesh;

	showHidden $Sel;

	$AssignAOShader = `checkBox -q -v cb_Assign_AOTexture`;
	if ($AssignAOShader == 1  && `size $Sel` != 0 )
	{

		int $Total_AO;
		if (`objExists ("Mat_NinjaAO*")` == 1)
			{
				select "Mat_NinjaAO*";
				string $SelMat_AO[] = `ls -sl -fl`;
				$Total_AO = `size $SelMat_AO`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaAO"  + $Total_AO)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaAO" + $Total_AO )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaAOTexure"  + $Total_AO) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaAO"  + $Total_AO)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Texture_Directory  +  $FileName + "." + $Extension ) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		//print $Sel;
		//print $SG_Name;
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }

	//print ($Texture_Directory  +  $FileName + "." + $Extension );
	system ("imconvert -sample 250 250 " + ($Texture_Directory  +  $FileName + "." + $Extension ) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Texture_Directory  +  $FileName + "." + $Extension );

}//end Bake AO



global proc string NinjaUV_Bake_LM()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
		$Format = "3";
    }

	mentalRayLoad;

	if (`objExists "LightMapBakeSet"` == 0)
	{
		NinjaUV_Create_LM_Bakeset();

    }

	else
	{
		setAttr "LightMapBakeSet.fileFormat" $Format;
    }

	$UVSetName = `textField -q -tx BakeUVSet`;
	$Sel =`ls -sl -fl -l`;
	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	$Object_Name = `ls -sl -fl -sn`;



	///////////////////Duplicate and Combine the Meshes
	select $Sel;
	string $Temp_Mesh[] = `duplicate`;

	if (`size $Temp_Mesh` > 1)
		{

			NinjaUV_Attach();
			$Temp_Mesh = `ls -sl -fl -l`;

    	}
	hide $Sel;

	if ($UVSetName != "map1")
	{
		polyCopyUV -uvSetNameInput $UVSetName -uvSetName map1 -ch 1 $Temp_Mesh;
    }
	sets -forceElement LightMapBakeSet `ls -dag -objectsOnly -geometry -selection`;//assign occlusion bake set to object

	////////////////////////Find Texture on Faces
	select $Temp_Mesh;
	string $TexturePath;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory LM");
	$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
	$LM_Name = substituteAllString ($TextureName, ".", "_LM.");
	string $buf[];
	$numTokens = `tokenize $LM_Name "." $buf`;
	string $FileName = $buf[0];
	textField -e -text ($Texture_Directory  +  $FileName + "." + $Extension) "Bake_Path";//this is the export path
	setAttr -type "string" LightMapBakeSet.prefix ($Texture_Directory  +  $FileName) ;
	////////////////////////End Find Texture on Faces


	//overide settings
	setAttr "LightMapBakeSet.xResolution" $AO_Width;
	setAttr "LightMapBakeSet.yResolution" $AO_Height;
	//Set UV Range
	$Umin = `floatField -q -v bake_Umin`;
	$Umax = `floatField -q -v bake_Umax`;
	$Vmin = `floatField -q -v bake_Vmin`;
	$Vmax = `floatField -q -v bake_Vmax`;
	setAttr "LightMapBakeSet.uvRange" 2;
	setAttr "LightMapBakeSet.uMin" $Umin;
	setAttr "LightMapBakeSet.uMax" $Umax;
	setAttr "LightMapBakeSet.vMin" $Vmin;
	setAttr "LightMapBakeSet.vMax" $Vmax;

	//bake the LM Map

	select $Temp_Mesh;
	//sets -e -forceElement initialShadingGroup $Temp_Mesh;//assign intial shading group to Mesh before baking

	$Shadows = `checkBox -q -v Ninja_cbBakeShadows`;
	if ($Shadows == 1)
	{
		convertLightmapSetup  -camera persp -sh -keepOrgSG -showcpv; //render Lightmap

    }

	else
	{
		convertLightmapSetup  -camera persp -keepOrgSG -showcpv; //render Lightmap
    }

	delete $Temp_Mesh;
	showHidden $Sel;

	$AssignLMShader = `checkBox -q -v cb_Assign_LMTexture`;
	if ($AssignLMShader == 1  && `size $Sel` != 0 )
	{

		int $Total_LM;
		if (`objExists ("Mat_NinjaLM*")` == 1)
			{
				select "Mat_NinjaLM*";
				string $SelMat_LM[] = `ls -sl -fl`;
				$Total_LM = `size $SelMat_LM`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaLM"  + $Total_LM)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaLM" + $Total_LM )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaLMTexure"  + $Total_LM) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaLM"  + $Total_LM)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Texture_Directory  +  $FileName + "." + $Extension) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		//print $Sel;
		//print $SG_Name;
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }



	system ("imconvert -sample 250 250 " + ($Texture_Directory  +  $FileName + "." + $Extension ) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Texture_Directory  +  $FileName + "." + $Extension );

}

global proc string NinjaUV_Bake_Color()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	int $Format;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
		$Format = "7";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
		$Format = "6";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
		$Format = "1";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
		$Format = "3";
    }

	mentalRayLoad;

	$Sel =`ls -sl -fl -l`;
	$AO_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$AO_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;
	$Rays = `intField -q -v Ninja_OcclusionRays`;
	$Falloff = `floatField -q -v Ninja_OcclusionFalloff`;
	$FillTexSeams = `floatField -q -v Ninja_OcclusionTextureSeams`;
	$Object_Name = `ls -sl -fl -sn`;
	$BackGroundColor = `colorSliderGrp -q -rgb AO_BackgroundColor`;
	$Samples = `radioButtonGrp  -q -select  BakeSamples` ;

	if (`objExists "ColorBakeSet"` == 0)
	{
		NinjaUV_Create_Color_Bakeset();

    }

	else
	{
		setAttr "ColorBakeSet.fileFormat" $Format;
    }

	///////////////////Duplicate and Combine the Meshes
	select $Sel;
	string $Temp_Mesh[] = `duplicate -rr`;

	if (`size $Temp_Mesh` > 1)
		{

			NinjaUV_Attach();
			$Temp_Mesh = `ls -sl -fl -l`;

    	}
	hide $Sel;
	///////////////////End Duplicate and Combine the Meshes

	$UVSetName = `textField -q -tx BakeUVSet`;
	if ($UVSetName != "map1")
	{
		polyCopyUV -uvSetNameInput $UVSetName -uvSetName map1 -ch 1 $Temp_Mesh;
    }
	sets -forceElement ColorBakeSet `ls -dag -objectsOnly -geometry -selection`;//assign occlusion bake set to object

	////////////////////////Find Texture on Faces
		select $Temp_Mesh;
		$TexturePath = eval ("NinjaUV_SetBakeDirectory Color");
		$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes
		$Texture_Directory = `dirname $TexturePath`;//this is only the directory
		$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
		string $Color_Name = substituteAllString ($TextureName, ".", "_C.");
		string $buf[];
		$numTokens = `tokenize $Color_Name "." $buf`;
		string $FileName = $buf[0];
		textField -e -text ($Texture_Directory  +  $FileName + "." + $Extension ) "Bake_Path";//this is the export path
		setAttr -type "string" ColorBakeSet.prefix ($Texture_Directory  +  $FileName) ;//set the occlusion texture path

    ////////////////////////End Find Texture on Faces

	//overide settings
	setAttr "ColorBakeSet.xResolution" $AO_Width;
	setAttr "ColorBakeSet.yResolution" $AO_Height;
	setAttr "ColorBakeSet.backgroundColor" -type double3 $BackGroundColor[0] $BackGroundColor[1] $BackGroundColor[2] ;
	setAttr "ColorBakeSet.fillTextureSeams" $FillTexSeams;
	setAttr "ColorBakeSet.samples" $Samples;
	//bake the AO Map

	select $Temp_Mesh;
	print $Temp_Mesh;

	convertLightmapSetup  -camera persp -keepOrgSG -showcpv;

	delete $Temp_Mesh;

	showHidden $Sel;

	$AssignColorShader = `checkBox -q -v cb_Assign_ColorTexture`;
	if ($AssignColorShader == 1  && `size $Sel` != 0 )
	{

		int $Total_Color;
		if (`objExists ("Mat_NinjaColor*")` == 1)
			{
				select "Mat_NinjaColor*";
				string $SelMat_Color[] = `ls -sl -fl`;
				$Total_Color= `size $SelMat_Color`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaColor"  + $Total_Color)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaColor" + $Total_Color )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaColorTexure"  + $Total_Color) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaColor"  + $Total_Color)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Texture_Directory  +  $FileName + "." + $Extension ) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		//print $Sel;
		//print $SG_Name;
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }

	//print ($Texture_Directory  +  $FileName + "." + $Extension );
	system ("imconvert -sample 250 250 " + ($Texture_Directory  +  $FileName + "." + $Extension ) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Texture_Directory  +  $FileName + "." + $Extension );

}//end Bake AO

global proc string NinjaUV_Bake_ColorFlat()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	string $Sel[] = `ls -sl -fl -l`;
	$SourceBakeMesh = `duplicate -rr $Sel`;
	if (`size $SourceBakeMesh` > 1)
		{
			select $SourceBakeMesh;
			NinjaUV_Attach();
			$SourceBakeMesh = `ls -sl -fl -l`;
    	}

	$Tex_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$Tex_Height = `intField -q -v NinjaUV_BakeAO_Height`;

	$TexturePath = eval ("NinjaUV_SetBakeDirectory Color");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $Color_Name = substituteAllString ($TexturePath, ".tga" , "_C");
	textField -e -text ($Color_Name + "." + $Extension) "Bake_Path";//this is the export path

	//print $Color_Name;

	string $Temp_Mesh[] = `duplicate -rr`;
	$Temp_Mesh = `ls -sl -fl`;
	for ($r = 0; $r < (`size $Temp_Mesh`); $r++)
		{
			rename $Temp_Mesh[$r] ("Temp_Mesh_" + $r);
		}

	$Target_Mesh = `ls -sl -fl`;
	if (`size $Target_Mesh` > 1)
		{
			select $Target_Mesh;
			NinjaUV_Attach();
			$Target_Mesh = `ls -sl -fl -l`;
    	}

	//hide $Sel;
	//select $Target_Mesh;
	$OverScan = `intField -q -v ColorBake_OverScan`;
	surfaceSampler 	-target $Target_Mesh
					-uvSet map1
					-searchOffset 0
					-maxSearchDistance 0
					-searchCage ""
					-source $SourceBakeMesh
					-mapOutput diffuseRGB
					-mapWidth $Tex_Width
					-mapHeight $Tex_Height
					-max 0
					-mapSpace tangent
					-mapMaterials 0
					-shadows 0
					-filename $Color_Name
					-fileFormat $Extension
					-superSampling 0
					-filterType 0
					-filterSize 0
					-overscan $OverScan
					-searchMethod 0
					-useGeometryNormals 0
					-ignoreMirroredFaces 0
					-flipU 0
					-flipV 0;

	$AssignShader = `checkBox -q -v cb_Assign_ColorTexture`;
	if ($AssignShader == 1  && `size $Sel` != 0 )
	{

		int $Total_Color;
		if (`objExists ("Mat_NinjaColor*")` == 1)
			{
				select "Mat_NinjaColor*";
				string $SelMat_Color[] = `ls -sl -fl`;
				$Total_Color = `size $SelMat_Color`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaColor"  + $Total_Color)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaColor" + $Total_Color )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaColorTexure"  + $Total_Color) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaColor"  + $Total_Color)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Color_Name + "." + $Extension) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }

	delete  $SourceBakeMesh $Target_Mesh;
	showHidden $Sel;
	//system ("imconvert -sample 250 250 " + ($Color_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	system ("imconvert -sample 250 250 " + ($Color_Name + "." + $Extension ) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Color_Name + "." + $Extension);

}


global proc string NinjaUV_Bake_UVShellColor()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	string $Sel[] = `ls -sl -fl -l`;
	$SourceBakeMesh = `duplicate -rr $Sel`;
	if (`size $SourceBakeMesh` > 1)
		{
			select $SourceBakeMesh;
			NinjaUV_Attach();
			$SourceBakeMesh = `ls -sl -fl -l`;
    	}
	$DeleteShaders = `NinjaUV_RandomUVShellsShaders`;

	$Tex_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$Tex_Height = `intField -q -v NinjaUV_BakeAO_Height`;

	$TexturePath = eval ("NinjaUV_SetBakeDirectory Color");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $Color_Name = substituteAllString ($TexturePath, ".tga" , "_C");
	textField -e -text ($Color_Name + "." + $Extension) "Bake_Path";//this is the export path

	//print $Color_Name;

	string $Temp_Mesh[] = `duplicate -rr`;
	$Temp_Mesh = `ls -sl -fl`;
	for ($r = 0; $r < (`size $Temp_Mesh`); $r++)
		{
			rename $Temp_Mesh[$r] ("Temp_Mesh_" + $r);
		}

	$Target_Mesh = `ls -sl -fl`;
	if (`size $Target_Mesh` > 1)
		{
			select $Target_Mesh;
			NinjaUV_Attach();
			$Target_Mesh = `ls -sl -fl -l`;

    	}
	hide $Sel;
	select $Target_Mesh;

	surfaceSampler 	-target $Target_Mesh
					-uvSet map1
					-searchOffset 0
					-maxSearchDistance 0
					-searchCage ""
					-source $SourceBakeMesh
					-mapOutput diffuseRGB
					-mapWidth $Tex_Width
					-mapHeight $Tex_Height
					-max 1 -mapSpace tangent
					-mapMaterials 1 -shadows 1
					-filename $Color_Name
					-fileFormat $Extension
					-superSampling 0
					-filterType 0
					-filterSize 0
					-overscan 0
					-searchMethod 0
					-useGeometryNormals 1
					-ignoreMirroredFaces 0
					-flipU 0
					-flipV 0;

	$AssignShader = `checkBox -q -v cb_Assign_ColorTexture`;
	if ($AssignShader == 1  && `size $Sel` != 0 )
	{

		int $Total_Color;
		if (`objExists ("Mat_NinjaColor*")` == 1)
			{
				select "Mat_NinjaColor*";
				string $SelMat_Color[] = `ls -sl -fl`;
				$Total_Color = `size $SelMat_Color`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaColor"  + $Total_Color)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaColor" + $Total_Color )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaColorTexure"  + $Total_Color) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaColor"  + $Total_Color)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Color_Name + "." + $Extension) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }

	delete  $SourceBakeMesh $Target_Mesh $DeleteShaders;
	showHidden $Sel;
	//system ("imconvert -sample 250 250 " + ($Color_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	system ("imconvert -sample 250 250 " + ($Color_Name + "." + $Extension ) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($Color_Name + "." + $Extension);

}

global proc string NinjaUV_Bake_UV()
{
	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	$Sel = `ls -sl -fl`;

	$Texture_Width = `intField -q -v "NinjaUV_BakeAO_Width"`;
	$Texture_Height = `intField -q -v "NinjaUV_BakeAO_Height"`;

	string $Target_Mesh[] = `ls -sl -fl`;


	string $TexturePath;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory UV");
	$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
	$UV_Name = substituteAllString ($TextureName, ".", "_UV.");

	string $buf[];
	$numTokens = `tokenize $UV_Name "." $buf`;
	string $FileName = $buf[0];
	textField -e -text ($Texture_Directory  +  $UV_Name  ) "Bake_Path";//this is the export path

	$Umin = `floatField -q -v bake_Umin`;
	$Umax = `floatField -q -v bake_Umax`;
	$Vmin = `floatField -q -v bake_Vmin`;
	$Vmax = `floatField -q -v bake_Vmax`;
	uvSnapshot -aa -n ($Texture_Directory  +  $UV_Name ) -xr $Texture_Width -yr $Texture_Height -uMin $Umin -uMax $Umax -vMin $Vmin -vMax $Vmax -r 255 -g 255 -b 255 -o -ff $Extension;

	select $Sel;
	$AssignUVShader = `checkBox -q -v cb_Assign_UVTexture`;
	if ($AssignUVShader == 1  && `size $Sel` != 0 )
	{

		int $Total_UV;
		if (`objExists ("Mat_NinjaUV*")` == 1)
			{
				select "Mat_NinjaUV*";
				string $SelMat_UV[] = `ls -sl -fl`;
				$Total_LM = `size $SelMat_UV`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaUV"  + $Total_UV)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaUV" + $Total_UV )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaUVTexure"  + $Total_UV) -asTexture file`;//create texture node
		string $UV_Node_Name = `shadingNode -name ("UV_NinjaUV"  + $Total_UV)  -asUtility place2dTexture`;//create uv node


		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Texture_Directory  +  $UV_Name + "." + $Extension) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Node_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
		//print $Sel;
		//print $SG_Name;
		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }

	system ("imconvert -sample 250 250 " + ($Texture_Directory  +  $UV_Name) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return  ($Texture_Directory  +  $UV_Name);
}


global proc string NinjaUV_Bake_Checker()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	$BakeWidth =  `intField -q -v NinjaUV_BakeAO_Width`;
	$BakeHeight = `intField -q -v NinjaUV_BakeAO_Height`;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory Checker");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $Checker_Name = substituteAllString ($TexturePath, ".", "_Checker.");
	textField -e -text ($Checker_Name) "Bake_Path";//this is the export path

	string $Sel[] = `ls -sl -fl -l`;

	$CheckerPlane = `polyPlane -ch on -o on -ax 0 0 1 -w 1 -h 1 -sw 1 -sh 1 -cuv 2 `;
	int $Total_Checker;
	if (`objExists ("Mat_NinjaChecker*")` == 1)
		{
			select "Mat_NinjaChecker*";
			string $SelMat_Checker[] = `ls -sl -fl`;
			$Total_Checker = `size $SelMat_Checker`;
		}

	else
	{
		$Total_Checker = 0;
    }

	string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaChecker" + $Total_Checker )`;//create a material node
	string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaChecker" + $Total_Checker  )`;//create a Shading Group node
	string $CheckerName = `shadingNode -asTexture checker -name ("Tex_NinjaChecker" + $Total_Checker )`;
	setAttr ($CheckerName + ".color2") -type double3 0.5 0.5 0.5 ;


	string $UV_CheckerName = `shadingNode -name ("UV_NinjaChecker" + $Total_Checker )  -asUtility place2dTexture`;//create uv node
	setAttr ($UV_CheckerName + ".repeatU") ($BakeWidth / 32);
	setAttr ($UV_CheckerName + ".repeatV") ($BakeHeight / 32);


	connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
	connectAttr -force ($UV_CheckerName + ".outUV")  ($CheckerName + ".uvCoord");//connects uv node to texture node
	connectAttr -force ($CheckerName  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

	sets -e -forceElement $SG_Name $CheckerPlane[0];//assign material to object

	//$Samples = 3;
	$BakePlane = `polyPlane -ch on -o on -ax 0 0 1 -w 1 -h 1 -sw 1 -sh 1 -cuv 2 `;
	string $CheckerBakePath = substituteAllString ($Checker_Name, ("." + $Extension), "");
	surfaceSampler -target $BakePlane
					   -uvSet map1
					   -searchOffset 0
					   -maxSearchDistance 0
					   -searchCage ""
					   -source $CheckerPlane[0]
					   -mapOutput diffuseRGB
					   -mapWidth $BakeWidth
					   -mapHeight $BakeHeight
					   -max 1 -mapSpace tangent
					   -mapMaterials 1 -shadows 1
					   -filename $CheckerBakePath
					   -fileFormat $Extension
					   -superSampling 0
					   -filterType 0
					   -filterSize 3
					   -overscan 1
					   -searchMethod 0
					   -useGeometryNormals 1
					   -ignoreMirroredFaces 0
					   -flipU 0
					   -flipV 0;


	$Texture_Name = `shadingNode -name ("Tex_NinjaCheckerTexure" + $Total_Checker ) -asTexture file`;//create texture node
	$UV_Name = `shadingNode -name ("UV_NinjaTexture" + $Total_Checker )  -asUtility place2dTexture`;//create uv node
	setAttr -type "string" ($Texture_Name + ".fileTextureName") ($Checker_Name) ;//assign texture to texture node
	connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
	connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

	//print $SG_Name;
	$AssignCheckerTexture = `checkBox -q -v cb_Assign_CheckerTexture`;
	if ($AssignCheckerTexture == 1  && `size $Sel` != 0 )
	{
		sets -e -forceElement $SG_Name $Sel;//assign material to object

    }

	delete $CheckerPlane $BakePlane $CheckerName $UV_CheckerName;
	system ("imconvert -sample 250 250 " + ($Checker_Name) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return $Checker_Name;

}

global proc string NinjaUV_Bake_Combine()
{


	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	$Tex_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$Tex_Height = `intField -q -v NinjaUV_BakeAO_Height`;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory ColorBake");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $CombineBake_Name = substituteAllString ($TexturePath, ("." + $Extension), "_C");
	textField -e -text ($CombineBake_Name + "." + $Extension) "Bake_Path";//this is the export path

	string $Sel[] = `ls -sl -fl -l`;

	//create Source Base Mesh
	$SourceBakeMesh = `duplicate -n "TargetBakeMesh" -rr $Sel`;
	if (`size $Sel` > 1)
	{
		NinjaUV_Attach;
    }
	$SourceBakeMesh = `ls -sl -fl -l`;
	// end create source mesh


	$OverlapShells = `checkBox -q -v cb_CombineOverlapShells`;
	if ($OverlapShells == 1)
	{

		string $UVShell_Array[] = `eval ("NinjaUV_CollectShells()")`;
		string $DetachedMesh[] = {};
		string $DetatchedUVs[] = {};
		//seperate object by similar shells
		for ($a = 0; $a < `size $UVShell_Array`; $a++)
			{

				string $SingleShell_a[];
				tokenize $UVShell_Array[$a] "," $SingleShell_a;

				int $testUV =  stringArrayContains($SingleShell_a[0], $DetatchedUVs);
				if ($testUV == 0)
				{
					select -r $SingleShell_a;
					doMenuComponentSelection($SourceBakeMesh[0], "puv");
					$SelUVs = `ls -sl -fl -l`;

					if (`size $SelUVs` != 0)
					{
						NinjaUV_SelectSimilarShells;
						$SimilarUVs = `ls -sl -fl -l`;

						appendStringArray($DetatchedUVs, $SimilarUVs, `size $SimilarUVs`);
						$DetatchedUVs = `stringArrayRemoveDuplicates $DetatchedUVs`;
						ConvertSelectionToFaces;
						$Faces = `ls -sl -fl -l`;
						//error;
						if (`size Faces` != 0)
						{
							doMenuComponentSelection($SourceBakeMesh[0], "facet");
							NinjaMesh_Extract;
							$SelMesh = `ls -sl -fl -l`;
							appendStringArray($DetachedMesh, $SelMesh, `size $SelMesh`);
							//rename "Detached" ;
							//error;
						}//end if

					}//end if

                }//end if
			}//end for a
		delete $SourceBakeMesh;
		select $DetachedMesh;

		//detach unique UVShell Mesh
		string $UniquMesh[] = {};
		for ($d = 0; $d < `size $DetachedMesh`; $d++)
			{
				select $DetachedMesh[$d];
				string $UVShell_Array[] = `eval ("NinjaUV_CollectShells()")`;
				string $SingleShell[];
				tokenize $UVShell_Array[0] "," $SingleShell;
				select $SingleShell;
				ConvertSelectionToFaces;
				doMenuComponentSelection($DetachedMesh[$d], "facet");
				NinjaMesh_Extract;
				rename ("Unique_" + `shortNameOf $DetachedMesh[$d]`);
				$Sel = `ls -sl -fl -l`;
				$UniquMesh[$d] = $Sel[0];
            }

		select $UniquMesh;
		polyMultiLayoutUV -lm 1 -sc 1 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 0 -su 1 -sv 1 -ou 0 -ov 0;

		for ($u = 0; $u < `size $UniquMesh`; $u++)
		{
			select $UniquMesh[$u];
			ConvertSelectionToUVs;
			float $UV_BoundsUnique[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
			string $TargetMesh = substituteAllString($UniquMesh[0], "Unique_", "");
			select $TargetMesh;
			ConvertSelectionToUVs;
			float $UV_BoundsTarget[] = `polyEvaluate -bc2`;//xmin xmax ymin ymax
			float $DistU = $UV_BoundsUnique[0] - $UV_BoundsTarget[0];
			float $DistV = $UV_BoundsUnique[2] - $UV_BoundsTarget[2];
			polyEditUV -relative true -u $DistU -v $DistV ;

        }
		error;
	}//End


	//Layout Target BaseMesh
	string $TargetBakeMesh[] = $Sel;
	$ReNinjaUV_ScaleUV = `checkBox -q -v cb_CombineReNinjaUV_ScaleUV`;
	if ($ReNinjaUV_ScaleUV == 1)
	{
		select $TargetBakeMesh;
		checkBox -e -v 0 AutoSetSize;
		NinjaUV_QuickScale;
    }

	select $TargetBakeMesh;

	performPolyLayoutUV 0;
	//


	//Create CombineBake Mesh
	$CombineBakeMesh = `duplicate -n "CombineBakeMesh" -rr $TargetBakeMesh`;
	$NewMeshes = `ls -sl -fl -l`;

	if (`size $CombineBakeMesh` > 1)
	{
		NinjaUV_Attach;
		$CombineBakeMesh = `ls -sl -fl -l`;
    }
	//

	//error;
	$UVSetName = `textField -q -tx BakeUVSet`;
	if ($UVSetName != "map1")
	{
		polyCopyUV -uvSetNameInput $UVSetName -uvSetName map1 -ch 1 $CombineBakeMesh;
    }

	select $CombineBakeMesh;


	//performPolyLayoutUV 0;

	//polyMultiLayoutUV -lm 1 -sc 1 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 0 -su 1 -sv 1 -ou 0 -ov 0;

	print $CombineBake_Name;

	surfaceSampler 	-target $CombineBakeMesh
					-uvSet map1
					-searchOffset 0
					-maxSearchDistance 0
					-searchCage ""
					-source $SourceBakeMesh
					-mapOutput diffuseRGB
					-mapWidth $Tex_Width
					-mapHeight $Tex_Height
					-max 1 -mapSpace tangent
					-mapMaterials 1 -shadows 1
					-filename $CombineBake_Name
					-fileFormat $Extension
					-superSampling 0
					-filterType 0
					-filterSize 3
					-overscan 1
					-searchMethod 0
					-useGeometryNormals 1
					-ignoreMirroredFaces 0
					-flipU 0
					-flipV 0;


	int $Total_CombineBake;
	if (`objExists ("Mat_NinjaCombineBake*")` == 1)
		{
			select "Mat_NinjaCombineBake*";
			string $SelMat_CombineBake[] = `ls -sl -fl`;
			$Total_CombineBake = `size $SelMat_CombineBake`;
		}

	else
	{
		$Total_CombineBake = 0;
    }

	string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaCombineBake"  + $Total_CombineBake)`;//create a Shading Group node
	string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaCombineBake" + $Total_CombineBake )`;//create a material node
	string $Texture_Name = `shadingNode -name ("Tex_NinjaCombineBakeTexure"  + $Total_CombineBake) -asTexture file`;//create texture node
	string $UV_Name = `shadingNode -name ("UV_CombineBakeColor"  + $Total_CombineBake)  -asUtility place2dTexture`;//create uv node

	setAttr -type "string" ($Texture_Name + ".fileTextureName") ($CombineBake_Name + "." + $Extension) ;//assign texture to texture node
	connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
	connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
	connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

	sets -e -forceElement $SG_Name $TargetBakeMesh;//assign material to object
	if (`size $NewMeshes` > 1)
	{
		delete $CombineBakeMesh $SourceBakeMesh;
    }

	$Combine = `checkBox -q -v cb_CombineCombine`;
	if ($Combine == 1)
	{
		select $TargetBakeMesh;
		NinjaUV_Attach;
    }
	//select $CombineBakeMesh;
	system ("imconvert -sample 250 250 " + ($CombineBake_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	return ($CombineBake_Name + "." + $Extension);
}



global proc NinjaUV_Bake_StoreObject()
{
	$Sel = `ls -sl -fl -l`;
	textField -e -tx $Sel[0] ObjectBake_TargetName;
	radioButtonGrp  -e -select 2  ObjectBakeTarget;
}

global proc string NinjaUV_Bake_Object()
{

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }

	$Tex_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$Tex_Height = `intField -q -v NinjaUV_BakeAO_Height`;
	$TexturePath = eval ("NinjaUV_SetBakeDirectory Color");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $CombineBake_Name = substituteAllString ($TexturePath, ".tga" , "_C");
	textField -e -text ($CombineBake_Name + "." + $Extension) "Bake_Path";//this is the export path
	$Sel = `ls -sl -fl -l`;

	$BakeTargetType = `radioButtonGrp  -q -select  ObjectBakeTarget`;
	string $BakeTarget;
	if ($BakeTargetType == 1)
	{
		$BakeTarget = eval ("NinjaUV_CreatePlane");

    }

	if ($BakeTargetType == 2)
	{
		$BakeTarget = `textField -q -tx ObjectBake_TargetName`;
    }

	print $BakeTarget;
	//error;
	if ($BakeTarget != "")
	{
		select $Sel;
		$CombineBakeMesh = `duplicate -n "CombineBakeMesh" -rr $Sel`;
		$NewMeshes = `ls -sl -fl -l`;
		if (`size $NewMeshes` > 1)
		{
			NinjaUV_Attach;
			$Sel = `ls -sl -fl -l`;
			$CombineBakeMesh = `duplicate -n "CombineBakeMesh" -rr $Sel`;
		}


		$UVSetName = `textField -q -tx BakeUVSet`;
		if ($UVSetName != "map1")
		{
			polyCopyUV -uvSetNameInput $UVSetName -uvSetName map1 -ch 1 $CombineBakeMesh;
		}


		//select $CombineBakeMesh;


		surfaceSampler 	-target $BakeTarget
						-uvSet map1
						-searchOffset 0
						-maxSearchDistance 0
						-searchCage ""
						-source $CombineBakeMesh
						-mapOutput diffuseRGB
						-mapWidth $Tex_Width
						-mapHeight $Tex_Height
						-max 1 -mapSpace tangent
						-mapMaterials 1 -shadows 1
						-filename $CombineBake_Name
						-fileFormat $Extension
						-superSampling 0
						-filterType 0
						-filterSize 3
						-overscan 1
						-searchMethod 0
						-useGeometryNormals 1
						-ignoreMirroredFaces 0
						-flipU 0
						-flipV 0;


		int $Total_CombineBake;
		if (`objExists ("Mat_NinjaCombineBake*")` == 1)
			{
				select "Mat_NinjaCombineBake*";
				string $SelMat_CombineBake[] = `ls -sl -fl`;
				$Total_CombineBake = `size $SelMat_CombineBake`;
			}

		else
		{
			$Total_CombineBake = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaCombineBake"  + $Total_CombineBake)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaCombineBake" + $Total_CombineBake )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaCombineBakeTexure"  + $Total_CombineBake) -asTexture file`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_CombineBakeColor"  + $Total_CombineBake)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($CombineBake_Name + "." + $Extension) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

		sets -e -forceElement $SG_Name $BakeTarget;//assign material to object
		if (`size $NewMeshes` > 1)
		{
			delete $Sel;
		}
		delete $CombineBakeMesh;

		system ("imconvert -sample 250 250 " + ($CombineBake_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
		image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;

    }

	else
	{

		error "There is no target object specified for custom object";
    }

	return ($CombineBake_Name + "." + $Extension);
}

global proc NinjaUV_Bake_MultiBake()

{
	$Sel = `ls -sl -fl -l`;

	$PSD_Width = `intField -q -v NinjaUV_BakeAO_Width`;
	$PSD_Height = `intField -q -v NinjaUV_BakeAO_Height`;

	$Bake_AO = `checkBox -q -v  cb_Multi_AO`;
	$Bake_LM = `checkBox -q -v  cb_Multi_LM`;
	$Bake_UV = `checkBox -q -v  cb_Multi_UV`;
	$Bake_Color = `checkBox -q -v  cb_Multi_Color`;
	$Bake_UVShellColors = `checkBox -q -v  cb_Multi_ShellColors`;
	//$Bake_Combine = `checkBox -q -v  cb_Multi_Combine`;
	$Bake_Checker = `checkBox -q -v  cb_Multi_Checker`;



	///////////////////Duplicate and Combine the Meshes
	string $Temp_Mesh[] = `duplicate `;

	if (`size $Temp_Mesh` > 1)
		{

			NinjaUV_Attach();
			$Temp_Mesh = `ls -sl -fl -l`;

    	}
	hide $Sel;
	select $Temp_Mesh;
	///////////////////End Duplicate and Combine the Meshes

	string $Bake_Path;
	string $LM_Path;
	string $UV_Path;
	string $Color_Path;
	string $Checker_Path;

	string $BakeArray[] = {};
	string $BakeArrayPath[] = {};
	string $BakeString = "";
	//if ($Bake_Combine == 1)
	//{
	//	$Color_Path = eval ("NinjaUV_Bake_Combine");
	//	$Temp_Mesh = `ls -sl -fl -l`;
	//	$BakeString = ($BakeString + " -addChannlImage Color "  + $Color_Path);
	//	stringArrayInsertAtIndex (0,$BakeArray, "Combine");
	//	stringArrayInsertAtIndex (0,$BakeArrayPath, $Color_Path);
    //}

	if ($Bake_UVShellColors == 1)
	{
		$Color_Path = eval ("NinjaUV_Bake_UVShellColor");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage Color "  + $Color_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "UVShellColor");
		stringArrayInsertAtIndex (0,$BakeArrayPath, $Color_Path);
    }

	if ($Bake_AO == 1)
	{
		$AO_Path = eval ("NinjaUV_Bake_AO");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage AO "  + $AO_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "AO");
		stringArrayInsertAtIndex (0,$BakeArrayPath, $AO_Path);
    }

	if ($Bake_LM == 1)
	{
		$LM_Path = eval ("NinjaUV_Bake_LM");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage LM "  + $LM_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "LM");
		stringArrayInsertAtIndex (0,$BakeArrayPath, $LM_Path);

    }

	if ($Bake_UV == 1)
	{
		$UV_Path = eval ("NinjaUV_Bake_UV");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage UV " + $UV_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "UV");
		stringArrayInsertAtIndex (0,$BakeArrayPath,  $UV_Path);
    }

	if ($Bake_Color == 1)
	{
		$Color_Path = eval ("NinjaUV_Bake_ColorFlat");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage Color "  + $Color_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "Color");
		stringArrayInsertAtIndex (0,$BakeArrayPath, $Color_Path);
    }


	if ($Bake_Checker == 1)
	{
		$Checker_Path = eval ("NinjaUV_Bake_Checker");
		select $Temp_Mesh;
		$BakeString = ($BakeString + " -addChannlImage Checker "  + $Checker_Path);
		stringArrayInsertAtIndex (0,$BakeArray, "Checker");
		stringArrayInsertAtIndex (0,$BakeArrayPath, $Checker_Path);
    }

	delete $Temp_Mesh;
	showHidden  $Sel;

	$PSDPath = eval ("NinjaUV_SetBakeDirectory Multi");

	$PSDPath = substituteAllString ($PSDPath, "\\", "/");//fix slashes
	$PSD_Directory = `dirname $PSDPath`;//this is only the directory
	$TextureName =  substituteAllString ($PSDPath, $PSD_Directory, "");
	string $PSD_Name = substituteAllString ($TextureName, ".", "_Multi.");

	textField -e -text ($PSD_Directory + $PSD_Name) "Bake_Path";//this is the export path
	$AssignPSD = `checkBox -q -v  cb_Assign_PSDTexture`;
	if ($AssignPSD == 1  && `size $Sel` != 0 )
	{

		int $Total_Color;
		if (`objExists ("Mat_NinjaPSD*")` == 1)
			{
				select "Mat_NinjaPSD*";
				string $SelMat_Color[] = `ls -sl -fl`;
				$Total_Color = `size $SelMat_Color`;
			}

		else
		{
			$Total_Color = 0;
		}

		string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_NinjaPSD"  + $Total_Color)`;//create a Shading Group node
		string $Mat_Name = `shadingNode -shared -asShader blinn -name ("Mat_NinjaPSD" + $Total_Color )`;//create a material node
		string $Texture_Name = `shadingNode -name ("Tex_NinjaPSDTexure"  + $Total_Color) -asTexture psdFileTex`;//create texture node
		string $UV_Name = `shadingNode -name ("UV_NinjaPSD"  + $Total_Color)  -asUtility place2dTexture`;//create uv node

		setAttr -type "string" ($Texture_Name + ".fileTextureName") ($PSD_Directory + $PSD_Name) ;//assign texture to texture node
		connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
		connectAttr -f ($UV_Name + ".coverage")  ($Texture_Name + ".coverage");//connects uv node to texture node
		connectAttr -force ($Texture_Name  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node

		sets -e -forceElement $SG_Name $Sel;//assign material to object
    }



	//print $BakeString;


	psdTextureFile -xr $PSD_Width -yr $PSD_Height
	-chs "Dummy" 1 true
	-psf ($PSD_Directory + $PSD_Name);



	psdEditTextureFile -deleteChannel Dummy -psf ($PSD_Directory + $PSD_Name);

	for ($i = 0; $i < (`size $BakeArray`); $i++)
		{
			psdEditTextureFile -addChannelImage $BakeArray[$i] $BakeArrayPath[$i] -psf ($PSD_Directory + $PSD_Name);
        }

	//psdEditTextureFile
	//-deleteChannel Dummy
	//-addChannelImage Checker $Checker_Path
	//-addChannelImage Color   $Color_Path
	//-addChannelImage AO   $Bake_Path
	//-addChannelImage LM  $LM_Path
	//-addChannelImage UV   $UV_Path
	//-psf ($PSD_Directory + $PSD_Name);

	//Combine Textures into a PSD

	//createLayeredPsdFile -xr $PSD_Width -yr $PSD_Height
	//-ifn "Layer Checker"  "Normal" $Checker_Path
	//-ifn "Layer Color"  "Normal" $Color_Path
	//-ifn "Layer AO" "Multiply"  $Bake_Path
	//-ifn "Layer LM"  "Overlay" $LM_Path
	//-ifn "Layer UV"  "Difference" $UV_Path
	//-psf ($PSD_Directory + $PSD_Name);



	int $OpenPSD = `checkBox -q -v cb_Open_PSDTexture`;
	if ($OpenPSD == 1)
	{
		NinjaUV_ViewAOMap;
    }

	system ("imconvert -sample 250 250 " + ($PSD_Directory + $PSD_Name) + " " + ($PSD_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($PSD_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;
	//print $PSDPath;



}

global proc NinjaUV_Bake_Range()
{
	$Sel = `ls -sl -fl- l`;
	ConvertSelectionToUVs;
	$UVExtents = `polyEvaluate -bc2`;//xmin xmax ymin ymax
	float $Umax = ($UVExtents[1] + .5);
	int $UTiles = `floor $Umax`;

	float $Vmax = ($UVExtents[3] + .5);
	int $VTiles = `floor $Vmax`;


	for ($u = 0; $u < $UTiles; $u++)
		{
			for ($v = 0; $v < $VTiles; $v++)
			{

				floatField -e -v $u bake_Umin;
				floatField -e -v ($u + 1) bake_Umax;
				floatField -e -v $v bake_Vmin;
				floatField -e -v ($v + 1) bake_Vmax;
				select $Sel;
				NinjaUV_Bake_MultiBake;

            }

        }

}

global proc NinjaUV_Bake_ScreenTiles()
{

	if ((`window -ex NinjaMapWindow`) == true)
	{
		deleteUI NinjaMapWindow;
	}


	string $NinjaLight_Window;
	$Ninja_MapWindow = `window -t "NinjaMapWindow" -wh 900 900 "NinjaMapWindow"`;
	string $pnlLayout = `paneLayout`;
	string $mdlPanel = `modelPanel`;
	showWindow $Ninja_MapWindow;
	window -e -wh 1000 1000 "NinjaMapWindow";
	lookThroughModelPanelClipped "top" $mdlPanel  0.001 10000;
	setAttr "top.scaleX" 1.3235;
	setAttr "top.scaleY" 1.3235;
	setAttr "top.scaleZ" 1.3235;
	DisplayShadedAndTextured;
	modelEditor -e -allObjects 0 $mdlPanel;
	modelEditor -e -polymeshes 1 $mdlPanel;
	modelEditor -e -grid 0 $mdlPanel;
	//error;

	$Plane = `ls -sl -fl -l`;
	//Create a new Plane
	$Sel_Extents = `polyEvaluate -b $Plane`; //xmin xmax ymin ymax zmin zmax
	float $Sel_Width = $Sel_Extents [1] - $Sel_Extents[0];
	float $Sel_Depth = $Sel_Extents [3] - $Sel_Extents[2];
	float $Sel_Height = $Sel_Extents [5] - $Sel_Extents[4];

	float $Sel_CenterX = (($Sel_Extents[0] + $Sel_Extents[1]) / 2);
	float $Sel_CenterY = (($Sel_Extents[2] + $Sel_Extents[3]) / 2);
 	float $Sel_CenterZ = (($Sel_Extents[4] + $Sel_Extents[5]) / 2);

	$ScreenTileRes = `intField -q -v IF_BakeScreenTileRes`;
	$Num_ScreenTiles = `intField -q -v IF_BakeScreenTiles`;
	$BasePlane = `polyPlane -ch on -o on -w $Sel_Width -h $Sel_Height -sw 1 -sh 1 -sx $Num_ScreenTiles -sy $Num_ScreenTiles -cuv 2 `;
	move $Sel_CenterX ($Sel_CenterY - 100 ) $Sel_CenterZ $BasePlane;

	//Create and Assign New Shader
	string $BaseSG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("BaseSG_MapReferece")`;//create a Shading Group node
	string $BaseSurfaceShader = `shadingNode -asShader surfaceShader`;
	setAttr ($BaseSurfaceShader + ".outColor") -type double3 0 0 1;
	connectAttr -force ($BaseSurfaceShader  + ".outColor") ($BaseSG_Name + ".surfaceShader");//connects material node to Shading Group node
	sets -e -forceElement $BaseSG_Name $BasePlane;//assign material to object

	////
	select $BasePlane;
	ConvertSelectionToFaces;
	$Faces = `ls -sl -fl -l`;
	hide $Plane;
	setAttr "defaultRenderGlobals.imageFormat" 19;
	$MayaLocation = `internalVar -uad`;
	string $OpenFile = `file -q -sn`;

	string $buf[];
	$numTokens = `tokenize $OpenFile "/" $buf`;
	string $FileName = $buf[(`size $buf` - 1)];
	string $bufB[];
	$numTokens = `tokenize $FileName "." $bufB`;
	string $FilePrefix = $bufB[0];
	sysFile -md ($MayaLocation + "NinjaMaps");
	string $MapTileArray[] = {};
	string $RefObject;

	//string $CleanUpArray[] = {};
	for ($f = 0; $f < `size $Faces` ; $f++)
		{
			select $Faces[$f];
			FrameSelected;
			select -d;
			playblast -orn off -st 1 -et 1 -w 800 -h 800 -p 100 -v off -fo -fmt image -f ($MayaLocation + "NinjaMaps/" + $FilePrefix + $f);
			$MapTileArray[$f] = ($MayaLocation + "NinjaMaps/" + $FilePrefix + $f + ".0001.tga" );

			string $SG_Name = `sets -renderable true -noSurfaceShader true -empty -name ("SG_MapReferece")`;//create a Shading Group node
				string $SurfaceShader = `shadingNode -asShader surfaceShader`;
				string $TextureFileNode = `shadingNode -n "TempMapNode" -asTexture file`;
				//setAttr ($SurfaceShader + ".outColor") -type double3 0 1 0 ;
				connectAttr -force ($SurfaceShader  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
				connectAttr -force ($TextureFileNode  + ".outColor") ($SurfaceShader + ".outColor");//connects texture node to Shading Node

				sets -e -forceElement $SG_Name $Faces[$f];//assign material to Face of the BasePlane
				setAttr -type "string" ($TextureFileNode + ".fileTextureName") ($MayaLocation + "NinjaMaps/" + $FilePrefix + $f + ".0001.tga" );//assign texture path to texture node
				playblast -orn off -st 1 -et 1 -w 800 -h 800 -p 100 -v off -fo -fmt image -f ($MayaLocation + "NinjaMaps/" + $FilePrefix + ($f + 1));

        }



	deleteUI NinjaMapWindow;
	setAttr "top.scaleX" 1;
	setAttr "top.scaleY" 1;
	setAttr "top.scaleZ" 1;

	select $BasePlane;
	polyForceUV -unitize ;
	select $BasePlane;

	$BakeTarget = eval ("NinjaUV_CreatePlane");
	//$TargetPlane = `duplicate -rr $BasePlane`;
	//select $TargetPlane;
	//polyProjection -ch 1 -type Planar -ibd on -md b $TargetPlane[0];

	//Bakeout Final image

	$TexOutput_Format = `radioButtonGrp  -q -select TexOutput_Format`;
	string $Extension;
	if ($TexOutput_Format == 1)
	{
		$Extension = "bmp";
    }

	if ($TexOutput_Format == 2)
	{
		$Extension = "tga";
    }

	if ($TexOutput_Format == 3)
	{
		$Extension = "tif";
    }

	if ($TexOutput_Format == 4)
	{
		$Extension = "jpg";
    }


	$TexturePath = eval ("NinjaUV_SetBakeDirectory Color");
	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	string $ScreenTile_Name = substituteAllString ($TexturePath, ".tga" , "_C");
	textField -e -text ($ScreenTile_Name + "." + $Extension ) "Bake_Path";//this is the export path


	surfaceSampler 	-target $BakeTarget
						-uvSet map1
						-searchOffset 0
						-maxSearchDistance 0
						-searchCage ""
						-source $BasePlane
						-mapOutput diffuseRGB
						-mapWidth ($ScreenTileRes * $Num_ScreenTiles)
						-mapHeight ($ScreenTileRes * $Num_ScreenTiles)
						-max 1
						-mapSpace tangent
						-mapMaterials 1
						-shadows 0
						-filename $ScreenTile_Name
						-fileFormat $Extension
						-superSampling 0
						-filterType 0
						-filterSize 1
						-overscan 1
						-searchMethod 0
						-useGeometryNormals 1
						-ignoreMirroredFaces 0
						-flipU 0
						-flipV 0;

	delete $BakeTarget $BasePlane;

	system ("imconvert -sample 250 250 " + ($ScreenTile_Name + "." + $Extension) + " " + ($Texture_Directory  +  "/BakePreview.xpm" ) );
	image -e -i ($Texture_Directory  +  "/BakePreview.xpm" )  Image_NinjaBakePreview;

}

global proc string NinjaUV_CreatePlane()
{
	string $sel[] = `ls -sl -l -fl`;
	$Sel_Extents = `polyEvaluate -b $sel`;
	float $Sel_Width = $Sel_Extents [1] - $Sel_Extents[0];
	float $Sel_Depth = $Sel_Extents [3] - $Sel_Extents[2];
	float $Sel_Height = $Sel_Extents [5] - $Sel_Extents[4];
	//$Prefix = `textField -q -tx Collision_Name`;

	string $Col_Plane[];
	if (($Sel_Height < $Sel_Depth) && ($Sel_Height < $Sel_Width ))
		{
			$Bake_Plane = `polyPlane -name "BakePlane" -ch on -o on -ax 0 0 1 -w $Sel_Width -h $Sel_Depth -sw 1 -sh 1 -cuv 2`;
		}
	if (($Sel_Depth < $Sel_Height) && ($Sel_Depth < $Sel_Width))
		{
			$Bake_Plane = `polyPlane -name "BakePlane" -ch on -o on -ax 0 0 1 -w $Sel_Width -h $Sel_Height -sw 1 -sh 1 -cuv 2`;
			rotate -r -os 90 0 0 ;
		}

	if (($Sel_Width < $Sel_Height) && ($Sel_Width < $Sel_Depth))
		{
			$Bake_Plane = `polyPlane -name "BakePlane" -ch on -o on -ax 0 0 1 -w $Sel_Depth -h $Sel_Height -sw 1 -sh 1 -cuv 2`;
			rotate -r -os 90 0 0 ;
			rotate -r -os 0 90 0 ;
		}

	string $Bake_Plane[] = `ls -sl -l -fl`;
	float $Plane_Extents[] = `polyEvaluate -b $Bake_Plane[0]`;//xmin xmax ymin ymax zmin zmax, get bounding box of new collision object
	xform -ws -piv $Plane_Extents[0] $Plane_Extents[2] $Plane_Extents[4] ; //set the pivot to lower bounding box
	move -rpr -ws $Sel_Extents[0] $Sel_Extents[2] $Sel_Extents[4] ;//move collision to lower bounding box of selection
	polyNormalizeUV -normalizeType 1 -preserveAspectRatio off ;
	xform -cp $Bake_Plane;

	return $Bake_Plane[0];

}


global proc NinjaUV_ViewAOMap()
{
	string $AO_File = `textField -q -text "Bake_Path"`;
	//print $AO_File;
	system ("load " + $AO_File);

}

global proc Explore_AO_Map()
{
	string $AO_File = `textField -q -text "Bake_Path"`;
	$AO_File =  substituteAllString($AO_File, "/", "\\");
	system ("explorer /select,\"" + $AO_File);

}

global proc Preview_AO_Mesh()
{

	$sel = `ls -sl -fl -l`;
	//get material
	ConvertSelectionToFaces;
	$Selected_Face = `ls -sl -fl`;
	string $Face_Material = NinjaUV_GetFaceTexture($Selected_Face[0]);// gets texture node name
	$TexturePath = `getAttr ($Face_Material + ".fileTextureName")` ;//get texture name
	$TexturePath = substituteAllString ($TexturePath, "\\", "/");//fix slashes

	$Texture_Directory = `dirname $TexturePath`;//this is only the directory
	$TextureName =  substituteAllString ($TexturePath, $Texture_Directory, "");
	$AO_Name = substituteAllString ($TextureName, ".", "_AO.");
	string $Bake_Path = ($TexturePath  +  $AO_Name);

	textField -e -text ($Texture_Directory   +  $AO_Name ) "Bake_Path";//this is the export path

	select $sel;
	duplicate -rr;
	$AO_Mesh = `ls -sl -fl -l`;
	string $new_object = `rename "AO_mesh" `;//renames the combined mesh
	$AO_Mesh = `ls -sl -fl -l`;

	string $SG_Name;

	if (`objExists ("AO_Material")`)
	{
		//catchQuiet (`delete "AO_Material1" "AO_Material" "Tex_AO" "UV_AO"`);
		setAttr -type "string" Tex_AO.fileTextureName ($Texture_Directory   +  $AO_Name );
		AEfileTextureReloadCmd Tex_AO.fileTextureName;

    }


	else
	{
			string $Mat_Name = `shadingNode -shared -asShader blinn -name ("AO_Material")` ;//create a material node
			$SG_Name = `sets -renderable true -noSurfaceShader true -empty -name "AO_Material"`;//create a Shading Group node

			$BL_Texture = `shadingNode -name "Tex_AO" -asTexture file`;//create texture node
			$BL_UV = `shadingNode -name "UV_AO"  -asUtility place2dTexture`;//create uv node

			connectAttr -force ($Mat_Name  + ".outColor") ($SG_Name + ".surfaceShader");//connects material node to Shading Group node
			connectAttr -f ($BL_UV + ".coverage")  ($BL_Texture + ".coverage");//connects uv node to texture node
			connectAttr -force ($BL_Texture  + ".outColor") ($Mat_Name + ".color");//connects texture node to Shading Node
			setAttr -type "string" ($BL_Texture + ".fileTextureName") ($Texture_Directory +  $AO_Name + ".tga") ;//assign texture to texture node
			AEfileTextureReloadCmd Tex_AO.fileTextureName;
	}

		//AEfileTextureReloadCmd Juicer:Mat_Grid_1024_Tag_Diffuse_bitmap.fileTextureName;
		select $AO_Mesh;
		sets -e -forceElement AO_Material1;//assign material to object
		hide $sel;

}


//////////////////////////////////////////////////////////////Bake Options/////////////////////////////////////////////////////////////////

global proc NinjaUV_TransferUV()
{
	$sel = `selectedNodes`;
	$last = ((`size $sel`) -1);
	float $last_position[] = `xform -q -ws -piv $sel[$last]`;
	string $TransferMesh[] = `duplicate $sel[0]`;
	//move -rpr $last_position[0] $last_position[1] $last_position[2] $TransferMesh[0];

	select -r $TransferMesh[0];
	select -add $sel[$last];
	//transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -flipUVs 0 -colorBorders 1 ;
	//transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 4 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1 ;
	transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 4 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0 ;
	select $sel;
	DeleteHistory;
	delete $TransferMesh;
}

global proc NinjaUV_CopyUVs()
{
	ConvertSelectionToFaces;
	global string $CopyFaceUVs[];
	$CopyFaceUVs = `ls -sl -fl -l`;
}

global proc NinjaUV_PasteUVs()
{
	global string $CopyFaceUVs[];
	ConvertSelectionToFaces;

	//get target mesh
	string $TargetFaces[] = `ls -sl -fl -l`;
	string $buffer[];
	tokenize $TargetFaces[0] "." $buffer;
	string $TargetMesh = $buffer[0];

	//get Source Mesh
	string $SourceFaces[] = $CopyFaceUVs;
	string $buffer[];
	tokenize $SourceFaces[0] "." $buffer;
	string $SourceMesh = $buffer[0];

	//store Target Face IDs
	string $TargetFaceIDs[] = {};
	for ($f = 0 ;$f < `size $TargetFaces`; $f++)
		{
			string $buffer[];
			tokenize $TargetFaces[$f] "." $buffer;
			stringArrayInsertAtIndex (0, $TargetFaceIDs, $buffer[1]);
        }

	//store source Face IDs
	string $SourceFacesIDs[] = {};
	for ($f = 0 ;$f < `size $SourceFaces`; $f++)
		{
			string $buffer[];
			tokenize $SourceFaces[$f] "." $buffer;
			stringArrayInsertAtIndex (0, $SourceFacesIDs, $buffer[1]);
        }


	//detach temp source mesh
	string $DupObject[] = `duplicate -rr $SourceMesh`;
	select $DupObject;
	string $DupFaceSelectionArray[] = {};
	for ($s = 0 ;$s < `size $SourceFacesIDs`; $s++)
		{
			stringArrayInsertAtIndex (0, $DupFaceSelectionArray, ($DupObject[0] + "." + $SourceFacesIDs[$s]));
        }

	select $DupFaceSelectionArray;
	doMenuComponentSelection($DupObject[0], "facet");
	NinjaUV_DetachFaces;
	$TempSourceMesh = `ls -sl -fl -l`;
	delete $DupObject;


	//detach temp target mesh
	string $DupObject[] = `duplicate -rr $TargetMesh`;
	select $DupObject;
	string $TargetFaceSelectionArray[] = {};
	for ($t = 0 ;$t < `size $TargetFaceIDs`; $t++)
		{
			stringArrayInsertAtIndex (0, $TargetFaceSelectionArray, ($DupObject[0] + "." + $TargetFaceIDs[$t]));

        }
	select $TargetFaceSelectionArray;
  	doMenuComponentSelection($DupObject[0], "facet");
	NinjaUV_DetachFaces;
	$TempTargetMesh = `ls -sl -fl -l`;
	delete $DupObject;

	//create TargetAttachMesh
	string $TargetAttachObject[] = `duplicate -rr $TargetMesh`;
	select -cl;
	string $DeleteFaces[] = {};

	for ($x = 0 ;$x < `size $TargetFaceIDs`; $x++)
		{
			stringArrayInsertAtIndex (0, $DeleteFaces, ($TargetAttachObject[0] + "." + $TargetFaceIDs[$x]) );
        }

	delete $DeleteFaces;

	float $mayaVersion = `getApplicationVersionAsFloat` ;
	//transfer UV's
	select $TempSourceMesh;
	select -add $TempTargetMesh;
	if ($mayaVersion >= 2011)
		{
			transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 5 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0;
	    }
	else
		{
			transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 4 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0;
        }

	DeleteHistory;

	select  $TempTargetMesh $TargetAttachObject;
	NinjaUV_Attach;
	$CombinedMesh = `ls -sl -fl -l`;

	//TranferMethod
	select $CombinedMesh;
	select -add $TargetMesh ;

	//NinjaUV_TransferUV;
	transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 1 -sourceUvSet "map1" -targetUvSet "map1" -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0 ;
	DeleteHistory;
	delete $CombinedMesh $TempSourceMesh;
	doMenuComponentSelection($TargetMesh, "facet");
	select $TargetFaces;
	ConvertSelectionToUVs;

	//CombineMethod
	//delete $TargetMesh $TempSourceMesh;
	//rename $CombinedMesh $TargetMesh;


}

global proc NinjaUV_MirrorPasteUVs()
{
	global string $CopyFaceUVs[];
	ConvertSelectionToFaces;

	//get target mesh
	string $TargetFaces[] = `ls -sl -fl -l`;
	string $buffer[];
	tokenize $TargetFaces[0] "." $buffer;
	string $TargetMesh = $buffer[0];

	//get Source Mesh
	string $SourceFaces[] = $CopyFaceUVs;
	string $buffer[];
	tokenize $SourceFaces[0] "." $buffer;
	string $SourceMesh = $buffer[0];



	//store Target Face IDs
	string $TargetFaceIDs[] = {};
	for ($f = 0 ;$f < `size $TargetFaces`; $f++)
		{
			string $buffer[];
			tokenize $TargetFaces[$f] "." $buffer;
			stringArrayInsertAtIndex (0, $TargetFaceIDs, $buffer[1]);
        }

	//store source Face IDs
	string $SourceFacesIDs[] = {};
	for ($f = 0 ;$f < `size $SourceFaces`; $f++)
		{
			string $buffer[];
			tokenize $SourceFaces[$f] "." $buffer;
			stringArrayInsertAtIndex (0, $SourceFacesIDs, $buffer[1]);
        }


	//detach temp source mesh
	string $DupObject[] = `duplicate -rr $SourceMesh`;

	//select -cl;
	select $DupObject;
	string $DupFaceSelectionArray[] = {};
	for ($s = 0 ;$s < `size $SourceFacesIDs`; $s++)
		{
			stringArrayInsertAtIndex (0, $DupFaceSelectionArray, ($DupObject[0] + "." + $SourceFacesIDs[$s]));
			//select -add ($DupObject[0] + "." + $SourceFacesIDs[$s]);
        }
	select $DupFaceSelectionArray;

	//error;

	doMenuComponentSelection($DupObject[0], "facet");
	NinjaUV_DetachFaces;
	$TempSourceMesh = `ls -sl -fl -l`;
	delete $DupObject;


	//detach temp target mesh
	string $DupObject[] = `duplicate -rr $TargetMesh`;
	select $DupObject;
	//select -cl;
	string $TargetFaceSelectionArray[] = {};
	for ($t = 0 ;$t < `size $TargetFaceIDs`; $t++)
		{
			stringArrayInsertAtIndex (0, $TargetFaceSelectionArray, ($DupObject[0] + "." + $TargetFaceIDs[$t]));
			//select -add ($DupObject[0] + "." + $TargetFaceIDs[$t]);
        }
	select $TargetFaceSelectionArray;

  	doMenuComponentSelection($DupObject[0], "facet");
	NinjaUV_DetachFaces;
	$TempTargetMesh = `ls -sl -fl -l`;
	delete $DupObject;

	//create TargetAttachMesh
	string $TargetAttachObject[] = `duplicate -rr $TargetMesh`;
	select -cl;
	string $DeleteFaces[] = {};

	for ($x = 0 ;$x < `size $TargetFaceIDs`; $x++)
		{
			stringArrayInsertAtIndex (0, $DeleteFaces, ($TargetAttachObject[0] + "." + $TargetFaceIDs[$x]) );
			//select -add ($TargetAttachObject[0] + "." + $SelectedFaceIDs[$y]);
        }

	delete $DeleteFaces;


	//transfer UV's
	select $TempSourceMesh;
	scale -r -1 1 1 ;
	polyNormal -normalMode 0 -userNormalMode 0 -ch 1;
	select -add $TempTargetMesh;
	transferAttributes -flipUVs 1 -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 5 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0  $TempSourceMesh[0] $TempTargetMesh[0];
	DeleteHistory;

	//error;
	select  $TempTargetMesh $TargetAttachObject;
	NinjaUV_Attach;
	$CombinedMesh = `ls -sl -fl -l`;

	select $CombinedMesh;
	select -add $TargetMesh ;

	transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 0  $CombinedMesh[0] $TargetMesh ;
	DeleteHistory;

	delete $CombinedMesh $TempSourceMesh;
	doMenuComponentSelection($TargetMesh, "facet");
	select $TargetFaces;
	ConvertSelectionToUVs;

}


global proc Build_Ninja_UV_HUD()
{
	hudButton -s 2 -b 2 -ba "right"  -vis 1 -l "add edges" -bw 80 -bsh "rectangle" -rc "NinjaUV_Edge_AddEdges"  NinjaUV_Add_Edges;
	hudButton -s 2 -b 4 -ba "right"  -vis 1 -l "Ninja Mapping" -bw 80 -bsh "rectangle" -rc "Ninja_UV_Map_it"  NinjaUV_NinjaMap;
}

global proc Delete_Ninja_UV_HUD()
{
	headsUpDisplay -rem NinjaUV_Add_Edges;
	headsUpDisplay -rem NinjaUV_NinjaMap;
}

global proc NinjaUV_BakeSetsCreate()
{
	$BakeSetName = `textField -q -tx tf_BakeSetName`;
	$NewBakeSetName = `createBakeSet $BakeSetName textureBakeSet`;
	$Sel = `ls -dag -objectsOnly -geometry -selection`;
	if (`size $Sel` != 0)
		{
			sets -forceElement $NewBakeSetName $Sel;
		}
	NinjaUV_BakeSetRefreshList;
}

global proc NinjaUV_BakeSetAdd()
{
	$SelBakeList = `textScrollList -q -si BakeSet_List`;
	$Sel = `ls -dag -objectsOnly -geometry -selection`;
	if (`size $Sel` != 0)
		{
			sets -forceElement $SelBakeList $Sel;
		}
}

global proc NinjaUV_BakeSetDelete()
{
	$SelBakeList = `textScrollList -q -si BakeSet_List`;
	delete $SelBakeList;
	NinjaUV_BakeSetRefreshList;
}

global proc NinjaUV_BakeSetEdit()
{
	$SelBakeList = `textScrollList -q -si BakeSet_List`;
	showEditor $SelBakeList[0];
	select -r -ne $SelBakeList[0];
}

global proc NinjaUV_BakeSetRename()
{
	$SelBakeList = `textScrollList -q -si BakeSet_List`;
	$NewName = `textField -q -tx tf_BakeSetName`;
	rename $SelBakeList[0] $NewName;
	NinjaUV_BakeSetRefreshList;
}

global proc NinjaUV_BakeSetRefreshList()
{
	string $BakeSetArray[] = `ls -type "textureBakeSet"`;
	textScrollList -e -ra BakeSet_List;//Clear out list
	for ($i = 0; $i < (`size $BakeSetArray`); $i++)
		{
			textScrollList -e -append $BakeSetArray[$i] BakeSet_List;
        }//end for
}

global proc NinjaUV_BakeSetSelectObjects()
{
	$BakeList = `textScrollList -q -si BakeSet_List`;
	select $BakeList;
	textField -e -tx $BakeList[0] tf_BakeSetName;
}

global proc NinjaUV_BakeSetsBakeIt()
{
	$SelBakeList = `textScrollList -q -si BakeSet_List`;
	for ($i = 0; $i < (`size $SelBakeList`); $i++)
		{
			select $SelBakeList[$i];
			NinjaUV_Bake_MultiBake;

        }//end for
}

global proc Build_Ninja_UV_Menu()
{
		menuBarLayout;
			menu -label "UI";
       			menuItem -label "BarMode" -c ("Ninja_UVBar");
				menuItem -label "UVMode" -c ("NinjaUV_UVMode");
				menuItem -label "Dock (2011+)" -c ("Ninja_UVDock");
				menuItem -label "FullMode" -c ("Ninja_UVFull");
				menuItem -label "Create UV HUD" -c ("Build_Ninja_UV_HUD");
				menuItem -label "Delete UV HUD" -c ("Delete_Ninja_UV_HUD");
				menuItem -label "UV Split" -c ("NinjaUV_SplitLayout");

			menu -label "Window";
       			menuItem -label "UV Editor" -c ("TextureViewWindow");
				menuItem -label "Hypershade" -c ("HypershadeWindow");
				menuItem -label "BarMode" -c ("Ninja_UV");
				menuItem -label "UVMode" -c ("Ninja_UVUV");
				menuItem -label "FullMode" -c ("Ninja_UVFull");
				menuItem -label "Create UV HUD" -c ("Build_Ninja_UV_HUD");
				menuItem -label "Delete UV HUD" -c ("Delete_Ninja_UV_HUD");


			menu -label "Select";
       			menuItem -label "Select Hard Edges" -c ("Ninja_UV_SelectHardEdge");
				menuItem -label "Select Interior UV's" -c ("Ninja_UV_SelectInteriorUVs");
				menuItem -label "Select Border Edges" -c ("Ninja_UV_SelectBorderEdge");
				menuItem -label "Select Similar Shells" -c ("NinjaUV_SelectSimilarShells");
				menuItem -label "Select By Same Material" -c ("NinjaUV_SelectByShader");

			menu -label "UV's";
				menuItem -label "quick scale UV" -c ("NinjaUV_QuickScale()");
				menuItem -label "quick fix UV" -c ("NinjaUV_QuickFix()");
				menuItem -label "Quick Straighten UV Edges" -c ("NinjaUV_QuickStraighten()");
				menuItem -label "Detach UV Shell" -c ("NinjaUV_DetachShell()");

			menu -label "Mesh";
					menuItem -label "Cut Edge and Seperate" -c ("NinjaUV_CutAndSeperate()");
					menuItem -label "Detach Faces " -c ("NinjaUV_DetachFaces()");
					menuItem -label "Detach By UV Shells " -c ("NinjaUV_DetachByShells()");
					menuItem -label "Attach Objects " -c ("NinjaUV_Attach()");
					menuItem -label "Colorize UV Shells " -c ("NinjaUV_ColorUVShells()");
					menuItem -label "Un-Colorize UV Shells " -c ("NinjaUV_UnColorUVShells()");

			menu -label "Help" -helpMenu true;
       			//menuItem -label "Open Help Page" -c ("Open_Ninja_UV_Help()");
				menuItem -label "get face material" -c ("NinjaUV_FindTexture()");
				//menuItem -label "Select Faces With Same Material" -c ("NinjaUV_FindSameMaterial()");
				menuItem -label "Calculate Pixel Ratio" -c ("NinjaUV_CheckPixelRatio()");
				menuItem -label "Transfer UV's" -c ("NinjaUV_TransferUV()");
				menuItem -label "Calculate UV usage" -c ("NinjaUV_CalcuateUVArea");

}


global proc string  Build_frame_UV_PixelRatio()
{
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global float $NinjaUV_FrameColor[];

	$HelpText = (
				"----------------------------------------------------Pixel Ratio -------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn"  -label "Scale (Pixel Ratio)"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_PixelRatio ;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_PixelRatio 1");
		columnLayout;

			rowColumnLayout -nc 6 -cw 1 ($NinjaUV_UIWidth /6)  -cw 2 ($NinjaUV_UIWidth /6)  -cw 3 ($NinjaUV_UIWidth /6) -cw 4 ($NinjaUV_UIWidth /6)  -cw 5 ($NinjaUV_UIWidth /6)  -cw 6 ($NinjaUV_UIWidth /6) ;
				iconTextButton -rpt 1 -l "64"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
				-c ("floatField -e -v 64 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 64 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );

				iconTextButton -rpt 1 -l "96"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
				-c ("floatField -e -v 96 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 96 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );

				iconTextButton -rpt 1 -l "128"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
				-c ("floatField -e -v 128 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 128 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );

				iconTextButton -rpt 1 -l "256"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
				-c ("floatField -e -v 256 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 256 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );

				iconTextButton -rpt 1 -l "512"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
				-c ("floatField -e -v 512 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 512 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );

				iconTextButton -rpt 1 -l "1024"  -h 18  -style "textOnly" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
				-c ("floatField -e -v 1024 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio" )
				-dcc ("floatField -e -v 1024 NinjaUV_PixelRatio; " + "NinjaUV_SetPixelRatio;" + "NinjaUV_QuickScale" );
			setParent..;//parent rowColumnLayout


				string $UnitScale = `currentUnit -q -l`;
				float $UnitSize = 1;

					if ($UnitScale == "cm")
					{
						$UnitSize = 1000;
					}

					if ($UnitScale == "cm")
					{
						$UnitSize = 100;
					}

					if ($UnitScale == "m")
					{
						$UnitSize = 1;
					}

					if ($UnitScale == "in")
					{
						$UnitSize = 12;
					}

					if ($UnitScale == "ft")
					{
						$UnitSize = 1;
					}

					if ($UnitScale == "yd")
					{
						$UnitSize = 1;
					}

				rowColumnLayout -numberOfColumns 4 -cw 1 60 -cw 2 60 -cw 3 60 -cw 4 60 ;

					floatField -v 128 -pre 2 -w 50 -cc ("NinjaUV_SetPixelRatio") NinjaUV_PixelRatio;
					text -l "Pixels Per" ;

					floatField -v $UnitSize -pre 2 -w 50 -cc ("NinjaUV_SetPixelRatio") NinjaUV_UnitRatio;
					optionMenu -cc ("NinjaUV_SetUnitScale") NinjaUV_UnitScale;
						menuItem -l "mm";
						menuItem -l "cm";
						menuItem -l "m";
						menuItem -l "in";
						menuItem -l "ft";
						menuItem -l "yd";

					//text -l ("Unit  (" + $UnitScale + ")") NinjaUV_UnitScale;
				setParent..;


			separator   -height 4 -width $NinjaUV_UIWidth;

			rowColumnLayout -nc 2 -cw 1 175  -cw 2 75 ;
				checkBox -label "Auto Find Texture Size  (input)"  -value 1 AutoSetSize;
				textField -w 100 -tx "color" TextureInputConnection;
					popupMenu;
						menuItem -l "color" -c ("textField -e -tx \"color\" TextureInputConnection");
						menuItem -l "diffuse" -c ("textField -e -tx \"diffuse\" TextureInputConnection");
				setParent..;

			rowColumnLayout -nc 6 -cw 1 ($NinjaUV_UIWidth /6)  -cw 2 ($NinjaUV_UIWidth /6)  -cw 3 ($NinjaUV_UIWidth /6) -cw 4 ($NinjaUV_UIWidth /6)  -cw 5 ($NinjaUV_UIWidth /6)  -cw 6 ($NinjaUV_UIWidth /6) ;
						button -l "64"  -h 18
						//-bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
						-c ("floatField -e -v 64 Tex_ScaleU; "
							+ "floatField -e -v 64 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

						button -l "128"  -h 18
						//-bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
						-c ("floatField -e -v 128 Tex_ScaleU; "
							+ "floatField -e -v 128 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

						button  -l "256"  -h 18
						//-bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
						-c ("floatField -e -v 256 Tex_ScaleU; "
							+ "floatField -e -v 256 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

						button  -l "512"  -h 18
						//-bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
						-c ("floatField -e -v 512 Tex_ScaleU; "
							+ "floatField -e -v 512 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

						button  -l "1024"  -h 18
						//-bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]
						-c ("floatField -e -v 1024 Tex_ScaleU; "
							+ "floatField -e -v 1024 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

						button  -l "2048"  -h 18
						//-bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2]
						-c ("floatField -e -v 2048 Tex_ScaleU; "
							+ "floatField -e -v 2048 Tex_ScaleV; "
							+ "checkBox -e -value 0 AutoSetSize; "
							+ "NinjaUV_SetPixelRatio" );

					setParent..;//parent rowColumnLayout

			button -l "find and set Texture size"  -w $NinjaUV_UIWidth -h 18  -c ("checkBox -e -value 0 AutoSetSize; " + "NinjaUV_FindTexture; " );
			rowLayout -numberOfColumns 4 -columnWidth4  ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4);
				text "Tex Width";
				floatField -v 1024 -pre 0 -w 50 -cc ("checkBox -e -value 0 AutoSetSize; " + "NinjaUV_SetPixelRatio") Tex_ScaleU ;
				text "Tex Height";
				floatField -v 1024 -pre 0 -w 50 -cc ("checkBox -e -value 0 AutoSetSize; " + "NinjaUV_SetPixelRatio") Tex_ScaleV ;
			setParent..;

			rowLayout -en 0 -vis 1 -numberOfColumns 4 -columnWidth4 ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4) ($NinjaUV_UIWidth /4);
				text "Map Size U" ;
				floatField -v 400 -pre 2  -w 50 Map_ScaleU ;
				text "Map Size V" ;
				floatField -v 400 -pre 2  -w 50 Map_ScaleV ;
			setParent..;

			separator   -height 4 -width $NinjaUV_UIWidth;


			radioButtonGrp  -numberOfRadioButtons 3  -label "" -labelArray3 "Center" "Bottom Left" "Group" -select 1 -columnWidth4 1 75 100 50  QuickScale_Location;

			rowColumnLayout -nc 3  -cw 1 ($NinjaUV_UIWidth / 3) -cw 2 ($NinjaUV_UIWidth / 3) -cw 3 ($NinjaUV_UIWidth / 3);
				button -label "Quick scale" -annotation "Scales Uv's based on pixel ratio and texture size settings"   -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]  -w ($NinjaUV_UIWidth / 3) -h 24 -c ("NinjaUV_QuickScale()");
				button -label "Scale To last" -annotation "Scales Uv's based on pixel ratio and texture size settings"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w ($NinjaUV_UIWidth / 3) -h 24 -c ("NinjaUV_ScaleToLast()");
				button -label "Check Ratio" -annotation "Scales Uv's based on pixel ratio and texture size settings"    -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w ($NinjaUV_UIWidth / 3) -h 20 -c ("NinjaUV_CheckPixelRatio()");
			setParent..;

			//button -l "Quick Scale Group" -c "NinjaUV_QuickScaleGroup";

		setParent..;//parent columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}

global proc string  Build_frame_UV_UnfoldOptions()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

	$HelpText = (
				"----------------------------------------------------Unfold Options -------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Unfold options"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_UnfoldOptions;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_UnfoldOptions 1");
		columnLayout;
			//separator   -height 4 -width $NinjaUV_UIWidth;
			rowLayout -nc 2  -columnWidth2 150 50;
				text "Unfold Iterations" ;
				floatField -v 100 -pre 0 -w 50  -cc ("Set_Unfold_Accuracy") Unfold_Iterations;
			setParent..;//rowLayout

			rowLayout -nc 3  -columnWidth3 90 60 80;
				checkBox -label "Auto Unfold" -value 1 NinjaUV_QuickUnfold_Auto_unfold;
				checkBox -label "Scale" -value 0 QM_Adjust_Scale;
				checkBox -label "Pin Borders" -value 0 Hold_Edge;
			setParent..;//rowLayout

			string $RB_Group1 = ` radioButtonGrp  -numberOfRadioButtons 4  -label "" -labelArray4 "None" "H - V" "H Strip" "H" -select 1 -columnWidth5 1 ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4) -cc("NinjaUV_AutoUnfoldOff") Map_HV1`;
			radioButtonGrp -numberOfRadioButtons 4   -shareCollection $RB_Group1 -label "" -labelArray4 "Both"  "V - H" "V Strip" "V" -columnWidth5  1 ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4) ($NinjaUV_UIWidth / 4)  -cc("NinjaUV_AutoUnfoldOff") Map_HV;
			button -label "Quick Unfold"  -annotation "Unfolds UV's using unfold option settings above" -w $NinjaUV_UIWidth -h 25 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_QuickUnfold()");
			//popupMenu;
		setParent..; //columnLayout
	setParent..; //frameLayout -bs "etchedIn"
	return $HelpText;
}


global proc string  Build_frame_UV_CutEdges()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Cut Edges -------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Cut Edges/Seams"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_CutEdges ;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_CutEdges 1");
		columnLayout;
			//separator   -height 4 -width $NinjaUV_UIWidth;
				textScrollList -width $NinjaUV_UIWidth -numberOfRows 6 -allowMultiSelection true  -sc ("NinjaUV_Edge_SelectEdges")EdgeSpline_list;
				popupMenu;
					menuItem -label "Add Edges" 	-c ("NinjaUV_Edge_AddEdges()");
					menuItem -label "Remove Edges"  -c ("NinjaUV_Edge_RemoveEdges()");
					menuItem -label "Replace Edges" -c ("NinjaUV_Edge_ReplaceEdges()");
					//menuItem -label "Add Hard Edges" -c ("Ninja_UV_SelectHardEdge()");
					menuItem -label "Clear Edges"	-c ("NinjaUV_Edge_ClearEdges()");
					//menuItem -label "Save Edge List" 	-c ("NinjaUV_Edge_SaveEdgeList()");
					menuItem -label "Load Edge List" 	-c ("NinjaUV_Edge_LoadEdgeList()");
					menuItem -label "Select All Edges" 	-c ("NinjaUV_Edge_SelectAllEdgeList()");

				rowColumnLayout -nc 6 -cw 1 ($NinjaUV_UIWidth/6) -cw 2 ($NinjaUV_UIWidth/6) -cw 3 ($NinjaUV_UIWidth/6) -cw 4 ($NinjaUV_UIWidth/6) -cw 5 ($NinjaUV_UIWidth/6) -cw 6 ($NinjaUV_UIWidth/6);
					button -l "add" -c ("NinjaUV_Edge_AddEdges()");
					button -l "remove" -c ("NinjaUV_Edge_RemoveEdges()");
					button -l "replace" -c ("NinjaUV_Edge_ReplaceEdges()");
					button -l "clear" -c ("NinjaUV_Edge_ClearEdges()");
					button -l "load" -c ("NinjaUV_Edge_LoadEdgeList()");
					button -l "select" -c ("NinjaUV_Edge_LoadEdgeList()");
				setParent..;
		setParent..;//parent columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}



global proc string  Build_frame_UV_NinjaMapping()
{
	global string $MayaIconFolder;
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Ninja Mapping -------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Ninja Mapping"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_NinjaMapping ;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_NinjaMapping 1");
		columnLayout;
			//separator   -height 4 -width $NinjaUV_UIWidth;
				radioButtonGrp -numberOfRadioButtons 2 -label "Map Type:" -labelArray2  "Planar"  "Best Fit" -select 1  -columnWidth3  60 75 75 Map_Gizmo;
				rowColumnLayout -nc 2 -columnWidth 1 125 -columnWidth 2 125;
					//checkBox -label "True Camera" -value 0 True_Camera;
					checkBox -label "Start UV's at 0"  -value 0 Set_Zero;
					//checkBox -label "Auto Cut Hard Edges"  -value 0 CutHardEdges;
					//checkBox -label "Interactive"  -onc ("Start_Interactive") -ofc ("Kill_Interactive");
					//checkBox -label "Flatten Cut Edges"  -value 1 Flatten_CutEdges;
					checkBox -l "Layout 0-1" -v 0 cb_LayoutUVs;
					checkBox -label "Fix Cut Edges"  -value 1 Fix_CutEdges;
					checkBox -l "Delete History" -v 0 cb_UVDeleteHistory;
				setParent..;

				separator   -height 4 -width $NinjaUV_UIWidth;
					rowColumnLayout -nc 4 -columnWidth 1  60 -columnWidth 2 60 -columnWidth 3 60  -columnWidth 4 60;
						//button -label "Auto\n Mapping" -annotation "maps planar to camera direction" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 36 -c ("NinjaUV_NinjaMapping");
						button -label "Preview" -w 60 -h 50 -annotation "preview mapping"   -c ("NinjaUV_PreviewUVs");
						iconTextButton -l "HV" -w 60 -h 70 -style "iconAndTextVertical" -c ("NinjaUV_ForceMapping HV")iconButton_HV;
						iconTextButton -l "VH" -w 60 -h 70 -style "iconAndTextVertical" -c ("NinjaUV_ForceMapping VH")iconButton_VH;
						iconTextButton -l "Both" -w 60 -h 70 -style "iconAndTextVertical" -c ("NinjaUV_ForceMapping Both")iconButton_Both;
					setParent..;

				rowColumnLayout -nc 3 -cw 1 35 -cw 2 30 -cw 3 150 ;
					text -l "Angle";
					intField -v 0 -min 0 - max 90 int_NinjaUVAngleSelect;
					button -l "Select By Face Angle" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -c "NinjaUV_SelectByFaceAngle";

				setParent..;

				separator   -height 4 -width $NinjaUV_UIWidth;
				if (`filetest -r ($MayaIconFolder + "NinjaUV_NinjaMapping.xpm")` == 1)
					{
						rowColumnLayout -nc 3 -columnWidth 1  83 -columnWidth 2 83 -columnWidth 3 83 ;
							text -l "Ninja Mapping";
							text -l "Uniform Mapping";
							text -l "Tube Mapping";

							iconTextButton -ann "Ninja Mapping" -rpt 1  -w 64 -h 40 -style "iconOnly" -image1 ("NinjaUV_NinjaMapping.xpm") -c ("NinjaUV_NinjaMapping") ;
							iconTextButton -ann "Uniform Mapping" -rpt 1  -w 64 -h 40 -style "iconOnly" -image1 ("NinjaUV_UniformMapping.xpm") -c ("NinjaUV_UniformMapping") ;
							iconTextButton -ann "Tube Mapping" -rpt 1  -w 64 -h 40 -style "iconOnly" -image1 ("NinjaUV_TubeMapping.xpm") -c ("NinjaUV_TubeMapping") ;
						setParent..;
					}

				else
					{
						button -label "Ninja Map" -annotation "maps planar to camera direction" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 250 -h 40 -c ("NinjaUV_NinjaMapping");
						rowColumnLayout -nc 2 -columnWidth 1  125 -columnWidth 2 125;
							button -label "Uniform Map" -annotation "Uniform Mapping select edges you want cut and run" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 64 -h 25 -c ("NinjaUV_UniformMapping()");
							button -label "Tube Map" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 25 -w 64 -c ("NinjaUV_TubeMapping");
						setParent..;
					}

				rowColumnLayout -nc 5 -columnWidth 1 ($NinjaUV_UIWidth/5) -columnWidth 2 ($NinjaUV_UIWidth/5) -columnWidth 3 ($NinjaUV_UIWidth/5) -columnWidth 4 ($NinjaUV_UIWidth/5) -columnWidth 5 ($NinjaUV_UIWidth/5);

					//text -l "Planar";
					//text -l "Cylinder";
					//text -l "Sphere";
					//text -l "Auto";
					//text -l "UV Editor";

					shelfButton -l "Planar Map" -i polyPlanProj.xpm 		-c "NinjaUV_ApplyMapping Planar" -dcc "";
					shelfButton -l "Cylindrical Map" -i polyCylProj.xpm 	-c "NinjaUV_ApplyMapping Cylindrical";
					shelfButton -l "Sphere Map" -i polySphereProj.xpm		-c "NinjaUV_ApplyMapping Sphere";
					shelfButton -l "Auto Map" -i polyAutoProj.xpm 			-c "NinjaUV_ApplyMapping Auto";
					shelfButton -l "UV Editor" -i textureEditor.xpm 		-c "NinjaUV_UVEditor";
				setParent..;

					button -label "Transfer Map Objects" -annotation "select Target last" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_TransferUV()");

			rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth/2) -cw 2 ($NinjaUV_UIWidth/2);
				button -label "Copy UV" -w ($NinjaUV_UIWidth/2) -c "NinjaUV_CopyUVs";
				iconTextButton -rpt 1 -style "textOnly" -label "Paste UV" -annotation "select Target last" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_PasteUVs()");
			setParent..;

			button -label "Mirror Paste UVs" -w ($NinjaUV_UIWidth) -c "NinjaUV_MirrorPasteUVs";
		setParent..; //columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}

global proc Build_frame_UV_TransferMapping()
{

	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Transfer Mapping" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_TransferMapping;
		columnLayout;
			button -label "Transfer Map Objects" -annotation "select Target last" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_TransferUV()");

			rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth/2) -cw 2 ($NinjaUV_UIWidth/2);
				button -label "Copy UV" -w ($NinjaUV_UIWidth/2) -c "NinjaUV_CopyUVs";
				iconTextButton -rpt 1 -style "textOnly" -label "Paste UV" -annotation "select Target last" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_PasteUVs()");
			setParent..;


		setParent..;
	setParent..;
}


global proc Build_frame_UV_LiveMapping()
{

	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Live Mapping" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_LiveMapping;
		columnLayout;
			button -l "Start Live Mapping" -w $NinjaUV_UIWidth -bgc 0 1 0 -c ("NinjaUV_LiveMappingStart") button_LiveMapping;
		setParent..;
	setParent..;
}

global proc string  Build_frame_UV_EdgeMapping()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Edge Mapping -------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Edge Mapping (works on objects only)" -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_EdgeMapping;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_EdgeMapping 1");
		columnLayout;
		//separator   -height 4 -width $NinjaUV_UIWidth;
			//button -label "Edge Mapping (2010 and below)" -annotation "maps between 2 edges" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 30 -w $NinjaUV_UIWidth -c ("NinjaUV_EdgeMap()");
		//separator   -height 4 -width $NinjaUV_UIWidth;



		setParent..; //columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}


global proc string  Build_frame_UV_QuickFixUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Quick Fix UV-------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Quick Fix UV's"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_QuickFixUV;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_AdjustUV 1");
		columnLayout;
			button -label "Quick Fix UV"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 24 -c ("NinjaUV_QuickFix()");
			popupMenu;
						//menuItem -label "Fix U" -c ("Unfold_Selected U");
						//menuItem -label "Fix V" -c ("Unfold_Selected V");
						menuItem -label "Fix Border Uv's" -c ("NinjaUV_NinjaUV_QuickFixBorder");
						menuItem -label "Fix Interior Uv's" -c ("NinjaUV_NinjaUV_QuickFixInterior");
			rowColumnLayout -nc 2 -cw 1 125 -cw 2 125;
				button -label "Quick Fix U"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("Unfold_Selected U");
				button -label "Quick Fix V"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("Unfold_Selected V");
				button -label "Cut and Fix Edge"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("NinjaUV_CutAndFix Edge");
				button -label "Cut and Fix Shell"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("NinjaUV_CutAndFix Shell");
			setParent..;
		setParent..; //columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}


global proc Build_frame_UV_StraightenUV(string $Parent)
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Straighten UV's" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_StraightenUV;
			columnLayout;
				progressBar -height 10 -width $NinjaUV_UIWidth -bgc 1 0 0 ("UVStraighten_progressbar" + $Parent);
				text -l "Straighten Process: " -w $NinjaUV_UIWidth ("UVStraighten_process" + $Parent);
				intSliderGrp -l "Angle Tolerence" -field true -cw 1 85 -cw 2 50 -cw 3 100 -v 30 -minValue 0 -maxValue 45 ("UVStraighten_Angle" + $Parent);
				button -label "Straighten Horizontal / Vertical" -annotation "straigtens selected UVs" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 25  -w ($NinjaUV_UIWidth) 	-c ("NinjaUV_StraightenUVSelection Both " + $Parent);

				rowColumnLayout -nc 2 -cw 1 125 -cw 2 125;
					button -label "Straigten Horizontal"  -annotation "straigtens horizontal UVs" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("NinjaUV_StraightenUVSelection Horizontal " + $Parent);
					button -label "Straigten Vertical"  -annotation "straigtens vertical UVs" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w 125 -h 24 -c ("NinjaUV_StraightenUVSelection Vertical " + $Parent);
				setParent..;

			setParent..;
		setParent..;
}


global proc string  Build_frame_UV_AdjustUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Adjust UV-------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Adjust UV's"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_AdjustUV;
		popupMenu;
		menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_AdjustUV 1");
		columnLayout;

			rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2);
				button -label "Align Shell Horizontal"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "snaps 2 shells together with 2 uv's selected" -h 24  -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_AlignUVShellEdge Horizontal");
				button -label "Align Shell Vertical"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "snaps 2 shells together with 2 uv's selected" -h 24  -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_AlignUVShellEdge Vertical");
			setParent..;


			button -label "quick relax"  -annotation "Fixes Distored Textures" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 24 -c ("NinjaUV_QuickRelax()");
			button -label "Detach UV Shell" -annotation "Detach UV shell based on face selection"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 24 -c ("NinjaUV_DetachShell()");
			button -label "Move/Sew Nearest Edge" -annotation "Detach UV shell based on face selection"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 24 -c ("NinjaUV_SewNearestEdge()");
			//button -label "Move/Sew Best Guess Edge" -annotation "Detach UV shell based on face selection"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w $NinjaUV_UIWidth -h 24 -c ("NinjaUV_SewBestEdge()");
			//rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2);
			//	button -label "Copy UV's"  -h 20  -c ("NinjaUV_CopyPasteUV Copy");
			//	button -label "Paste UV's" -h 20  -c ("NinjaUV_CopyPasteUV Paste");
			//setParent..;


		setParent..; //columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}



global proc string  Build_frame_UV_MoveUV(string $Parent)
{
	global string $MayaIconFolder;
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Move UV-------------------------------------------------*\n"+
				"\n"
				);

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Move UV's"  -width $NinjaUV_FrameWidth -cl false -cll true -p $Parent frame_UV_MoveUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_MoveUV 1");
		columnLayout;
		//separator   -height 4 -width $NinjaUV_UIWidth;
			rowColumnLayout -nc 8 -cw 1 ($NinjaUV_UIWidth /8)  -cw 2 ($NinjaUV_UIWidth /8)  -cw 3 ($NinjaUV_UIWidth /8) -cw 4 ($NinjaUV_UIWidth /8) -cw 5 ($NinjaUV_UIWidth /8) -cw 6 ($NinjaUV_UIWidth /8) -cw 7 ($NinjaUV_UIWidth /8) -cw 8 ($NinjaUV_UIWidth /8);
				button -l ".05"   -h 20 -c ("floatField -e -v .05 UV_Move_AmountBar");
				button -l ".1"    -h 20 -c ("floatField -e -v .1 UV_Move_AmountBar");
				button -l ".125"  -h 20 -c ("floatField -e -v .125 UV_Move_AmountBar");
				button -l ".25"   -h 20 -c ("floatField -e -v .25 UV_Move_AmountBar");
				button -l ".5"    -h 20 -c ("floatField -e -v .5 UV_Move_AmountBar") ;
				button -l "1"     -h 20 -c ("floatField -e -v 1 UV_Move_AmountBar");
				button -l "U" 	  -h 20 -c ("NinjaUV_CalculateUVSize U");
				button -l "V"     -h 20 -c ("NinjaUV_CalculateUVSize V");
			setParent..;//parent rowColumnLayout

		separator   -height 4 -width $NinjaUV_UIWidth;
			rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;

				if (`filetest -r ($MayaIconFolder + "NinjaUV_MoveArrowUp.xpm")` == 1)
				{
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowUPL.xpm") -c ("NinjaUV_MoveUV UP_Left UV_Move_AmountBar") ;
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowUP.xpm") -c ("NinjaUV_MoveUV UP UV_Move_AmountBar");
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowUPR.xpm") -c ("NinjaUV_MoveUV UP_Right UV_Move_AmountBar") ;
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowLeft.xpm") -c ("NinjaUV_MoveUV Left UV_Move_AmountBar");
					floatField  -v 1 UV_Move_AmountBar ;
					//iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_Blank.xpm")-c ("NinjaUV_MoveUV Zero") ;
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowRight.xpm") -c ("NinjaUV_MoveUV Right UV_Move_AmountBar");
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowDownL.xpm") -c ("NinjaUV_MoveUV Down_Left UV_Move_AmountBar");
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowDown.xpm") -c ("NinjaUV_MoveUV Down UV_Move_AmountBar");
					iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_MoveArrowDownR.xpm") -c ("NinjaUV_MoveUV Down_Right UV_Move_AmountBar");

                }

				else
				{
					button -label "Move Up left"    -annotation "Moves selected UV's Up and Left"      -h 24  -w 20 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_MoveUV UP_Left UV_Move_AmountBar");
					button -label "Move Up"         -annotation "Moves selected UV's UP"               -h 24  -w 40 -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -c ("NinjaUV_MoveUV UP UV_Move_AmountBar");
					button -label "Move Up right"   -annotation "Moves selected UV's Up and Right"     -h 24  -w 45 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_MoveUV UP_Right UV_Move_AmountBar");
					button -label "Move Left"       -annotation "Moves selected UV's Left"             -h 24  -w 45 -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -c ("NinjaUV_MoveUV Left UV_Move_AmountBar");
					floatField  -v 1 UV_Move_AmountBar ;
					//button -label "Move to Zero"    -annotation "Moves selected UV's to start at Zero" -h 24  -w 45 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_MoveUV Zero");
					button -label "Move Right"      -annotation "Moves selected UV's Right"            -h 24  -w 45 -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -c ("NinjaUV_MoveUV Right UV_Move_AmountBar");
					button -label "Move Down Left"  -annotation "Moves selected UV's Down and Left"    -h 24  -w 45 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_MoveUV Down_Left UV_Move_AmountBar");
					button -label "Move Down"       -annotation "Moves selected UV's Down"             -h 24  -w 45 -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -c ("NinjaUV_MoveUV Down UV_Move_AmountBar");
					button -label "Move Down Right" -annotation "Moves selected UV's Down and Right"   -h 24  -w 45 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c ("NinjaUV_MoveUV Down_Right UV_Move_AmountBar");
				}

			setParent..;
		setParent..;//parent columnLayout
	setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}

global proc string  Build_frame_UV_SnapUV()
{
	global string $MayaIconFolder;
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Snap UV-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Snap UV Shells" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_SnapUV;
			popupMenu;
				menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_SnapUV 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;

			radioButtonGrp -numberOfRadioButtons 2 -label "Snap Point" -labelArray2 "Extents" "Center"  -select 1 -columnWidth3 75  75 75 Snap_Point;

				if (`filetest -r ($MayaIconFolder + "NinjaUV_MoveArrowUp.xpm")` == 1)
				{
					rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Top Left Corner" -image1 ("NinjaUV_SnapTopL.xpm") -c ("NinjaUV_SetVToOne(); NinjaUV_SetUToZero()") ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Top Edge" -image1 ("NinjaUV_SnapTop.xpm")  -c ("NinjaUV_SetVToOne()");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Top Right Corner" -image1 ("NinjaUV_SnapTopR.xpm") -c ("NinjaUV_SetVToOne(); NinjaUV_SetUToOne()") ;

						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Left Edge" -image1 ("NinjaUV_SnapLeft.xpm") -c ("NinjaUV_SetUToZero()");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Center" -image1 ("NinjaUV_SnapCenter.xpm") -c ("NinjaUV_SetUVToMid") ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Right Edge" -image1 ("NinjaUV_SnapRight.xpm") -c ("NinjaUV_SetUToOne()");

						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Bottom Left Corner" -image1 ("NinjaUV_SnapBotL.xpm")  -c ("NinjaUV_SetVToZero(); NinjaUV_SetUToZero()");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Bottm Edge" -image1 ("NinjaUV_SnapBot.xpm")   -c ("NinjaUV_SetVToZero()");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's to Bottom Right Corner" -image1 ("NinjaUV_SnapBotR.xpm") -c ("NinjaUV_SetVToZero(); NinjaUV_SetUToOne()");


						iconTextButton -rpt 1  -h 24 -style "textOnly" -annotation "" -l "Relative (0-1)" -image1 ("NinjaUV_Blank.xpm")  -c "NinjaUV_ResetToZero";
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's Small to Large" -image1 ("NinjaUV_SnapSL.xpm")  -c ("Snap_Align " + "S");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -annotation "Snap selected UV's Large to Small" -image1 ("NinjaUV_SnapLS.xpm")  -c ("Snap_Align " + "L");
					setParent..;
                }

				else
				{
					rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
						button -label "Snap TL" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetVToOne(); NinjaUV_SetUToZero()");
						button -label "Snap V to 1" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "moves maximum extents of selected UV's to 1 on the V" -h 20 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetVToOne()");
						button -label "Snap TR" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetVToOne(); NinjaUV_SetUToOne()");
						button -label "Snap U to 0" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "moves lowest extents of selected UV's to 0 on the U" -h 20 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetUToZero()");
						button -label "Snap Mid"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's to start at Zero" -h 20  -w ($NinjaUV_UIWidth /3)-c ("NinjaUV_SetUVToMid");
						button -label "Snap U to 1" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "moves maximum extents of selected UV's to 1 on the U" -h 20 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetUToOne()");
						button -label "Snap BL" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_SetVToZero(); NinjaUV_SetUToZero()");
						button -label "Snap V to 0" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "moves lowest extents of selected UV's to 0 on the V" -h 20 -w 100 -c ("NinjaUV_SetVToZero()");
						button -label "Snap BR" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3)-c ("NinjaUV_SetVToZero(); NinjaUV_SetUToOne()");


						button -label "Relative (0-1)" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -w ($NinjaUV_UIWidth /3) -c "NinjaUV_ResetToZero";
						button -label "Snap  S-->L" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "snaps 2 shells together with 2 uv's selected" -h 25  -w ($NinjaUV_UIWidth /3) -c ("Snap_Align " + "S");
						button -label "Snap  L-->S" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "snaps 2 shells together with 2 uv's selected" -h 25  -w ($NinjaUV_UIWidth /3) -c ("Snap_Align " + "L");
					setParent..;
				}
					//button -label "Smart Snap Shells Across objects" -annotation "snaps shells together across objects based on shared edges" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 30 -w $NinjaUV_UIWidth  -c ("Smart_NinjaUV_AlignShells()");
			setParent..;//columnLayout
		setParent..;//frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc Build_frame_UV_MirrorUV()
{
	global float $NinjaUV_ButtonColorA[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Mirror UV's" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_MirrorUV;
		columnLayout;


			rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3) -cw 3 ($NinjaUV_UIWidth /3);
				button -label "Mirror - U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV -U");
				button -label "Mirror Center U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV CenterU");
				button -label "Mirror + U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV U");

				button -label "Mirror - V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV -V");
				button -label "Mirror Center V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV CenterV");
				button -label "Mirror + V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_MirrorUV V");
			setParent..;//parent rowColumnLayout

			separator   -height 4 -width $NinjaUV_UIWidth;
			button -l "Start Symmetry Mapping" -w $NinjaUV_UIWidth -bgc 0 1 0 -c ("NinjaUV_SymmetryStart") button_StartSymmetry;
		setParent..;//parent columnLayout
	setParent..;//parent frameLayout
}


global proc string  Build_frame_UV_AlignUV()
{
	global string $MayaIconFolder;
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Align UV-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Align UV Shells" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_AlignUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_AlignUV 1");
			columnLayout;
				if (`filetest -r ($MayaIconFolder + "NinjaUV_MoveArrowUp.xpm")` == 1)
				{
					rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_Blank.xpm")  ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignTop.xpm") -c ("NinjaUV_AlignShells Top");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_Blank.xpm")  ;

						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignLeft.xpm") -c ("NinjaUV_AlignShells Left");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignCen.xpm") -c ("NinjaUV_AlignShells Cen") ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignRight.xpm") -c ("NinjaUV_AlignShells Right");

						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignCenU.xpm")  -c ("NinjaUV_AlignShells CenU");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignBot.xpm")   -c ("NinjaUV_AlignShells Bot");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignCenV.xpm") -c ("NinjaUV_AlignShells CenV");

						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_Blank.xpm")  ;
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_AlignHorizontal.xpm") -c ("NinjaUV_AlignUVShellEdge Horizontal");
						iconTextButton -rpt 1  -h 24 -style "iconOnly" -image1 ("NinjaUV_Blank.xpm")  ;
					setParent..;//rowColumnLayout

                }


               else
				{
					rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
						button -label "" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's Up and Left" -h 20  -w ($NinjaUV_UIWidth /3)  ;//-c ("NinjaUV_AlignShells TopLeft");
						button -label "Align Top" -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "Moves selected UV's UP" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Top");
						button -label "" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's Up and Right" -h 20  -w ($NinjaUV_UIWidth /3) ; //-c ("NinjaUV_AlignShells Top_Right");
						button -label "Align Left"  -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "Moves selected UV's Left" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Left");
						button -label "Align Cen"  -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's to start at Zero" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Cen");
						button -label "Align Right"   -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "Moves selected UV's Right" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Right");
						button -label "Align Cen U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's Down and Left" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells CenU");
						button -label "Align Bottom"   -bgc $NinjaUV_ButtonColorB[0] $NinjaUV_ButtonColorB[1] $NinjaUV_ButtonColorB[2] -annotation "Moves selected UV's Down" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Bot");
						button -label "Align Cen V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Moves selected UV's Down and Right" -h 20  -w ($NinjaUV_UIWidth /3)-c ("NinjaUV_AlignShells CenV");
					setParent..;//rowColumnLayout
						button -label "Align Shell Edge Horizontal" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "snaps 2 shells together with 2 uv's selected" -h 25  -w $NinjaUV_UIWidth -c ("NinjaUV_AlignUVShellEdge Horizontal");
				}




				separator -height 4 -width $NinjaUV_UIWidth;
				progressBar -height 10 -width $NinjaUV_UIWidth -bgc 1 0 0 MatchUV_progress;
				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2);
					text "Tolerance";
					floatField -v .005 NinjaUV_MatchUVs_buffer;
				setParent..;

				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2);
					button -label "Store Target UV" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Store Match UV" -h 25  -w ($NinjaUV_UIWidth /2) -c ("StoreNinjaUV_MatchUVs");
					button -label "Clear Target UV" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Clear Match UV" -h 25  -w ($NinjaUV_UIWidth /2) -c ("ClearNinjaUV_MatchUVs");
				setParent..;

				button -label "Match UV" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Matches UV" -h 30  -w $NinjaUV_UIWidth -c ("NinjaUV_MatchUVs");


			setParent..;//columnLayout
		setParent..;//frameLayout -bs "etchedIn" align

	return $HelpText;
}

global proc string  Build_frame_UV_NinjaUV_ScaleUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];

	$HelpText = (
				"----------------------------------------------------Scale UV-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Scale and Normalize UV's"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_NinjaUV_ScaleUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_NinjaUV_ScaleUV 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;

				rowColumnLayout -nc 4 -cw 1 ($NinjaUV_UIWidth /4)  -cw 2 ($NinjaUV_UIWidth /4)  -cw 3 ($NinjaUV_UIWidth /4) -cw 4 ($NinjaUV_UIWidth /4) ;
					button -l ".125"  -h 20 -c ("floatField -e -v .125 UV_ScaleValue");
					button -l ".25"   -h 20 -c ("floatField -e -v .25 UV_ScaleValue");
					button -l ".5"    -h 20 -c ("floatField -e -v .5 UV_ScaleValue") ;
					button -l "2"     -h 20 -c ("floatField -e -v 2 UV_ScaleValue");
 				setParent..;//parent rowColumnLayout
				//separator   -height 4 -width $NinjaUV_UIWidth;

				radioButtonGrp  -numberOfRadioButtons 2 -label "Scale From:" -labelArray2 "Lower Left" "UV pivot" -select 1 -columnWidth3 80 80 70 UVScaleLocation ;
				rowLayout -nc 2  -columnWidth2 100 100;
					text "UV scale value" ;
					floatField -v 1 UV_ScaleValue;
					//text "VScale";
					//floatField -v 1  VScale;
				setParent..;
			//separator   -height 4 -width $NinjaUV_UIWidth;
				rowLayout -nc 3  -columnWidth3 ($NinjaUV_UIWidth /3) ($NinjaUV_UIWidth /3) ($NinjaUV_UIWidth /3) ;
					button -label "Scale U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]  -annotation "Scales selected UV's on the U" -h 25 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_ScaleUV " + "U") UScale;
					button -label "Scale V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]  -annotation "Scales selected UV's on the V" -h 25 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_ScaleUV " + "V") VScale;
					button -label "Scale UV" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]  -annotation "Scales selected UV's on the UV" -h 25 -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_ScaleUV " + "UV") UVScale;
				setParent..;

				separator   -height 4 -width $NinjaUV_UIWidth;

				rowColumnLayout -nc 4 -cw 1 ($NinjaUV_UIWidth /4)  -cw 2 ($NinjaUV_UIWidth /4)  -cw 3 ($NinjaUV_UIWidth /4) -cw 4 ($NinjaUV_UIWidth /4) ;
					button -l ".25" -h 20 -c ("floatField -e -v .25 Normalize_Scale");
					button -l ".5"  -h 20 -c ("floatField -e -v .5 Normalize_Scale");
					button -l "1"   -h 20 -c ("floatField -e -v 1 Normalize_Scale") ;
					button -l "2"   -h 20 -c ("floatField -e -v 2 Normalize_Scale");
 				setParent..;//parent rowColumnLayout

				rowLayout -nc 2 -columnWidth2 100 100;
					text "Normalize Scale";
					floatField -v 1 -w 100 Normalize_Scale;
				setParent..;

				rowLayout -nc 2 -columnWidth2 ($NinjaUV_UIWidth /2) ($NinjaUV_UIWidth /2);
					button -label "Normalize U" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Scales UV's propotionaly to fit from 0 - Normalize scale value on the U" -h 25 -w ($NinjaUV_UIWidth /2) -c ("NinjaUV_NormalizeU()");
					button -label "Normalize V" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Scales UV's propotionaly to fit from 0 - Normalize scale value on the V" -h 25 -w ($NinjaUV_UIWidth /2) -c ("NinjaUV_NormalizeV()");
				setParent..;


			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}


global proc string  Build_frame_UV_LayoutUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Layout UV-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Layout / Randomize Shells"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_LayoutUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_LayoutUV 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				rowColumnLayout -nc 2 -cw 1 125 -cw 2 125;
					text -l "Layout Padding";
					floatField -v 0.005 Layout_PaddingValue;
				setParent..;

				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2) -cw 2 ($NinjaUV_UIWidth /2);
						button -label "Layout Horizontal" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 25 -w ($NinjaUV_UIWidth /2) -c ("NinjaUV_ArrangeShells h");
						button -label "Layout Vertical" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 25 -w ($NinjaUV_UIWidth /2) -c ("NinjaUV_ArrangeShells v");

						rowColumnLayout -nc 2 -cw 1 75 -cw 2 45;
							text -l "Horz Grid Value";
							intField -v 0 LayoutGrid_HorizontalValue;
						setParent..;

						button -label "Layout Grid" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 25 -w ($NinjaUV_UIWidth /2) -c ("NinjaUV_ArrangeShells grid");
				setParent..;


				separator   -height 4 -width $NinjaUV_UIWidth;
				progressBar -height 10 -width $NinjaUV_UIWidth -bgc 1 0 0 RandomizeUV_progress;

					rowColumnLayout -nc 5 -cw 1 35 -cw 2 30 -cw 3 35 -cw 4 30 -cw 5 120;
						text -l "U Tiles";
						intField -v 1 RandTileU;
						text -l "V Tiles" ;
						intField -v 1 RandTileV;
						button -label "Tile Randomize UVs" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 25 -w 120 -c ("NinjaUV_RandomizeTileUVs");
					setParent..;


					rowColumnLayout -nc 5 -cw 1 35 -cw 2 30 -cw 3 35 -cw 4 30 -cw 5 125;
						text -l "Max U";
						floatField -v .1 -pre 2 RandMaxU;
						text -l "Max V" ;
						floatField -v .1 -pre 2 RandMaxV;
						button -label "Randomize UV Shells" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 25 -w 120 -c ("NinjaUV_RandomizeUVs");
					setParent..;


			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"
	return $HelpText;
}


global proc string  Build_frame_UV_SetsUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------UV Sets-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "UV Sets" -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_SetsUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_SetsUV 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				button -label "Get UV Sets" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Get UV Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_GetUVSets()");
				button -label "Add and Copy UV's to New UV Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Get UV Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_AddUVSets()");
				textField -text "map2" -w $NinjaUV_UIWidth NewUVSetName;
				separator   -height 4 -width $NinjaUV_UIWidth;
				button -label "Copy UV's to Existing UV Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Get UV Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_CopyUVSets()");
				rowColumnLayout -nc 4 -cw 1 25  -cw 2 100  -cw 3 25 -cw 4 100 ;
					text -l "From";
					textField -text "" -w $NinjaUV_UIWidth FromUVSetName;
					popupMenu;
						menuItem -l "Set From" -c("NinjaUV_SetFromToText From");
					text -l "To";
					textField -text "" -w $NinjaUV_UIWidth ToUVSetName;
					popupMenu;
						menuItem -l "Set To" -c("NinjaUV_SetFromToText To");
				setParent..;
				separator   -height 4 -width $NinjaUV_UIWidth;
				textScrollList -width $NinjaUV_UIWidth -h 100 -allowMultiSelection false  -sc ("NinjaUV_SetUVSets") UVSet_List;
				separator   -height 4 -width $NinjaUV_UIWidth;
				button -label "Delete UV Sets" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Get UV Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_DeleteUVSets()");
			setParent..;//columnLayout
		setParent..;//frameLayout -bs "etchedIn"
	return $HelpText;
}

global proc string  Build_frame_UV_SetsBake()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Bake Sets-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Bake Sets" -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_SetsBake;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_SetsBake 1");
			columnLayout;
				textScrollList -width $NinjaUV_UIWidth -h 100 -allowMultiSelection true  -sc ("NinjaUV_BakeSetSelectObjects") -dcc ("NinjaUV_BakeSetEdit") BakeSet_List;
					popupMenu;
						menuItem -label "Delete BakeSet" -c ("NinjaUV_BakeSetDelete()");
						menuItem -label "Refresh List" -c ("NinjaUV_BakeSetRefreshList()");
				rowColumnLayout -nc 2 -cw 1 200  -cw 2 50;
					textField -tx "NinjaBakeSet" -w $NinjaUV_UIWidth tf_BakeSetName;
					button -l "rename" -c ("NinjaUV_BakeSetRename");
				setParent..;
				button -label "Create New Bake Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Creates a new bake set" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_BakeSetsCreate()");

				rowColumnLayout -nc 3 -cw 1 50  -cw 2 50 -cw 3 100;
					checkBox -l "LM" cb_BakeSetLM;
					checkBox -l "AO" cb_BakeSetAO;
					checkBox -l "Combine PSD" cb_BakeSetPSD;
				setParent..;

				button -label "Bake Bake Sets" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Bakes out selected Bake Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_BakeSetsBakeIt()");
			setParent..;//columnLayout
		setParent..;//frameLayout -bs "etchedIn"
	NinjaUV_BakeSetRefreshList;
	return $HelpText;
}

global proc string  Build_frame_UV_BakeOptions()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Bake Options-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Bake Options"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_BakeOptions;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeOptions 1");
			columnLayout;
				$MayaLocation = `internalVar -uad`;

				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth/2)  -cw 2 ($NinjaUV_UIWidth/2) ;
					button -l "Default Texture Path" -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_BakeDefaultTextureName");
					button -l "Match Texture Path"   -w ($NinjaUV_UIWidth/2) -c ("NinjaUV_BakeMatchTextureName");
				setParent..;

				textField -w $NinjaUV_UIWidth -text ($MayaLocation + "NinjaDojo/NinjaBake/") "Bake_Path";
				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2) -cw 2 ($NinjaUV_UIWidth /2) ;
					text -l "output file name";
					textField -w $NinjaUV_UIWidth -text "NinjaBake" BakeName;
				setParent..;

				radioButtonGrp  -numberOfRadioButtons 4  -label "Format" -labelArray4  "bmp" "tga" "tif" "jpg" -select 2 -columnWidth5 55 45 45 45 45 TexOutput_Format;
				radioButtonGrp  -numberOfRadioButtons 4 -label "samples" -labelArray4 "1x1" "2x2" "3x3" "4x4" -select 1 -columnWidth5 50 50 50 50 50 BakeSamples ;

				separator   -height 4 -width $NinjaUV_UIWidth;
				rowColumnLayout -nc 5 -cw 1 ($NinjaUV_UIWidth /5)  -cw 2 ($NinjaUV_UIWidth /5)  -cw 3 ($NinjaUV_UIWidth /5) -cw 4 ($NinjaUV_UIWidth /5) -cw 5 ($NinjaUV_UIWidth /5);
						button -l "128"  -h 20 -c ("intField -e -v 128 NinjaUV_BakeAO_Width; intField -e -v 128 NinjaUV_BakeAO_Height ");
						button -l "256"  -h 20 -c ("intField -e -v 256 NinjaUV_BakeAO_Width; intField -e -v 256 NinjaUV_BakeAO_Height ");
						button -l "512"  -h 20 -c ("intField -e -v 512 NinjaUV_BakeAO_Width; intField -e -v 512 NinjaUV_BakeAO_Height ");
						button -l "1024" -h 20 -c ("intField -e -v 1024 NinjaUV_BakeAO_Width; intField -e -v 1024 NinjaUV_BakeAO_Height ");
						button -l "2048" -h 20 -c ("intField -e -v 2048 NinjaUV_BakeAO_Width; intField -e -v 2048 NinjaUV_BakeAO_Height ");
					setParent..;//parent rowColumnLayout
				separator   -height 4 -width $NinjaUV_UIWidth;
				button -l "Match Texture Size" -w $NinjaUV_UIWidth -c ("NinjaUV_BakeMatchTextureSize");
				rowLayout -nc 4 -columnWidth4 50 50 50 50;
					text -l "Width" ;
					intField -v 1024 NinjaUV_BakeAO_Width;
					text -l "Height" ;
					intField -v 1024 NinjaUV_BakeAO_Height;
				setParent..;

				rowColumnLayout -nc 2 -cw 1 85  -cw 2 125 ;
					text -l "UV Set Name:";
					textField -tx "map1" BakeUVSet;
				setParent..;


				rowColumnLayout -nc 2 -cw 1 180  -cw 2 72 ;
					rowColumnLayout -nc 4 -cw 1 40  -cw 2 50 -cw 3 40 -cw 4 50 ;
						text -l "U min";
						floatField -v 0 bake_Umin;
						text -l "U max";
						floatField -v 1 bake_Umax;
						text -l "V min";
						floatField -v 0 bake_Vmin;
						text -l "V max";
						floatField -v 1 bake_Vmax;
					setParent..;

					rowColumnLayout -nc 3 -cw 1 24  -cw 2 24 -cw 3 24;
						button -l "1,3" -w 24 -h 20 -c "NinjaUV_SetBakeZone 1 3";
						button -l "2,3" -w 24 -h 20 -c "NinjaUV_SetBakeZone 2 3";
						button -l "3,3" -w 24 -h 20 -c "NinjaUV_SetBakeZone 3 3";

						button -l "1,2" -w 24 -h 20 -c "NinjaUV_SetBakeZone 1 2";
						button -l "2,2" -w 24 -h 20 -c "NinjaUV_SetBakeZone 2 2";
						button -l "3,2" -w 24 -h 20 -c "NinjaUV_SetBakeZone 3 2";

						button -l "1,1" -w 24 -h 20 -c "NinjaUV_SetBakeZone 1 1";
						button -l "2,1" -w 24 -h 20 -c "NinjaUV_SetBakeZone 2 1";
						button -l "3,1" -w 24 -h 20 -c "NinjaUV_SetBakeZone 3 1";
					setParent..;
				setParent..;

			setParent..;
		setParent..;
	return $HelpText;
}

global proc string  Build_frame_UV_BakePreview()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Bake Preview-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Bake Preview"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_BakePreview;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakePreview 1");
			columnLayout;
				image  -w 250 -h 250 -i "polySphere.xpm" Image_NinjaBakePreview;
				rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2) -cw 2 ($NinjaUV_UIWidth /2) ;
					button -l "Open Texture" -w ($NinjaUV_UIWidth /2) -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("NinjaUV_ViewAOMap");
					button -l "Explore Texture" -w ($NinjaUV_UIWidth /2) -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("Explore_AO_Map");
				setParent..;

			setParent..;
		setParent..;
	return $HelpText;
}



global proc string  Build_frame_UV_BakeAO()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Ambient/Occlusion Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Ambient/Occlusion Map"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeAO;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeAO 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				//checkBox -l "Force Lambert Shader" cb_ForceLambert;

				//$Rays = `getAttr "OcclusionBakeSet.occlusionRays"`;
				//$Falloff = `getAttr "OcclusionBakeSet.occlusionFalloff"`;
				rowColumnLayout -nc 2 -cw 1 150  -cw 2 60;
					text -l "Occlusion Rays: "  -al "left";
					intField -v 256 Ninja_OcclusionRays ;
					text -l "Occlusion Falloff: "  -al "left";
					floatField -v 200 Ninja_OcclusionFalloff;
					text -l "Fill Texture Seams" -al "left";
					floatField -v 2.0 Ninja_OcclusionTextureSeams;

				setParent..;
				colorSliderGrp -label "BackGroundColor" -cw3 85 50 100 -h 20 -rgb 1 1 1  AO_BackgroundColor;
				checkBox -l "Assign AO Material to selected Objects" -v 0 cb_Assign_AOTexture;
				button -l "Bake AO" -w $NinjaUV_UIWidth -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]-c("NinjaUV_Bake_AO");
				button -w $NinjaUV_UIWidth -l "Edit AO Bake Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("NinjaUV_Edit_AO_Bakeset()");
				//button -w $NinjaUV_UIWidth -l "Preview on Mesh" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("Preview_AO_Mesh()");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeLM()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Light Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Light Map"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeLM;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeLM 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Calculate Shadows" Ninja_cbBakeShadows;
				checkBox -l "Assign LightMap Material to selected Objects" -v 0 cb_Assign_LMTexture;
				button -l "Bake Light Map" -w $NinjaUV_UIWidth -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]-c("NinjaUV_Bake_LM");
				button -w $NinjaUV_UIWidth -l "Edit Light Map Bake Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]-c("NinjaUV_Edit_LM_Bakeset");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}


global proc string  Build_frame_UV_BakeUV()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------UV Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "UV Map"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeUV;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeUV 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Assign UV Material to selected Objects" -v 0 cb_Assign_UVTexture;
				button -l "Bake UV" -w $NinjaUV_UIWidth -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2]-c("NinjaUV_Bake_UV");
				setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeColor()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Color Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Color Bake"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeColor;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeColor 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Assign Color Material to selected Objects" -v 0 cb_Assign_ColorTexture;

				rowColumnLayout -nc 2 -cw 1 125  -cw 2 125 ;
					text -l "overscan/padding";
					intField -v 2 ColorBake_OverScan;
				setParent..;

				button -label "Bake Light/Color" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_Color");
				button -label "Edit Color Bake Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Edit_Color_Bakeset");
				button -label "Bake Color Flat" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_ColorFlat");

			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeUVShellColor()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"---------------------------------------------------- UV Shell Color -------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "UV Shell Color"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeUVShellColor;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeColor 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Assign Random Colors" -v 0 cb_Assign_RandomColors;
				//button -label "Assign Random Shaders to UV Shells" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_RandomUVShellsShaders");
				//button -label "Bake Light/Color" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_Color");
				colorSliderGrp -label "Shell Color" -cw3 85 50 100 -h 20 -rgb .5 .5 .5  UV_ShellColor;
				button -label "Bake UV Shell Colors" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_UVShellColor");
				//button -label "Edit Color Bake Set" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Edit_Color_Bakeset");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string Build_frame_UV_TextureAtlas()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
		$HelpText = (
				"----------------------------------------------------Texture Atlas-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Texture Atlas"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_TextureAtlas;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeColor 1");
			columnLayout;
					//checkBox -l "Bake Texture" -v 1 AtlasBakeTexture;
					text -l "Progress" AtlasProgressText;
					rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2)  ;
						checkBox -l "Group" -v 1 Atlas_Group;
						checkBox -l "Duplicate" -v 1 Atlas_Duplicate;
					setParent..;
					//checkBox -l "Overlap Similar Object Names" -v 1 Atlas_Overlap;
					button -label "Layout and Bake UV Atlas" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 24 -w ($NinjaUV_UIWidth) -c ("NinjaUV_TextureAtlas");

			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string Build_frame_UV_BakeScreenTiles()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
		$HelpText = (
				"----------------------------------------------------Texture Atlas-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Screen Tiles"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeScreenTiles;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeScreenTiles 1");
			columnLayout;
					rowColumnLayout -nc 2 -cw 1 ($NinjaUV_UIWidth /2)  -cw 2 ($NinjaUV_UIWidth /2) ;
						text "Tile Resolution";
						intField -v 800 IF_BakeScreenTileRes;
						text "Number of Tiles";
						intField -v 5 IF_BakeScreenTiles;

					setParent..;
					button -label "Bake Screen Tiles" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "" -h 24 -w ($NinjaUV_UIWidth) -c ("NinjaUV_Bake_ScreenTiles");

			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_CombineBake()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Transfer Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Combine Bake"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_CombineBake;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeColor 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Overlap Similar Shells" -v 0 cb_CombineOverlapShells;
				checkBox -l "Rescale UV's" -v 0 cb_CombineReNinjaUV_ScaleUV;
				checkBox -l "Combine Objects" -v 0 cb_CombineCombine;
				button -label "Combine Bake" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_Combine");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeChecker()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Checker Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Checker Texture"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakeChecker;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeChecker 1");
			columnLayout;
				//separator   -height 4 -width $NinjaUV_UIWidth;
				checkBox -l "Assign Checker Material to selected Objects" -v 0 cb_Assign_CheckerTexture;
				button -label "Bake Checker Texture" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_Checker");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeObject()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Object Bake-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Object Bake"  -width $NinjaUV_FrameWidth -cl true -cll true frame_UV_BakePlanar;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakePlanar 1");
			columnLayout;
				radioButtonGrp  -numberOfRadioButtons 2  -label "" -labelArray2  "Plane" "Custom" -select 1 -columnWidth3 1 100 100  ObjectBakeTarget;
					rowColumnLayout -nc 2 -cw 1 200 -cw 2 50;
						textField ObjectBake_TargetName;
						button -l "store" -c "NinjaUV_Bake_StoreObject";
					setParent..;
				button -label "Bake Object to Texture" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -h 24 -w $NinjaUV_UIWidth -c ("NinjaUV_Bake_Object");
			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}

global proc string  Build_frame_UV_BakeMulti()
{
	global float $NinjaUV_ButtonColorA[];
	global float $NinjaUV_ButtonColorB[];
	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	global float $NinjaUV_FrameColor[];
	$HelpText = (
				"----------------------------------------------------Multi Map-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Ninja Multi Bake"  -width $NinjaUV_FrameWidth -cl false -cll true frame_UV_BakeMulti;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeMulti 1");
			columnLayout;
				//Bake Sets

				rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
					checkBox -l "AO" -v 0 cb_Multi_AO;
					checkBox -l "LM" -v 0 cb_Multi_LM;
					checkBox -l "UV" -v 0 cb_Multi_UV;
					checkBox -l "Color" -v 0 cb_Multi_Color;
					checkBox -l "Shell Colors" -v 0 cb_Multi_ShellColors;
					//checkBox -l "Combine" -v 0 cb_Multi_Combine;
					checkBox -l "Checker" -v 0 cb_Multi_Checker;
				setParent..;

				checkBox -l "Assign PSD Material to selected Objects" -v 0 cb_Assign_PSDTexture;
					//checkBox -l "Auto Set UV Range (Batch Bake)" -v 1 cb_AutoSetUVRange;
				checkBox -l "Open PSD After Bake" -v 1 cb_Open_PSDTexture;
      			button -l "Multi Bake selected objects" -w $NinjaUV_UIWidth -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("NinjaUV_Bake_MultiBake");
				button -l "Multi Bake Range Bake" -w $NinjaUV_UIWidth -h 24 -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -c("NinjaUV_Bake_Range");

				textScrollList -width $NinjaUV_UIWidth -h 100 -allowMultiSelection true  -sc ("NinjaUV_BakeSetSelectObjects") -dcc ("NinjaUV_BakeSetEdit") BakeSet_List;
				popupMenu;
					menuItem -label "add to BakeSet" -c ("NinjaUV_BakeSetAdd()");
					menuItem -label "Delete BakeSet" -c ("NinjaUV_BakeSetDelete()");
					menuItem -label "Refresh List" -c ("NinjaUV_BakeSetRefreshList()");

				rowColumnLayout -nc 3 -cw 1 50  -cw 2 150 -cw 3 50;
					button -label "New"  -annotation "Creates a new bake set" -h 25 -w 50-c ("NinjaUV_BakeSetsCreate()");
					textField -tx "NinjaBakeSet" -w $NinjaUV_UIWidth tf_BakeSetName;
					button -l "rename" -c ("NinjaUV_BakeSetRename");
				setParent..;

				button -label "Bake Selected Bake Sets" -bgc $NinjaUV_ButtonColorA[0] $NinjaUV_ButtonColorA[1] $NinjaUV_ButtonColorA[2] -annotation "Bakes out selected Bake Sets" -h 25 -w $NinjaUV_UIWidth -c ("NinjaUV_BakeSetsBakeIt");

			setParent..;//parent columnLayout
		setParent..;//parent frameLayout -bs "etchedIn"

	return $HelpText;
}


global proc Build_frame_UV_CreateProjection()

{
	$NinjaProjection_UIWidth = 250;
	$NinjaProjection_FrameWidth = 255;
	global float $NinjaUV_FrameColor[];

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Create"  -width $NinjaProjection_FrameWidth -cl false -cll true frame_UV_ProjectionCreate;
		columnLayout;
			//separator   -height 4 -width $NinjaProjection_UIWidth;

			button -l "Create New Camera" -w $NinjaProjection_UIWidth -h 30 -c ("NinjaProjection_CreateCamera");

				rowColumnLayout -nc 2 -cw 1 125  -cw 2 125 ;
					text -l "Camera Name: ";
					textField -w 125 -tx "PCam" Ninja_pCamName;
				setParent..;
				separator   -height 4 -width $NinjaProjection_UIWidth;
		setParent..;
	setParent..;
}


global proc Build_frame_UV_ProjectionList()
{
	$NinjaProjection_UIWidth = 250;
	$NinjaProjection_FrameWidth = 255;
	global float $NinjaUV_FrameColor[];


	$HelpText = (
				"----------------------------------------------------Projection Mappping-------------------------------------------------*\n"+
				"\n"
				);
		frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Camera Projection List"  -width $NinjaProjection_FrameWidth -cl false -cll true frame_UV_ProjectionList;
		popupMenu;
			menuItem -l "Interactuve Help" -c ("Build_NinjaHelpTopic frame_UV_BakeMulti 1");
			columnLayout;

				columnLayout ;
					textScrollList -w 240 -h 100 -sc ("NinjaProjection_BuildCameraEdit; " + "NinjaProjection_BuildCameraAttr()" ) -dcc ("NinjaProjection_SelectCam") sceneCameraList;
					//textScrollList -w 240 -h 100 -sc ("NinjaProjection_BuildCameraEdit; " ) -dcc ("NinjaProjection_SelectCam") sceneCameraList;
						popupMenu;
							menuItem -l "Refresh List" -c ("NinjaProjection_RefreshCameraList");
							menuItem -l "Delete Camera" -c ("NinjaProjection_DeleteCam");
				setParent..;//columnLayout

				columnLayout -w 250 CameraUI_Parent;
					columnLayout ;
					setParent..;//columnLayout
				setParent..;//columnLayout

			setParent..;//columnLayout
		setParent..;//frameLayout
}


global proc Build_frame_UV_CameraAttributes()
{
	global float $NinjaUV_FrameColor[];
	$NinjaProjection_UIWidth = 250;
	$NinjaProjection_FrameWidth = 255;


	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Camera Attributes" -width $NinjaProjection_FrameWidth -cl false -cll true frame_UV_CameraAttributes;
		columnLayout CameraAttributeParent;
			columnLayout -w $NinjaProjection_UIWidth -h 250 ;
				columnLayout;
					text -l "nothing selected";
				setParent..;//columnLayout
			setParent..;//parent scrollLayout
		setParent..;//columnLayout
	setParent..;//frameLayout

	//scrollLayout -e -h 250 CameraAttributeList;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////UI

global proc Build_frame_UV_MaterialTools()
{
	global int $NinjaUV_UIWidth;
	global float $NinjaUV_FrameColor[];

	frameLayout -bgc $NinjaUV_FrameColor[0] $NinjaUV_FrameColor[1] $NinjaUV_FrameColor[2] -bs "etchedIn" -label "Material Tools" -width ($NinjaUV_UIWidth + 5) -cl false -cll true frame_UV_MaterialTools;
		columnLayout CameraAttributeParent;
			button -l "Match Material" -w $NinjaUV_UIWidth;
		setParent..;
	setParent..;
}

global proc Build_Ninja_UV_UI(int $UseScroll)

{

	float $mayaVersion = `getApplicationVersionAsFloat` ;

	global int $NinjaUV_UIWidth;
	global int $NinjaUV_FrameWidth;
	int $SeperatorHeight = 4;
	int $SeperatorColor[] = {1, 1, 1} ;


	if ($mayaVersion == 2011)
	{
		$SeperatorColor = {0, 0, 0} ;
	}

	else
	{
		$SeperatorColor = {1, 1, 1} ;
    }

Build_Ninja_UV_Menu();

	if ($UseScroll == 1)
	{
		scrollLayout -hst 0;//remove for Ninja_UV_tools
    }
			columnLayout;
				rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth/3)  -cw 2 ($NinjaUV_UIWidth/3) -cw 3 ($NinjaUV_UIWidth/3) ;
						button -l "Hyper Shade" -w 75 -h 16 -c("HypershadeWindow");
						button -l "UV Editor"	-w 75 -h 16 -c ("NinjaUV_UVEditor");
						button -l "UV Sets"	    -w 75 -h 16 -c ("uvSetEditor");
				setParent..;

				button -label "Toggle Isolate Selected UV's"  -annotation "isolates uvs" -w $NinjaUV_UIWidth -h 16 -c ("NinjaUV_IsolateUVs");

				//////////////////////////Tabs
				string $NinjaUV_Tabs = `tabLayout -width 260 -innerMarginWidth 0 -innerMarginHeight 0`;

					//////////////////////////TAB Create UV
					string $tab_UV_Create = `columnLayout MapParent`;
						Build_frame_UV_PixelRatio;
						Build_frame_UV_UnfoldOptions;
						Build_frame_UV_CutEdges;
						Build_frame_UV_NinjaMapping;
						Build_frame_UV_QuickFixUV;
						Build_frame_UV_AdjustUV;
						Build_frame_UV_StraightenUV MapParent;
					setParent..;//parent tab

					//////////////////////////////////////TAB Edit UV
					string $tab_UV_Edit = `columnLayout EditUV`;
						Build_frame_UV_MoveUV EditUV;
						Build_frame_UV_SnapUV;
						Build_frame_UV_AlignUV;
						Build_frame_UV_MirrorUV;
						Build_frame_UV_NinjaUV_ScaleUV;
						Build_frame_UV_LayoutUV;
					setParent..;//parent Edit UV tab


					//////////////////////////////////////TAB UV Sets
					string $tab_UV_Sets = `columnLayout Sets`;
						Build_frame_UV_SetsUV;
					setParent..; //End UV Sets Tab

					//////////////////////////////////////TAB BAKE UV
					string $tab_Bake_Maps = `columnLayout Bake`;
						Build_frame_UV_BakeOptions;
						Build_frame_UV_BakePreview;
						Build_frame_UV_BakeMulti;
						//Build_frame_UV_SetsBake;
						Build_frame_UV_BakeAO;
						Build_frame_UV_BakeLM;
						Build_frame_UV_BakeUV;
						Build_frame_UV_BakeColor;
						Build_frame_UV_BakeUVShellColor;
						Build_frame_UV_CombineBake;
						Build_frame_UV_BakeChecker;
						Build_frame_UV_BakeObject;
						Build_frame_UV_TextureAtlas;
						//Build_frame_UV_BakeScreenTiles;
					setParent..; //parent bake maps tab

					//////////////////////////////////////TAB Material
					//string $tab_Material = `columnLayout Mat`;
					//	Build_frame_UV_MaterialTools;
					//setParent..;

					//////////////////////////////////////TAB BAKE Pmap
					string $tab_Projection = `columnLayout PMap`;
						Build_frame_UV_CreateProjection;
						Build_frame_UV_ProjectionList;
						Build_frame_UV_CameraAttributes;
					setParent..;

					NinjaProjection_RefreshCameraList;
					string $SelCameraList[] = `textScrollList -q -ai sceneCameraList`;
					textScrollList -e -si $SelCameraList[0] sceneCameraList;
					NinjaProjection_BuildCameraEdit;
					NinjaProjection_BuildCameraAttr;

			setParent..;//parent tablayout
		setParent..;//parent columnLayout

if ($UseScroll == 1)
	{
	setParent..;//parent scrollLayout //remove for Ninja_UV_tools
    }

tabLayout -edit
	-tabLabel $tab_UV_Create "Map"
	-tabLabel $tab_UV_Edit "Edit"
	$NinjaUV_Tabs;

NinjaUV_SetPixelRatio();
//mentalRayLoad;
if( !`exists doMenuComponentSelection` ) eval( "source dagMenuProc" );// load doMenuComponetSelection

}

global proc NinjaUV_UVEditor()
{
	global string $NinjaUV_Version;
	global int $NinjaUV_UIWidth;
	if (`window -ex polyTexturePlacementPanel1Window`)
	{
		deleteUI polyTexturePlacementPanel1Window;
    }

	if ((`window -ex Ninja_UVEditor_UI`) == true) deleteUI Ninja_UVEditor_UI;
	$Ninja_UV_Window = `window -title $NinjaUV_Version -width 200 Ninja_UVEditor_UI`;

	paneLayout -configuration "vertical2" -paneSize 1 25 75;
		scrollLayout;
			columnLayout UVWindow_Parent;
				Build_frame_UV_MoveUV UVWindow_Parent;
				Build_frame_UV_SnapUV;
				Build_frame_UV_AlignUV;
				Build_frame_UV_StraightenUV UVWindow_Parent;
				Build_frame_UV_QuickFixUV;
				Build_frame_UV_AdjustUV;
			setParent..;
		setParent..;


		string $NinjaUVPane = `paneLayout -configuration "single"`;
			//$Ninja_UVPanel = `modelPanel`;
		setParent..; //Parent paneLayout

	setParent..;
	showWindow Ninja_UVEditor_UI;
	$Ninja_UVPanel = `modelPanel -p $NinjaUVPane`;
	scriptedPanel -e -rp $Ninja_UVPanel polyTexturePlacementPanel1;
}

global proc NinjaUV_UVEditorXXX()
{
	global int $NinjaUV_UIWidth;
	if (`window -ex polyTexturePlacementPanel1Window`)
	{
		deleteUI polyTexturePlacementPanel1Window;
    }

	TextureViewWindow;


	paneLayout -p polyTexturePlacementPanel1;
		rowLayout -nc 5  ;

			//first Row
			rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
				button -label "Move Up left"    -annotation "Moves selected UV's Up and Left"      -h 20  -w 20  -c ("NinjaUV_MoveUV UP_Left UV_Move_Amount_UVEditor");
				button -label "Move Up"         -annotation "Moves selected UV's UP"               -h 20  -w 40  -c ("NinjaUV_MoveUV UP UV_Move_Amount_UVEditor");
				button -label "Move Up right"   -annotation "Moves selected UV's Up and Right"     -h 20  -w 45  -c ("NinjaUV_MoveUV UP_Right UV_Move_Amount_UVEditor");
				button -label "Move Left"       -annotation "Moves selected UV's Left"             -h 20  -w 45  -c ("NinjaUV_MoveUV Left UV_Move_Amount_UVEditor");

				floatField  -v 1 UV_Move_Amount_UVEditor;

				button -label "Move Right"      -annotation "Moves selected UV's Right"            -h 20  -w 45  -c ("NinjaUV_MoveUV Right UV_Move_Amount_UVEditor");
				button -label "Move Down Left"  -annotation "Moves selected UV's Down and Left"    -h 20  -w 45 -c ("NinjaUV_MoveUV Down_Left UV_Move_Amount_UVEditor");
				button -label "Move Down"       -annotation "Moves selected UV's Down"             -h 20  -w 45  -c ("NinjaUV_MoveUV Down UV_Move_Amount_UVEditor");
				button -label "Move Down Right" -annotation "Moves selected UV's Down and Right"   -h 20  -w 45  -c ("NinjaUV_MoveUV Down_Right UV_Move_Amount_UVEditor");
			setParent..;

			//second Row
			rowColumnLayout -nc 3 -cw 1 ($NinjaUV_UIWidth /3)  -cw 2 ($NinjaUV_UIWidth /3)  -cw 3 ($NinjaUV_UIWidth /3) ;
				button -label ""  -annotation "Moves selected UV's Up and Left" -h 20  -w ($NinjaUV_UIWidth /3)  ;//-c ("NinjaUV_AlignShells TopLeft");
				button -label "Align Top"  -annotation "Moves selected UV's UP" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Top");
				button -label ""  -annotation "Moves selected UV's Up and Right" -h 20  -w ($NinjaUV_UIWidth /3) ; //-c ("NinjaUV_AlignShells Top_Right");
				button -label "Align Left"  -annotation "Moves selected UV's Left" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Left");
				button -label "Align Cen"   -annotation "Moves selected UV's to start at Zero" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Cen");
				button -label "Align Right"   -annotation "Moves selected UV's Right" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Right");
				button -label "Align Cen U" -annotation "Moves selected UV's Down and Left" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells CenU");
				button -label "Align Bottom"   -annotation "Moves selected UV's Down" -h 20  -w ($NinjaUV_UIWidth /3) -c ("NinjaUV_AlignShells Bot");
				button -label "Align Cen V"  -annotation "Moves selected UV's Down and Right" -h 20  -w ($NinjaUV_UIWidth /3)-c ("NinjaUV_AlignShells CenV");
			setParent..;//rowColumnLayout

			//third row
			columnLayout;
				button -label "Quick Fix UV"  -annotation "Fixes Distored Textures"  -w 100 -h 20 -c ("NinjaUV_QuickFix()");
				button -label "Quick Fix U"  -annotation "Fixes Distored Textures"  -w 100 -h 20 -c ("Unfold_Selected U");
				button -label "Quick Fix V"  -annotation "Fixes Distored Textures"  -w 100 -h 20 -c ("Unfold_Selected V");
			setParent..;//rowColumnLayout

			//fourth row
			columnLayout;
				button -label "Straighten Both" -annotation "straigtens selected UV Shells" -w 120 -h 20   	-c ("NinjaUV_StraightenUVSelection Both");
				button -label "Straighten Horz" -annotation "straigtens selected edges" -w 120  -h 20  	-c ("NinjaUV_StraightenUVSelection Horizontal");
				button -label "Straighten Vert"  -annotation "snaps 2 shells together with 2 uv's selected" -h 20  -w 120 -c ("NinjaUV_StraightenUVSelection Vertical");
			setParent..;//rowColumnLayout
			columnLayout;

			setParent..;//rowColumnLayout

		setParent..;
	setParent..;

}

global proc Ninja_UV()
{
	global float $NinjaUV_FrameColor[];
	global string $NinjaUV_Version;
	float $mayaVersion = `getApplicationVersionAsFloat` ;
	if ($mayaVersion <= 2010)
	{
		$NinjaUV_FrameColor = {.95, .95, .95};

	}

	if ($mayaVersion >= 2011)
	{
		if ((`dockControl -ex Ninja_UV_Dock`) == true) deleteUI Ninja_UV_Dock;
		Ninja_UVDock;
    }

	else
	{
		Ninja_UVBar;
	}
}//end quickmapper UI

global proc NinjaUV_SplitLayout()
{

	string $uvTextureViews[] = `getPanel -scriptType "polyTexturePlacementPanel"`;

	setNamedPanelLayout "Persp/Outliner";
	scriptedPanel -edit -replacePanel outlinerPanel1 $uvTextureViews[0];
}

global proc Ninja_UVBar()
{

	global string $NinjaUV_Version;
	float $mayaVersion = `getApplicationVersionAsFloat` ;

	float $mayaVersion = `getApplicationVersionAsFloat` ;
	if ($mayaVersion >= 2011)
	{
		if ((`dockControl -ex Ninja_UV_Dock`) == true) deleteUI Ninja_UV_Dock;

    }

	if ((`window -ex Ninja_UV_UI`) == true) deleteUI Ninja_UV_UI;
	$Ninja_UV_Window = `window -title $NinjaUV_Version -width 280 Ninja_UV_UI`;

	Build_Ninja_UV_UI 1;

	showWindow Ninja_UV_UI;
	window -e -w 300 Ninja_UV_UI;
		//TextureViewWindow;
}

global proc Ninja_UVDock()
{

	global string $NinjaUV_Version;
	float $mayaVersion = `getApplicationVersionAsFloat` ;

	if ($mayaVersion >= 2011)
	{
		if ((`window -ex Ninja_UV_UI`) == true) deleteUI  Ninja_UV_UI;
		$Ninja_Mesh_UI =`window -title "Ninja UV" Ninja_UV_UI`;

		if ((`dockControl -ex Ninja_UV_Dock`) == true) deleteUI Ninja_UV_Dock;

		Build_Ninja_UV_UI 1;

		dockControl  -area "right" -allowedArea "right" -label $NinjaUV_Version -w 300 -content Ninja_UV_UI Ninja_UV_Dock ;

    }

}

global proc Ninja_UV_UI()
{

	global string $NinjaUV_Version;
	if ((`window -ex Ninja_UV_UI`) == true) deleteUI Ninja_UV_UI;
	$Ninja_UV_Window = `window -title $NinjaUV_Version -width 200 Ninja_UV_UI`;

		Build_Ninja_UV_UI 1;

	showWindow Ninja_UV_UI;
	window -e -w 300 Ninja_UV_UI;
	TextureViewWindow;

}//end quickmapper UI

global proc NinjaUV_UVMode()
{
	global string $NinjaUV_Version;
	float $mayaVersion = `getApplicationVersionAsFloat` ;
	if ($mayaVersion >= 2011)
	{
		if ((`dockControl -ex Ninja_UV_Dock`) == true) deleteUI Ninja_UV_Dock;

    }

	if ((`window -ex Ninja_UV_UI`) == true) deleteUI Ninja_UV_UI;
	$Ninja_UV_Window = `window -title $NinjaUV_Version -width 200 Ninja_UV_UI`;

	$allWindows = `lsUI -windows`;

	for ($window in $allWindows)
	{
		if ($window == "polyTexturePlacementPanel1Window")
		{
			 deleteUI $window;
		}
	}

	paneLayout -configuration "vertical2" -paneSize 1 80 20;



		string $NinjaUVPane = `paneLayout -configuration "single"`;
		setParent..; //Parent paneLayout

		Build_Ninja_UV_UI 1;

	setParent..;//parent paneLayout

	showWindow Ninja_UV_UI;

	$Ninja_UVPanel = `modelPanel -p $NinjaUVPane`;
	scriptedPanel -e -rp $Ninja_UVPanel polyTexturePlacementPanel1;
}


global proc Ninja_UVFull()
{
	global string $NinjaUV_Version;
	float $mayaVersion = `getApplicationVersionAsFloat` ;

	if ($mayaVersion >= 2011)
	{
		if ((`dockControl -ex Ninja_UV_Dock`) == true) deleteUI Ninja_UV_Dock;

    }


	if ((`window -ex Ninja_UV_UI`) == true) deleteUI Ninja_UV_UI;
	$Ninja_UV_Window = `window -title $NinjaUV_Version -width 200 Ninja_UV_UI`;

	$allWindows = `lsUI -windows`;

	for ($window in $allWindows)
	{
		if ($window == "polyTexturePlacementPanel1Window")
		{
			 deleteUI $window;
		}
	}

	paneLayout -configuration "vertical3" -paneSize 1 50 50 ;

		$NinjaUV_PerspPanel = `modelPanel`;
		setParent..;

		$Ninja_UVPanel = `modelPanel`;
		setParent..;

		Build_Ninja_UV_UI 1;

	setParent..;


	showWindow Ninja_UV_UI;
	window -e -w 1000 Ninja_UV_UI;
	lookThroughModelPanel persp $NinjaUV_PerspPanel;
	scriptedPanel -e -rp $Ninja_UVPanel polyTexturePlacementPanel1;
}

